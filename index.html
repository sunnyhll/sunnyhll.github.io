<!DOCTYPE html>












  


<html class="theme-next muse use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.5.0" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.5.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.5.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.5.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.5.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '6.5.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta property="og:type" content="website">
<meta property="og:title" content="微观天下">
<meta property="og:url" content="https://sunnyhll.github.io/index.html">
<meta property="og:site_name" content="微观天下">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="微观天下">






  <link rel="canonical" href="https://sunnyhll.github.io/">



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>微观天下</title>
  











  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">微观天下</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home menu-item-active">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sunnyhll.github.io/2020/12/07/Java-Questions-and-Answers/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="果核&肉肉">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="微观天下">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/12/07/Java-Questions-and-Answers/" class="post-title-link" itemprop="https://sunnyhll.github.io/index.html">Java Questions and Answers</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-12-07 11:02:21" itemprop="dateCreated datePublished" datetime="2020-12-07T11:02:21+08:00">2020-12-07</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-12-09 13:29:26" itemprop="dateModified" datetime="2020-12-09T13:29:26+08:00">2020-12-09</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/生活/" itemprop="url" rel="index"><span itemprop="name">生活</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本文将着重于以问答形式记录Java相关知识点。</p>
<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><ol>
<li>JVM垃圾收集器比较，怎么选？</li>
</ol>
<ul>
<li><p>JVM总共有7种垃圾收集器</p>
<p>  参考<a href="/2018/11/07/JVM-memory-management-and-GC/GCs.jpg">GCs</a></p>
</li>
<li><p>Serial,ParNew,Parallel Scavenge 负责堆年轻代中的内存回收</p>
</li>
<li><p>Serial Old,CMS,Parallel Old 负责堆老年代中的内存回收</p>
</li>
<li><p>G1分代回收，能独立管理整个GC堆</p>
</li>
<li><p>两个收集器中间存在连线的，说明能够配合工作</p>
</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">名称</th>
<th style="text-align:left">收集算法</th>
<th style="text-align:left">工作区域</th>
<th style="text-align:left">可配合对象</th>
<th style="text-align:left">线程/并发</th>
<th style="text-align:left">适用场合</th>
<th style="text-align:left">优缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Serial</td>
<td style="text-align:left">复制算法</td>
<td style="text-align:left">新生代</td>
<td style="text-align:left">CMS;<br>Serial Old</td>
<td style="text-align:left">单</td>
<td style="text-align:left">单CPU;<br>Client模式下</td>
<td style="text-align:left">缺：stop the world;<br>优：简单高效,没有线程交互开销,专注于GC;</td>
</tr>
<tr>
<td style="text-align:left">ParNew</td>
<td style="text-align:left">复制算法</td>
<td style="text-align:left">新生代</td>
<td style="text-align:left">CMS;<br>Serial Old</td>
<td style="text-align:left">多</td>
<td style="text-align:left">多CPU;<br>Server模式下</td>
<td style="text-align:left">缺：stop the world <br>优：并行并发GC</td>
</tr>
<tr>
<td style="text-align:left">Parallel Scavenge</td>
<td style="text-align:left">复制算法</td>
<td style="text-align:left">新生代</td>
<td style="text-align:left">Serial Old;<br>Parallel Scavenge</td>
<td style="text-align:left">多</td>
<td style="text-align:left">吞吐量控制,<br>Client,server均可以</td>
<td style="text-align:left">主要关注吞吐量,通过吞吐量的设置控制停顿时间,适应不同的场景</td>
</tr>
<tr>
<td style="text-align:left">Serial Old</td>
<td style="text-align:left">标记整理算法</td>
<td style="text-align:left">老年代</td>
<td style="text-align:left">Serial,<br>ParNew,<br>Parallel Scavenge</td>
<td style="text-align:left">单</td>
<td style="text-align:left">主要Client模式下</td>
<td style="text-align:left">缺：stop the world</td>
</tr>
<tr>
<td style="text-align:left">Parallel Old</td>
<td style="text-align:left">复制算法（Parallel Scavenge老年代版本）</td>
<td style="text-align:left">老年代</td>
<td style="text-align:left">Parallel Scavenge</td>
<td style="text-align:left">多</td>
<td style="text-align:left">吞吐量控制,<br>Client,server均可以</td>
<td style="text-align:left">主要关注吞吐量,通过吞吐量的设置控制停顿时间,适应不同的场景</td>
</tr>
<tr>
<td style="text-align:left">CMS(Concurretn Mark Sweep)</td>
<td style="text-align:left">标记清除算法</td>
<td style="text-align:left">老年代</td>
<td style="text-align:left">Serial,<br>ParNew,<br>Serial Old是其备选方案</td>
<td style="text-align:left">多</td>
<td style="text-align:left">互联网站;<br>B/S系统服务端</td>
<td style="text-align:left">缺：CPU资源敏感,无法处理浮动垃圾,产生大量内存碎片<br>优：并发收集,低停顿</td>
</tr>
<tr>
<td style="text-align:left">G1</td>
<td style="text-align:left">整体基于标记整理算法</td>
<td style="text-align:left">新生代&amp;老年代</td>
<td style="text-align:left"></td>
<td style="text-align:left">多</td>
<td style="text-align:left">面向服务端应用</td>
<td style="text-align:left">优：并行与并发, 分代收集,空间整合(标记整理算法),可预测停顿<br>需要Remembered Set来避免全堆扫描</td>
</tr>
</tbody>
</table>
<h1 id="Threading"><a href="#Threading" class="headerlink" title="Threading"></a>Threading</h1><ol>
<li><p>为什么要使用多线程?</p>
<p> 参考<a href="/2018/12/12/Java-Concurrency/#多线程概念">多线程概念</a>。</p>
</li>
</ol>
<ol start="2">
<li><p>CompletableFuture的get()方法和join()方法有什么区别？</p>
<p> 参考<a href="/2018/12/12/Java-Concurrency/#CompletableFuture">代码示例</a></p>
</li>
<li><p>多线程处理结果怎么拿到?</p>
<p> 当通过异步方式CompletableFuture调用时，可以通过get()/join()来阻塞当前线程等待结果，或者通过回调函数thenApply()传入后续处理。</p>
<p> 当通过Thread形式调用时，可以通过线程调度器方法join()方式阻塞当前线程等待结果。</p>
</li>
<li><p>线程池有哪些参数，分别怎么使用？怎么释放？</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                        TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                        BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                        ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                        RejectedExecutionHandler handler)</span></span></span><br></pre></td></tr></table></figure>
<ol>
<li><p>corePoolSize 线程池核心线程大小</p>
<p> 线程池中会维护一个最小的线程数量，即使这些线程处理空闲状态，他们也不会被销毁，除非设置了allowCoreThreadTimeOut。这里的最小线程数量即是corePoolSize。</p>
</li>
<li><p>maximumPoolSize 线程池最大线程数量</p>
<p> 一个任务被提交到线程池以后，首先会找有没有空闲存活线程，如果有则直接执行，如果没有则会缓存到工作队列（后面会介绍）中，如果工作队列满了，才会创建一个新线程，然后从工作队列的头部取出一个任务交由新线程来处理，而将刚提交的任务放入工作队列尾部。线程池不会无限制的去创建新线程，它会有一个最大线程数量的限制，这个数量即由maximunPoolSize指定。</p>
</li>
<li><p>keepAliveTime 空闲线程存活时间</p>
<p> 一个线程如果处于空闲状态，并且当前的线程数量大于corePoolSize，那么在指定时间后，这个空闲线程会被销毁，这里的指定时间由keepAliveTime来设定</p>
</li>
<li><p>unit 空闲线程存活时间单位</p>
<p> keepAliveTime的计量单位</p>
</li>
<li><p>workQueue 工作队列</p>
<p> 新任务被提交后，会先进入到此工作队列中，任务调度时再从队列中取出任务。jdk中提供了四种工作队列：</p>
<ol>
<li><p>ArrayBlockingQueue</p>
<p> 基于数组的有界阻塞队列，按FIFO排序。新任务进来后，会放到该队列的队尾，有界的数组可以防止资源耗尽问题。当线程池中线程数量达到corePoolSize后，再有新任务进来，则会将任务放入该队列的队尾，等待被调度。如果队列已经是满的，则创建一个新线程，如果线程数量已经达到maxPoolSize，则会执行拒绝策略。</p>
</li>
<li><p>LinkedBlockingQuene</p>
<p> 基于链表的无界阻塞队列（其实最大容量为Interger.MAX），按照FIFO排序。由于该队列的近似无界性，当线程池中线程数量达到corePoolSize后，再有新任务进来，会一直存入该队列，而不会去创建新线程直到maxPoolSize，因此使用该工作队列时，参数maxPoolSize其实是不起作用的。</p>
</li>
<li><p>SynchronousQuene</p>
<p> 一个不缓存任务的阻塞队列，生产者放入一个任务必须等到消费者取出这个任务。也就是说新任务进来时，不会缓存，而是直接被调度执行该任务，如果没有可用线程，则创建新线程，如果线程数量达到maxPoolSize，则执行拒绝策略。</p>
</li>
<li><p>PriorityBlockingQueue</p>
<p> 具有优先级的无界阻塞队列，优先级通过参数Comparator实现。</p>
</li>
</ol>
</li>
<li><p>threadFactory 线程工厂</p>
<p> 创建一个新线程时使用的工厂，可以用来设定线程名、是否为daemon线程等等</p>
</li>
<li><p>handler 拒绝策略</p>
<p> 当工作队列中的任务已到达最大限制，并且线程池中的线程数量也达到最大限制，这时如果有新任务提交进来，该如何处理呢。这里的拒绝策略，就是解决这个问题的，jdk中提供了4中拒绝策略：</p>
<ol>
<li><p>CallerRunsPolicy</p>
<p>该策略下，在调用者线程中直接执行被拒绝任务的run方法，除非线程池已经shutdown，则直接抛弃任务。</p>
</li>
<li><p>AbortPolicy</p>
<p>该策略下，直接丢弃任务，并抛出RejectedExecutionException异常。</p>
</li>
<li><p>DiscardPolicy</p>
<p>该策略下，直接丢弃任务，什么都不做。</p>
</li>
<li><p>DiscardOldestPolicy</p>
<p>该策略下，抛弃进入队列最早的那个任务，然后尝试把这次拒绝的任务放入队列</p>
</li>
</ol>
</li>
</ol>
</li>
<li><p>新建一个线程底层发生了什么？</p>
<ul>
<li><p>Java: 当我们创建一个线程并执行start()方法后这个线程才会被创建和执行。Java.lang.Thread.start()方法会调用本地方法start0();</p>
</li>
<li><p>JVM: start0()方法会调用JVM_StartThread()方法:</p>
<ul>
<li>这是JVM_StartThread的具体实现，可以看到，它会创建一个JavaThread实例。</li>
<li>os::create_thread的具体实现。在这个方法中会创建一个平台相关的OSThread 实例。在os::create_thread()方法中会利用glibc库中的pthread.h中的pthread_create方法创建一个轻量级的Linux进程，这个方法执行后，线程创建控制流从JVM转到OS.</li>
</ul>
</li>
<li>OS: <ul>
<li>pthread.h 中定义pthread_create()方法。</li>
<li>pthread_create 方法进入clone方法的桥梁create_thread()方法。</li>
<li>系统调用：<ul>
<li>系统调用的处理程序：sys_clone</li>
<li>do_fork()函数生成轻量级进程</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>线程池如何关闭线程</p>
<p> 两个方法，shutdown方法会停止处理新的任务，已经执行的任务会继续执行，shutdownnow方法会发送中断到线程中。</p>
</li>
<li>线程安全需要考虑几个方面问题:</li>
</ol>
<ul>
<li>原子性</li>
<li>可见性</li>
<li>有序性</li>
</ul>
<h1 id="Java-Language"><a href="#Java-Language" class="headerlink" title="Java Language"></a>Java Language</h1><ol>
<li>Synchronized和ReentrantLock比较有什么不同？</li>
</ol>
<ul>
<li>语法不同：一个是修饰符，一个是对象，利用方法/传参控制</li>
<li>实现机制不同：前者使用JVM管理实例对象头，互斥变量，后者使用AQS(volatile状态变量+FIFO同步队列)实现</li>
<li>性能不同：前者通过锁膨胀机制提升性能，后者需要程序员通过代码灵活控制锁的获取/释放/公平性问题。</li>
</ul>
<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><ol>
<li>Spring源码分析</li>
</ol>
<p><a href="http://ddrv.cn/docs/springtutorial/" target="_blank" rel="noopener">http://ddrv.cn/docs/springtutorial/</a></p>
<ol start="2">
<li>Spring AOP实现基于代码分析</li>
</ol>
<ul>
<li>JDK基于继承(Proxy实例，实现被代理类接口)和反射(调用真正实例方法)的动态代理实现方法</li>
<li>CGLIB基于反射生成代理子类继承（被代理类）实现动态代理，代理方法需要实现MethodInterceptor接口</li>
<li>代理实例方法直接调用的调用实现</li>
<li>代理实例方法间接调用的调用实现</li>
</ul>
<ol start="3">
<li>Spring getBean的实现</li>
</ol>
<ul>
<li>getBeanDefinition</li>
<li>IOC Container中Bean实例化-&gt;初始化-&gt;完整对象</li>
</ul>
<h1 id="Spring-boot"><a href="#Spring-boot" class="headerlink" title="Spring boot"></a>Spring boot</h1><ol>
<li>Spring boot源码分析</li>
</ol>
<p><a href="https://www.jianshu.com/p/9fa2d0bcd8e4" target="_blank" rel="noopener">https://www.jianshu.com/p/9fa2d0bcd8e4</a></p>
<ul>
<li>Starter组件，开箱即用的各类服务启动器</li>
<li>自动装配，分析代码上下文，动态扫描Bean，并完成装配</li>
<li>Actuator，Spring Boot应用的监控</li>
<li>Spring Boot Cli，基于命令行工具快速构建Spring Boot应用</li>
</ul>
<h1 id="Database"><a href="#Database" class="headerlink" title="Database"></a>Database</h1><ol>
<li>B+树的数据结构特点</li>
</ol>
<h1 id="编译器知识"><a href="#编译器知识" class="headerlink" title="编译器知识"></a>编译器知识</h1><ol>
<li><p>AST概念，Lombok框架基本概念</p>
</li>
<li><p>语法树概览</p>
</li>
</ol>
<h1 id="Spring-cloud"><a href="#Spring-cloud" class="headerlink" title="Spring cloud"></a>Spring cloud</h1><ol>
<li>对Spring Cloud微服务架构理解？</li>
</ol>
<p>微服务架构是一种松耦合架构，Java Spring Cloud对微服务支持体现在功能性支持上，目前有五个流行关键组件:</p>
<ul>
<li>API网关</li>
<li>负载均衡</li>
<li>服务注册</li>
<li>容错机制：弹性断路器模式，后备处理模式</li>
<li>配置管理</li>
</ul>
<p>这些组件保证了微服务内容服务器的服务A高可用性，P分区容忍性，但并没有保证C一致性。</p>
<ol start="2">
<li><p>对于Spring Cloud微服务架构组件源码分析</p>
<p> <a href="https://www.jianshu.com/p/53a280c0f17d" target="_blank" rel="noopener">https://www.jianshu.com/p/53a280c0f17d</a></p>
<ul>
<li>Spring Cloud Gateway 源码分析</li>
<li>Spring Cloud Alibaba源码分析</li>
</ul>
</li>
<li><p>Spring Cloud Netflix</p>
<ul>
<li>Ribbon 负载均衡</li>
<li>Zuul API网关</li>
<li>Eureka 服务注册</li>
<li>Hystrix弹性断路器模式，后备处理模式</li>
<li>Feign 支持RPC风格调用</li>
</ul>
</li>
<li><p>Spring Cloud Alibaba</p>
<ul>
<li>Nacos 配置中心，负载均衡，服务注册</li>
<li>Sentinel 弹性限流/熔断模式</li>
<li>Seata 分布式事务</li>
<li>RocketMQ 分布式消息通信</li>
</ul>
</li>
<li><p>Spring Cloud和Dubbo有什么不同？</p>
<ul>
<li>协议层不同：HTTP层和二进制协议（</li>
<li>耦合性不同: 解耦合RESTful设计和基于接口调用</li>
<li>注册中心: Eureka/Nacos和zk/redis等</li>
<li>功能中间件支持: 全方位多场景和SOA场景支持</li>
</ul>
</li>
</ol>
<h1 id="Distributed-system"><a href="#Distributed-system" class="headerlink" title="Distributed system"></a>Distributed system</h1><ol>
<li>分布式事务是怎么实现的？</li>
</ol>
<ul>
<li>Seata组件可以实现AT, TCC, Sega 和XA事务模式</li>
<li>RocketMQ可以实现TCC事务模式</li>
</ul>
<ol start="2">
<li>分布式缓存？</li>
</ol>
<ul>
<li>Memcached单机缓存, 内存存储，多核处理性能高</li>
<li>Redis分布式缓存Master-Slave, 支持持久化功能，高可用，支持分片</li>
<li>分布式写加锁，超时解锁，定时延长锁寿命</li>
</ul>
<ol start="3">
<li>Redis常见问题及解决方案？</li>
</ol>
<ul>
<li><p>缓存穿透问题：</p>
<ul>
<li>产生: 数据过期，未缓存，不存在数据访问，内存满了</li>
<li>解决： 布隆过滤器缓存已有数据状态，过滤</li>
</ul>
</li>
<li><p>缓存击穿问题:</p>
<ul>
<li>产生：瞬间高并发量穿透访问某一个key</li>
<li>解决：加锁更新缓存，或者重新get</li>
</ul>
</li>
<li><p>雪崩场景问题:</p>
<ul>
<li>产生: 高并发量多key穿透访问</li>
<li>解决：</li>
</ul>
</li>
</ul>
<h1 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h1><ol>
<li>Leetcode No.53 最大字序和</li>
</ol>
<p>暴力算法，贪心法，动态规划法，分治法。</p>
<h1 id="System-Architecture-and-Design"><a href="#System-Architecture-and-Design" class="headerlink" title="System Architecture and Design"></a>System Architecture and Design</h1><ol>
<li><p>Domain Driven Design</p>
</li>
<li><p>常见架构理论：六边形架构/洋葱架构</p>
</li>
</ol>
<h1 id="Developer-Career-Value"><a href="#Developer-Career-Value" class="headerlink" title="Developer Career/Value"></a>Developer Career/Value</h1><ol>
<li>你有什么可以为新公司提供的价值？</li>
</ol>
<ul>
<li>喜欢实践动手，愿意自学新的技术，能快速落地应用原型，根据需求深入研究</li>
<li>对于目前微服务架构，容器构建编排技术，云服务部署有一定地经验可以快速上手</li>
<li>熟悉Java基础知识，Spring框架，对于基于事件驱动，多线程，异步等性能优化方案有一定地经验</li>
<li>全栈开发经验，能够很好地协调前后端工程师共同参与的的项目开发</li>
<li>多平台前端开发经验，有助于公司开发一些必要的前端桌面应用，插件前端等</li>
<li>熟悉需求落地，能够把握业务重点，更好的控制项目进度</li>
<li>产品支持经验，能够更好的和运营维护工程师沟通，从开发角度提升运行效率</li>
<li>工作过程中可以帮助较为资浅同事</li>
</ul>
<ol start="2">
<li>你为旧公司做出了哪些项目贡献？</li>
</ol>
<ul>
<li><p>跨平台微服务迁移项目</p>
<ul>
<li><p>桌面用户界面迁移</p>
<ul>
<li>性能优化：同步UI转换成异步UI</li>
<li>跨平台支持: WinForm/WPF内嵌网页交互界面</li>
</ul>
</li>
<li><p>桌面处理逻辑微服务迁移</p>
<ul>
<li>跨平台支持/稳定性提升：复杂逻辑服务化</li>
<li>解耦合处理模型/优化内存管理：功能性逻辑与业务逻辑解耦合</li>
<li>运用容器技术自动化灵活部署于云服务</li>
<li>中心化插件模型快速迭代部署</li>
</ul>
</li>
<li><p>业务处理模型转型</p>
<ul>
<li>提前处理耗时数据准备工作</li>
<li>并发计算处理，支持远程处理模型</li>
<li>处理结果整合和后处理流程</li>
</ul>
</li>
</ul>
</li>
<li><p>云服务项目转型</p>
<ul>
<li>混合语言环境 Java/.NET/.NET core，灵活开发，各取其优</li>
<li>Docker技术引入，支持快速迭代批量部署</li>
<li>运用微服务架构支持云平台部署</li>
</ul>
</li>
<li><p>技术经验分享</p>
<ul>
<li>Java Spring</li>
<li>.NET COM/ASP.NET</li>
<li>.NET core</li>
<li>Cloud platform</li>
<li>Container技术</li>
</ul>
</li>
<li><p>业务金融安全领域知识</p>
<ul>
<li>访问授权模型</li>
<li>DLP数据管理机制<ul>
<li>Symantec</li>
<li>O365 DLP</li>
<li>O365 AIP</li>
<li>ESC</li>
</ul>
</li>
<li>终端日志跟踪机制</li>
</ul>
</li>
<li><p>管理经验</p>
</li>
</ul>
<ol start="3">
<li>为什么离开现在的公司？</li>
</ol>
<ul>
<li>技术栈落后<ul>
<li>传统科技公司的技术栈是2000年科技状态，并且运营以稳定高效为目的，因此技术革新迭代慢。</li>
<li>云服务，微服务，大数据技术已经是现代程序员必备知识，在传统金融公司无法得到实践</li>
</ul>
</li>
<li>资源有限<ul>
<li>公司从顶层架构设计上趋向于利用有限的资源进行维护，缺乏对新技术革新和投资</li>
<li>团队太小，开发人员需要兼职项目需求关系，维护，产品长远更新没有效率和不受重视</li>
</ul>
</li>
<li>个人职业发展<ul>
<li>寻求技术栈转型，更快地学习和实践现代化程序员职业道路</li>
<li>实现个人价值，希望能为公司业务带来改善</li>
</ul>
</li>
</ul>
<ol start="4">
<li>数据库上遇到的挑战，怎么解决的？</li>
</ol>
<p>拍卖网站数据库死锁问题，并发场景下，Sybase是基于页锁的粒度进行并发控制，当发生如下情况时：</p>
<p><img src="/2020/12/07/Java-Questions-and-Answers/DeadLockCase.png" alt="Deadlock"></p>
<ul>
<li>一个线程id=775正在等待表格页1741的互斥锁，执行INSERT操作, 目前另一个线程id=559已经拿到了Auction_Bids表格页1741的共享锁（读锁）</li>
<li>另一个线程id=559正在等待表格页1776的共享锁，执行SELECT操作，目前线程id=775已经拿到了Auction_Bids表格也1776的互斥锁。</li>
<li>Sybase数据库在解决死锁过程中选择了取消线程id=775的互斥锁，这样会致使一个写操作失效。</li>
</ul>
<p>锁产生的原因：</p>
<ul>
<li>Hibernate在生成Select SQL时，由于是表格Auction_Bids left outer join Auction_Users,需要对整个表格的页逐个进行扫描，所以会对Auction_Bids表格进行逐个共享锁获取。</li>
<li>对于insert操作时，锁是页锁，但是数据页会一页一页的锁，但是由于插入数据需要先自增操作select @@identity获取了令一个表页的互斥锁。因此第一个拿1776互斥锁行为阻止了select语句对页共享锁的获取。</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">Locking Scheme/Locking granulairty</th>
<th style="text-align:center">Table lock</th>
<th style="text-align:left">Page lock</th>
<th style="text-align:left">Row lock</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">数据页+索引页</td>
<td style="text-align:center">表锁+页锁</td>
<td style="text-align:left">页锁</td>
<td style="text-align:left">行锁</td>
</tr>
<tr>
<td style="text-align:left">仅数据页</td>
<td style="text-align:center">表锁+页锁</td>
<td style="text-align:left">页锁</td>
<td style="text-align:left">行锁</td>
</tr>
<tr>
<td style="text-align:left">仅数行</td>
<td style="text-align:center">表锁+行锁</td>
<td style="text-align:left">页锁</td>
<td style="text-align:left">行锁</td>
</tr>
</tbody>
</table>
<p>解决方案:</p>
<ul>
<li>由于大量的读操作被写操作阻塞住，读写分离是最好的解决方法。但是这个解决方案需要投入一个新的读数据库并且同步数据。</li>
<li>从数据库层面上可以通过创建索引，并且允许脏读写索引数据(插入的时候不锁索引表格)避免全表扫描，并且减小锁的粒度为行粒度来减少并发带来的死锁。代码层面上对于自增ID和插入数据操作(insert select)如果能够分别处理也能避免死锁的发生。</li>
</ul>
<ol start="5">
<li>邮件过滤规则引擎算法设计思想</li>
</ol>
<ul>
<li>采用类似于依赖注入方式，根据XML的配置的关联情况生成对应的实例。支持递归与或复合表达式配置。</li>
<li>表达式可视化支持能够大大减少客户咨询负担，可以交由业务端自行处理</li>
<li>单一规则灵活横向扩展，利用OOP的抽象对象将检查规则分类扩展，同时支持一套可共享判定操作行为。</li>
<li>单线程执行引擎具有不稳定性和执行效率低下问题，并发执行引擎并且加以高可用扩展能够更好的高效处理。</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sunnyhll.github.io/2020/12/07/Microservices-via-Spring-Cloud/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="果核&肉肉">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="微观天下">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/12/07/Microservices-via-Spring-Cloud/" class="post-title-link" itemprop="https://sunnyhll.github.io/index.html">Microservices via Spring Cloud</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-12-07 10:53:17" itemprop="dateCreated datePublished" datetime="2020-12-07T10:53:17+08:00">2020-12-07</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-12-08 16:16:37" itemprop="dateModified" datetime="2020-12-08T16:16:37+08:00">2020-12-08</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>目前各大科技公司都提供了各种云平台服务，对于普通地金融科技公司而言，从传统的内部维护基础架构的日子一去不复返。策略转向了开发面向多平台，多终端的服务开发，其中前端开发倾向于web，后端开发倾向于自包含而且能灵活大量部署的微服务架构。如何从传统的开发风格转变为适应云平台服务的应用开发成为了一个需要攻坚的课题。</p>
<p>采用微服务架构拥有诸多好处，在本文中将不做赘述，可参见微服务架构一文。目前，微服务架构已经从设计逐渐落地，开发者社区逐渐贡献出云生态的组件框架，能够让这一战略目标变为可执行方案。</p>
<h1 id="Spring-Cloud微服务框架"><a href="#Spring-Cloud微服务框架" class="headerlink" title="Spring Cloud微服务框架"></a>Spring Cloud微服务框架</h1><p>Spring家族拥有多个方向的项目，目前最为领先行业的就是Spring Framework, Spring Boot, Spring Cloud三大方向，分别致力于帮助开发者开发系统，简化应用初始搭建，以及实现微服务开发设计。</p>
<p>Spring Cloud提供了非常完整的一套微服务实施方案：</p>
<ul>
<li>服务发现</li>
<li>分布式配置</li>
<li>客户端负载均衡</li>
<li>服务容错保护</li>
<li>API网关</li>
<li>安全</li>
<li>事件驱动</li>
<li>分布式服务跟踪</li>
</ul>
<p>当然，代码构建微服务只是微服务落地的第一步，为了支持灵活大量部署，微服务需要借助容器技术来快速部署到各个云平台服务提供商的虚拟机上，Docker则是容器技术实现的一个典范，我将在另一篇文章中介绍容器技术。</p>
<h1 id="Spring-Cloud常用组件"><a href="#Spring-Cloud常用组件" class="headerlink" title="Spring Cloud常用组件"></a>Spring Cloud常用组件</h1><h2 id="API网关"><a href="#API网关" class="headerlink" title="API网关"></a>API网关</h2><p>Spring Cloud Gateway和Netflix Zuul为所有微服务提供了一个单一入口点。API网关是一个单独的中间件。</p>
<h2 id="Spring-Cloud-Gateway源码分析"><a href="#Spring-Cloud-Gateway源码分析" class="headerlink" title="Spring Cloud Gateway源码分析"></a>Spring Cloud Gateway源码分析</h2><p>处理流程：</p>
<ul>
<li>Netty web容器：NIO机制，事件循环监听端口请求</li>
<li>请求的Route Predicate函数式过滤匹配规则<ul>
<li>HTTP请求信息检查例如：Host，Query, Path, Header, Cookie</li>
</ul>
</li>
<li>请求过滤器Filter处理和转发接收<ul>
<li>Pre型在请求转发前执行，可以做鉴权，限流等操作</li>
<li>Post型过滤器可以对返回数据进行增强处理</li>
<li>下游服务可以为注册中心的地址/预先配置好的节点IP信息</li>
</ul>
</li>
</ul>
<h3 id="Netty-NIO的源码分析"><a href="#Netty-NIO的源码分析" class="headerlink" title="Netty NIO的源码分析"></a>Netty NIO的源码分析</h3><p><img src="/2020/12/07/Microservices-via-Spring-Cloud/NettyNIO.png" alt="NettyNIO"></p>
<ul>
<li><p>Reactor线程处理流程:</p>
<ol>
<li><p>初始化Initiation Dispatcher，然后将若干个Concrete Event Handler注册到Initiation Dispatcher中。当应用向Initiation Dispatcher注册Concrete Event Handler时，会在注册的同时指定感兴趣的事件，即，应用会标识出该事件处理器希望Initiation Dispatcher在某些事件发生时向其发出通知，事件通过Handle来标识，而Concrete Event Handler又持有该Handle。这样，事件 ————&gt; Handle ————&gt; Concrete Event Handler 就关联起来了。</p>
</li>
<li><p>Initiation Dispatcher 会要求每个事件处理器向其传递内部的Handle。该Handle向操作系统标识了事件处理器。</p>
</li>
<li><p>当所有的Concrete Event Handler都注册完毕后，应用会调用handle_events方法来启动Initiation Dispatcher的事件循环。这是，Initiation Dispatcher会将每个注册的Concrete Event Handler的Handle合并起来，并使用Synchronous Event Demultiplexer(同步事件分离器)同步阻塞的等待事件的发生。比如说，TCP协议层会使用select同步事件分离器操作来等待客户端发送的数据到达连接的socket handler上。<br>比如，在Java中通过Selector的select()方法来实现这个同步阻塞等待事件发生的操作。在Linux操作系统下，select()的实现中:</p>
<ul>
<li><p>会将已经注册到Initiation Dispatcher的事件调用epollCtl(epfd, opcode, fd, events)注册到linux系统中，这里fd表示Handle，events表示我们所感兴趣的Handle的事件；</p>
</li>
<li><p>通过调用epollWait方法同步阻塞的等待已经注册的事件的发生。不同事件源上的事件可能同时发生，一旦有事件被触发了，epollWait方法就会返回；</p>
</li>
<li><p>最后通过发生的事件找到相关联的SelectorKeyImpl对象，并设置其发生的事件为就绪状态，然后将SelectorKeyImpl放入selectedSet中。这样一来我们就可以通过Selector.selectedKeys()方法得到事件就绪的SelectorKeyImpl集合了。</p>
</li>
</ul>
</li>
<li><p>当与某个事件源对应的Handle变为ready状态时(比如说，TCP socket变为等待读状态时)，Synchronous Event Demultiplexer就会通知Initiation Dispatcher。</p>
</li>
<li><p>Initiation Dispatcher会触发事件处理器的回调方法，从而响应这个处于ready状态的Handle。当事件发生时，Initiation Dispatcher会将被事件源激活的Handle作为『key』来寻找并分发恰当的事件处理器回调方法。</p>
</li>
<li><p>Initiation Dispatcher会回调事件处理器的handle_event(type)回调方法来执行特定于应用的功能(开发者自己所编写的功能)，从而相应这个事件。所发生的事件类型可以作为该方法参数并被该方法内部使用来执行额外的特定于服务的分离与分发。</p>
</li>
</ol>
</li>
<li><p>服务器单线程Reactor处理流程</p>
<ol>
<li>服务器端的Reactor是一个线程对象，该线程会启动事件循环，并使用Selector来实现IO的多路复用。注册一个Acceptor事件处理器到Reactor中，Acceptor事件处理器所关注的事件是ACCEPT事件，这样Reactor会监听客户端向服务器端发起的连接请求事件(ACCEPT事件)。</li>
<li>客户端向服务器端发起一个连接请求，Reactor监听到了该ACCEPT事件的发生并将该ACCEPT事件派发给相应的Acceptor处理器来进行处理。Acceptor处理器通过accept()方法得到与这个客户端对应的连接(SocketChannel)，然后将该连接所关注的READ事件以及对应的READ事件处理器注册到Reactor中，这样一来Reactor就会监听该连接的READ事件了。或者当你需要向客户端发送数据时，就向Reactor注册该连接的WRITE事件和其处理器。</li>
<li>当Reactor监听到有读或者写事件发生时，将相关的事件派发给对应的处理器进行处理。比如，读处理器会通过SocketChannel的read()方法读取数据，此时read()操作可以直接读取到数据，而不会堵塞与等待可读的数据到来。</li>
<li><p>每当处理完所有就绪的感兴趣的I/O事件后，Reactor线程会再次执行select()阻塞等待新的事件就绪并将其分派给对应处理器进行处理。</p>
<p>注意，Reactor的单线程模式的单线程主要是针对于I/O操作而言，也就是所以的I/O的accept()、read()、write()以及connect()操作都在一个线程上完成的。</p>
<p>但在目前的单线程Reactor模式中，不仅I/O操作在该Reactor线程上，连非I/O的业务操作也在该线程上进行处理了，这可能会大大延迟I/O请求的响应。所以我们应该将非I/O的业务逻辑操作从Reactor线程上卸载，以此来加速Reactor线程对I/O请求的响应。</p>
</li>
</ol>
</li>
<li><p>服务器多线程Reactor处理流程：</p>
<p>  Reactor线程池中的每一Reactor线程都会有自己的Selector、线程和分发的事件循环逻辑。<br>  mainReactor可以只有一个，但subReactor一般会有多个。mainReactor线程主要负责接收客户端的连接请求，然后将接收到的SocketChannel传递给subReactor，由subReactor来完成和客户端的通信。</p>
<ol>
<li><p>注册一个Acceptor事件处理器到mainReactor中，Acceptor事件处理器所关注的事件是ACCEPT事件，这样mainReactor会监听客户端向服务器端发起的连接请求事件(ACCEPT事件)。启动mainReactor的事件循环。</p>
</li>
<li><p>客户端向服务器端发起一个连接请求，mainReactor监听到了该ACCEPT事件并将该ACCEPT事件派发给Acceptor处理器来进行处理。Acceptor处理器通过accept()方法得到与这个客户端对应的连接(SocketChannel)，然后将这个SocketChannel传递给subReactor线程池。</p>
</li>
<li><p>subReactor线程池分配一个subReactor线程给这个SocketChannel，即，将SocketChannel关注的READ事件以及对应的READ事件处理器注册到subReactor线程中。当然你也注册WRITE事件以及WRITE事件处理器到subReactor线程中以完成I/O写操作。Reactor线程池中的每一Reactor线程都会有自己的Selector、线程和分发的循环逻辑。</p>
</li>
<li><p>当有I/O事件就绪时，相关的subReactor就将事件派发给响应的处理器处理。注意，这里subReactor线程只负责完成I/O的read()操作，在读取到数据后将业务逻辑的处理放入到线程池中完成，若完成业务逻辑后需要返回数据给客户端，则相关的I/O的write操作还是会被提交回subReactor线程来完成。</p>
</li>
</ol>
</li>
</ul>
<h3 id="扩展知识：Tomcat-同步-异步BIO的源码分析"><a href="#扩展知识：Tomcat-同步-异步BIO的源码分析" class="headerlink" title="扩展知识：Tomcat 同步/异步BIO的源码分析"></a>扩展知识：Tomcat 同步/异步BIO的源码分析</h3><ul>
<li>服务器流程：<ol>
<li>服务器端的Server是一个线程，线程中执行一个死循环来阻塞的监听客户端的连接请求和通信。</li>
<li>当客户端向服务器端发送一个连接请求后，服务器端的Server会接受客户端的请求，ServerSocket.accept()从阻塞中返回，得到一个与客户端连接相对于的Socket。</li>
<li>构建一个handler，将Socket传入该handler。创建一个线程并启动该线程，在线程中执行handler，这样与客户端的所有的通信以及数据处理都在该线程中执行。当该客户端和服务器端完成通信关闭连接后，线程就会被销毁。</li>
<li>然后Server继续执行accept()操作等待新的连接请求。</li>
</ol>
</li>
</ul>
<ul>
<li><p>优点：</p>
<ul>
<li>使用简单，容易编程</li>
<li>在多核系统下，能够充分利用了多核CPU的资源。即，当I/O阻塞系统，但CPU空闲的时候，可以利用多线程使用CPU资源。</li>
</ul>
</li>
<li><p>缺点：该模式的本质问题在于严重依赖线程，但线程Java虚拟机非常宝贵的资源。随着客户端并发访问量的急剧增加，线程数量的不断膨胀将服务器端的性能将急剧下降。</p>
<ul>
<li>线程生命周期的开销非常高。线程的创建与销毁并不是没有代价的。在Linux这样的操作系统中，线程本质上就是一个进程，创建和销毁都是重量级的系统函数。</li>
<li>资源消耗。内存：大量空闲的线程会占用许多内存，给垃圾回收器带来压力。；CPU：如果你已经拥有足够多的线程使所有CPU保持忙碌状态，那么再创建更过的线程反而会降低性能。</li>
<li>稳定性。在可创建线程的数量上存在一个限制。这个限制值将随着平台的不同而不同，并且受多个因素制约：a)JVM的启动参数、b)Threa的构造函数中请求的栈大小、c)底层操作系统对线程的限制 等。如果破坏了这些限制，那么很可能抛出OutOfMemoryError异常。</li>
<li>线程的切换成本是很高的。操作系统发生线程切换的时候，需要保留线程的上下文，然后执行系统调用。如果线程数过高，不仅会带来许多无用的上下文切换，还可能导致执行线程切换的时间甚至会大于线程执行的时间，这时候带来的表现往往是系统负载偏高、CPU sy(系统CPU)使用率特别高，导致系统几乎陷入不可用的状态。</li>
<li>容易造成锯齿状的系统负载。一旦线程数量高但外部网络环境不是很稳定，就很容易造成大量请求的结果同时返回，激活大量阻塞线程从而使系统负载压力过大。</li>
<li>若是长连接的情况下并且客户端与服务器端交互并不频繁的，那么客户端和服务器端的连接会一直保留着，对应的线程也就一直存在在，但因为不频繁的通信，导致大量线程在大量时间内都处于空置状态。</li>
</ul>
</li>
<li><p>适用场景：如果你有少量的连接使用非常高的带宽，一次发送大量的数据，也许典型的IO服务器实现可能非常契合。</p>
</li>
</ul>
<h3 id="安全——服务验证和授权"><a href="#安全——服务验证和授权" class="headerlink" title="安全——服务验证和授权"></a>安全——服务验证和授权</h3><p>Spring Cloud Securty为微服务提供了一种灵活的用户验证机制，和授权模型。其中验证机制可以基于OAuth2.0标准下的OpenID协议完成，而用户服务授权模型则通过OAuth 2.0的token提供。云服务中的所有服务都应该引入服务验证和授权机制来保护内容服务的安全性。</p>
<p>如果需要更多的security功能，可以考虑引入spring security中的功能。本文将着重介绍基于OAuth2.0的微服务安全架构。</p>
<p>微服务中一般在gateway进行验证授权，而在下游微服务中只需要确认请求是经过认证的即可。关于鉴权的详细文章请见<a href="/2020/11/16/Authentication/">这里</a>.</p>
<h1 id="Spring-Cloud-Netflix"><a href="#Spring-Cloud-Netflix" class="headerlink" title="Spring Cloud Netflix"></a>Spring Cloud Netflix</h1><h2 id="Netflix-Eureka服务注册"><a href="#Netflix-Eureka服务注册" class="headerlink" title="Netflix Eureka服务注册"></a>Netflix Eureka服务注册</h2><p>Eureka是单独的服务组件，保证了A高可用，和P分区容忍性的中间件，与Zookeeper保证的C一致性，P分区容忍性不同，更加适合微服务架构，通过集群保证了高可用的动态服务注册以及心跳感知。Eureka一般和Ribbon放在同一个服务器上，所以在gateway上需要指向lb://abc-service就能保证负载均衡到对应的已注册资源服务中。</p>
<h2 id="Netflix-Ribbon负载均衡"><a href="#Netflix-Ribbon负载均衡" class="headerlink" title="Netflix Ribbon负载均衡"></a>Netflix Ribbon负载均衡</h2><p>Netflix Ribbon 采用拦截器将请求的Url进行负载均衡分发，从而达到内容微服务的负载均衡效果。Ribbon框架并不是单独执行，往往在前端服务中会通过（服务注册中心获取/API网关中写死）得到提供服务的IP地址，所以服务调用方引入Ribbon通过一定的均衡策略动态生成最终访问的IP地址。</p>
<ul>
<li><p>全局使用既定的某种负载均衡策略：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RandomRule <span class="title">randomRule</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RandomRule();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过配置方式灵活配置服务提供者的负载均衡策略</p>
</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 负载均衡策略</span></span><br><span class="line"><span class="comment"># service-provider-name 为调用的服务的名称</span></span><br><span class="line"><span class="attr">service-provider-name:</span></span><br><span class="line"><span class="attr">  ribbon:</span></span><br><span class="line"><span class="attr">    NFLoadBalancerRuleClassName:</span> <span class="string">com.netflix.loadbalancer.RandomRule</span></span><br></pre></td></tr></table></figure>
<h3 id="Ribbon负载均衡策略比较"><a href="#Ribbon负载均衡策略比较" class="headerlink" title="Ribbon负载均衡策略比较"></a>Ribbon负载均衡策略比较</h3><table>
<thead>
<tr>
<th style="text-align:left">策略名</th>
<th style="text-align:left">策略声明</th>
<th style="text-align:left">策略描述</th>
<th style="text-align:left">实现说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">BestAvailableRule</td>
<td style="text-align:left">public class BestAvailableRule extends ClientConfigEnabledRoundRobinRule</td>
<td style="text-align:left">选择一个最小的并发请求的server</td>
<td style="text-align:left">逐个考察Server：<br> 如果Server被tripped了，则忽略，<br>再选择其中ActiveRequestsCount最小的server</td>
</tr>
<tr>
<td style="text-align:left">AvailabilityFilteringRule</td>
<td style="text-align:left">public class AvailabilityFilteringRule extends PredicateBasedRule</td>
<td style="text-align:left">过滤掉那些因为一直连接失败的被标记为circuit tripped的后端server，并过滤掉那些高并发的的后端server（active connections 超过配置的阈值）</td>
<td style="text-align:left">使用一个AvailabilityPredicate来包含过滤server的逻辑, 其实就就是检查status里记录的各个server的运行状态</td>
</tr>
<tr>
<td style="text-align:left">WeightedResponseTimeRule</td>
<td style="text-align:left">public class WeightedResponseTimeRule extends RoundRobinRule</td>
<td style="text-align:left">根据相应时间分配一个weight，相应时间越长，weight越小，被选中的可能性越低。</td>
<td style="text-align:left">一个后台线程定期的从status里面读取评价响应时间，为每个server计算一个weight;<br>Weight的计算也比较简单responsetime 减去每个server自己平均的responsetime是server的权重;<br>当刚开始运行，没有形成statas时，使用roudrobin策略选择server。</td>
</tr>
<tr>
<td style="text-align:left">RetryRule</td>
<td style="text-align:left">public class RetryRule extends AbstractLoadBalancerRule</td>
<td style="text-align:left">对选定的负载均衡策略机上重试机制。</td>
<td style="text-align:left">在一个配置时间段内当选择server不成功，则一直尝试使用subRule的方式选择一个可用的server</td>
</tr>
<tr>
<td style="text-align:left">RoundRobinRule</td>
<td style="text-align:left">public class RoundRobinRule extends AbstractLoadBalancerRule</td>
<td style="text-align:left">roundRobin方式轮询选择server</td>
<td style="text-align:left">轮询index，选择index对应位置的server</td>
</tr>
<tr>
<td style="text-align:left">RandomRule</td>
<td style="text-align:left">public class RandomRule extends AbstractLoadBalancerRule</td>
<td style="text-align:left">随机选择一个server</td>
<td style="text-align:left">在index上随机，选择index对应位置的server</td>
</tr>
<tr>
<td style="text-align:left">ZoneAvoidanceRule</td>
<td style="text-align:left">public class ZoneAvoidanceRule extends PredicateBasedRule</td>
<td style="text-align:left">复合判断server所在区域的性能和server的可用性选择server</td>
<td style="text-align:left">使用ZoneAvoidancePredicate和AvailabilityPredicate来判断是否选择某个server，前一个判断判定一个zone的运行性能是否可用，剔除不可用的zone（的所有server），AvailabilityPredicate用于过滤掉连接数过多的Server。</td>
</tr>
</tbody>
</table>
<h2 id="Netflix-Feign动态代理RPC调用"><a href="#Netflix-Feign动态代理RPC调用" class="headerlink" title="Netflix Feign动态代理RPC调用"></a>Netflix Feign动态代理RPC调用</h2><p>RPC远程调用的一种经典实现，为了让服务调用的代码跟普通方法调用一样方便，可以使用Netflix Feign动态代理被调用的服务接口，并且在底层实际使用HTTPClient进行调用。</p>
<h2 id="Netflix-Hystrix服务弹性保证"><a href="#Netflix-Hystrix服务弹性保证" class="headerlink" title="Netflix Hystrix服务弹性保证"></a>Netflix Hystrix服务弹性保证</h2><p>对于微服务的调用失败需要进行动态的感知，当大量请求失败后需要主动断路避免延迟。而且需要后备方式记录或者进行服务降级。在.NETcore 中对等的实现是steeltoe.</p>
<h3 id="Hystrix熔断机制源码分析"><a href="#Hystrix熔断机制源码分析" class="headerlink" title="Hystrix熔断机制源码分析"></a>Hystrix熔断机制源码分析</h3><p>基于注解@HystrixCommand和AOP实现，在方法执行前拦截的动态代理执行。对于有弹性机制需要的节点，需要引入Hystrix进行失败回退方法编写。</p>
<h4 id="Hystrix手写代码示例"><a href="#Hystrix手写代码示例" class="headerlink" title="Hystrix手写代码示例"></a>Hystrix手写代码示例</h4><ol>
<li>自定义注解 @WuzzHystrixCommand</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> WuzzHystrixCommand &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认超时时间</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">timeout</span><span class="params">()</span> <span class="keyword">default</span> 1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 回退方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">fallback</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>编写切面类，实现简易的逻辑处理</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WuzzHystrixCommandAspect</span> </span>&#123;</span><br><span class="line">    <span class="comment">//线程池的处理，基于这个线程池的处理统计可以达到 THREAD 资源限流</span></span><br><span class="line">    ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注解切点</span></span><br><span class="line">    <span class="meta">@Pointcut</span>(value = <span class="string">"@annotation(com.wuzz.demo.custom.hystrix.WuzzHystrixCommand)"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointCut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//环绕通知</span></span><br><span class="line">    <span class="meta">@Around</span>(value = <span class="string">"pointCut()&amp;&amp;@annotation(hystrixCommand)"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">doPointCut</span><span class="params">(ProceedingJoinPoint joinPoint, WuzzHystrixCommand hystrixCommand)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException, NoSuchMethodException, InvocationTargetException, IllegalAccessException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> timeout = hystrixCommand.timeout();</span><br><span class="line">        <span class="comment">//前置的判断逻辑</span></span><br><span class="line">        Future future = executorService.submit(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> joinPoint.proceed(); <span class="comment">//执行目标方法</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">                throwable.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        Object result;</span><br><span class="line">        <span class="keyword">try</span> &#123;<span class="comment">// 使用 future 来实现超时</span></span><br><span class="line">            result = future.get(timeout, TimeUnit.MILLISECONDS);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException | TimeoutException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            future.cancel(<span class="keyword">true</span>);</span><br><span class="line">            <span class="comment">// ？</span></span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isBlank(hystrixCommand.fallback())) &#123;</span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//调用fallback</span></span><br><span class="line">            result = invokeFallback(joinPoint, hystrixCommand.fallback());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">invokeFallback</span><span class="params">(ProceedingJoinPoint joinPoint, String fallback)</span> <span class="keyword">throws</span> NoSuchMethodException, InvocationTargetException, IllegalAccessException </span>&#123;</span><br><span class="line">        <span class="comment">//获取被代理的方法的参数和Method</span></span><br><span class="line">        MethodSignature signature = (MethodSignature) joinPoint.getSignature();</span><br><span class="line">        Method method = signature.getMethod();</span><br><span class="line">        Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</span><br><span class="line">        <span class="comment">//得到fallback方法</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Method fallbackMethod = joinPoint.getTarget().getClass().getMethod(fallback, parameterTypes);</span><br><span class="line">            fallbackMethod.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            <span class="comment">//完成反射调用</span></span><br><span class="line">            <span class="keyword">return</span> fallbackMethod.invoke(joinPoint.getTarget(), joinPoint.getArgs());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>编写测试，调用：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WuzzHystrixCommand</span>(fallback = <span class="string">"customFallback"</span>, timeout = <span class="number">3000</span>)</span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/custom/hystrix/test"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Map map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">"id"</span>, <span class="number">666</span>);</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(REST_URL_PREFIX + <span class="string">"/hello?id=&#123;id&#125;"</span>, String.class, map);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">customFallback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"custom 请求被降级"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正常得调用是没有问题的，这个时候我们把服务提供方的服务接口里  sleep 3秒来模仿调用超时，在访问接口就会得到降级服务后的返回。</p>
<h1 id="Spring-Cloud-Alibaba"><a href="#Spring-Cloud-Alibaba" class="headerlink" title="Spring Cloud Alibaba"></a>Spring Cloud Alibaba</h1><h2 id="Nacos-配置中心，负载均衡，服务注册"><a href="#Nacos-配置中心，负载均衡，服务注册" class="headerlink" title="Nacos 配置中心，负载均衡，服务注册"></a>Nacos 配置中心，负载均衡，服务注册</h2><h3 id="Nacos服务注册源码分析"><a href="#Nacos服务注册源码分析" class="headerlink" title="Nacos服务注册源码分析"></a>Nacos服务注册源码分析</h3><ul>
<li>Nacos服务注册Naming Service源码分析<pre><code>* 接受Nacos客户端的API调用注册生成Instance实例
    * 将Instance放入serviceMap中ConcurrentHashMap集合中
    * consitencyService.listen实现数据定期检查
* 通过Namespace对已注册服务的隔离
* 定时检查HeartBeat对已注册Instance实例进行检查，更新实例状态
* 对出现异常的服务进行基于UDP协议推送更新于PushService
</code></pre><ul>
<li>Nacos服务方客户端注册源码分析<ul>
<li>Spring Boot自动启动NacosAutoServiceRegistration进行注册调用</li>
<li>监听ApplicationStartedEvent事件调用NacosServiceRegistry.register方法</li>
<li>namingService.regiterInstance中创建BeanInfo，定时发送心跳包：executorService.schedule(task, period, unit)</li>
</ul>
</li>
<li>Nacos前端客户端服务消费者源码分析<ul>
<li>客户端发起订阅请求会定期发起UpdateTask来获得最新地址</li>
<li>客户端也会提供本地EventListener回调实例处理出现异常的服务</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Sentinel-弹性限流-熔断模式"><a href="#Sentinel-弹性限流-熔断模式" class="headerlink" title="Sentinel 弹性限流/熔断模式"></a>Sentinel 弹性限流/熔断模式</h2><h3 id="Sentinel和Hystrix对比"><a href="#Sentinel和Hystrix对比" class="headerlink" title="Sentinel和Hystrix对比"></a>Sentinel和Hystrix对比</h3><p><img src="/2020/12/07/Microservices-via-Spring-Cloud/SentinelHystrix.png" alt="SH"></p>
<h2 id="Seata-分布式事务"><a href="#Seata-分布式事务" class="headerlink" title="Seata 分布式事务"></a>Seata 分布式事务</h2><p>分布式事务解决了分布式系统中存储数据（数据库/缓存)一致性问题。</p>
<h3 id="分布式事务解决理论"><a href="#分布式事务解决理论" class="headerlink" title="分布式事务解决理论"></a>分布式事务解决理论</h3><h4 id="X-Open分布式事务模型"><a href="#X-Open分布式事务模型" class="headerlink" title="X/Open分布式事务模型"></a>X/Open分布式事务模型</h4><ul>
<li>AP: Application 应用程序</li>
<li>RM： Resource Manager 资源管理者，数据库</li>
<li>TM： Transaction Manager事务管理器/协调者</li>
</ul>
<h4 id="两段提交协议"><a href="#两段提交协议" class="headerlink" title="两段提交协议"></a>两段提交协议</h4><ul>
<li>准备阶段： TM同之RM准备事务，并告知准备结果</li>
<li>提交/回滚阶段：如果所有RM返回成功则执行提交完成指令，反之执行回滚指令。</li>
</ul>
<p>存在问题：</p>
<ol>
<li>同步阻塞数据库</li>
<li>容易失败，一个节点失败就回滚</li>
<li>TM单点故障问题，造成RM锁死。</li>
<li>脑裂问题，二阶段部分提交问题。</li>
</ol>
<h4 id="三段提交协议"><a href="#三段提交协议" class="headerlink" title="三段提交协议"></a>三段提交协议</h4><ul>
<li>CanCommit询问阶段: TM询问是否可以参与事务/超时。</li>
<li>PreCommit准备阶段：如果所有RM确认可以，则发起事务，并返回结果/超时。</li>
<li>DoCommit提交/回滚阶段：如果均成功提交则发起提交/回滚指令。</li>
</ul>
<p>改进部分:</p>
<ul>
<li>超时即失败机制，避免两阶段提交锁死等待问题。</li>
<li>提前确认节点状态</li>
</ul>
<h3 id="分布式事务解决方案"><a href="#分布式事务解决方案" class="headerlink" title="分布式事务解决方案"></a>分布式事务解决方案</h3><ul>
<li>基于MQ的消息中间件实现TCC (Try-Confirm-Cancel)模型补偿型方案(幂等性实现，最大努力通知机制)</li>
<li>基于Seata模式的分布式事务框架(AT, TCC, Sega 和XA事务模式)</li>
</ul>
<h3 id="Seata源码分析"><a href="#Seata源码分析" class="headerlink" title="Seata源码分析"></a>Seata源码分析</h3><h2 id="Spring-Cloud-Stream-发布-订阅流处理"><a href="#Spring-Cloud-Stream-发布-订阅流处理" class="headerlink" title="Spring Cloud Stream 发布/订阅流处理"></a>Spring Cloud Stream 发布/订阅流处理</h2><p>Spring Cloud Stream支持消息中间件通信，因而可以支持多种高并发消息发布/消费场景：</p>
<p>Spring Cloud Stream包含如下四个核心部分：</p>
<ul>
<li>Spring Messaging<ul>
<li>Message, 消息对象，包含消息头和消息体</li>
<li>MessageChannel, 消息通道接口，用于接收消息，提供send方法将消息发送至消息通道</li>
<li>MessageHandler, 消息处理器接口，用于处理消息逻辑</li>
</ul>
</li>
<li>Spring Integration<ul>
<li>MessageDispatcher：消息分发接口，用于分发消息和添加删除消息处理器</li>
<li>MessageRouter: 消息路由接口，定义默认的输出消息通道</li>
<li>Filter：消息的过滤注解，用于配置消息过滤表达式</li>
<li>Aggregator: 消息的聚合注解，用于将多个消息聚合成一条</li>
<li>Splitter: 消息的分割，用于将一条消息拆分成多条</li>
</ul>
</li>
<li>Binders 目标绑定器，负责于外部消息中间件系统集成的组件<ul>
<li>doBindProducer: 为中间件绑定发送消息模块，让中间件能从MessageChannel接受到符合中间件格式的消息</li>
<li>doBindConsumer：为中间件绑定接受消息模块，让中间件能够发送符合Spring Message标准的消息到MessageChannel</li>
</ul>
</li>
<li>Bindings 绑定生成的桥梁，支持Kafka，RabbitMQ中间件</li>
</ul>
<h3 id="RocketMQ-分布式消息通信源码分析"><a href="#RocketMQ-分布式消息通信源码分析" class="headerlink" title="RocketMQ 分布式消息通信源码分析"></a>RocketMQ 分布式消息通信源码分析</h3><p>消息发送流程源码分析：</p>
<p><img src="/2020/12/07/Microservices-via-Spring-Cloud/SpringCloudStream.jpg" alt="MQProducer"></p>
<p>除了负责和Spring Cloud服务器中的Messaging集成之外，RocketMQ Binder还负责和MQ中间件集群通信，源码分发布/订阅两部分，分别如下:</p>
<ul>
<li>使用RocketMQTemplate真正发送MQ消息到中间件</li>
<li>同时创建ConsumerEndpoint和input MessageChannel监听MQ订阅消息，并且负责转发给下游</li>
<li>消息的消费分为顺序消费和并发消费，分别由DefaultMessageListenerOrderly,DefaultMessageListenerConcurrently实现，通过binders的配置设定。</li>
</ul>
<p>消息订阅流程源码分析：</p>
<p><img src="/2020/12/07/Microservices-via-Spring-Cloud/SpringCloudStreamConsume.jpg" alt="MQProducer"></p>
<p>其中，服务器对消息的接收，是基于注解方式注入到响应的业务方法中的。这就是在业务代码中，不需要为接收信息创建MessageChannel，却能拿到信息体中的反序列化后信息。</p>
<h3 id="RocketMQ-消息使用场景与实现"><a href="#RocketMQ-消息使用场景与实现" class="headerlink" title="RocketMQ 消息使用场景与实现"></a>RocketMQ 消息使用场景与实现</h3><h4 id="RocketMQ-顺序消息实现"><a href="#RocketMQ-顺序消息实现" class="headerlink" title="RocketMQ 顺序消息实现"></a>RocketMQ 顺序消息实现</h4><p>顺序发送消费场景：订单创建、支付、退款流程处理，数据库BinLog信息消费等等。</p>
<ul>
<li>顺序发送需要将消息发送到同一队列即可，通过基于消息ID的哈希分队选择器即可完成。</li>
<li>顺序消费需要binders中配置好ConsumerMQ的集群消费模式，即每条消息只会被ConsumerGroup中的一个Consumer消费。通过Consumer拿Broker独占锁实现。消费成功后会提交并更新消费进程，避免重复消费。代码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.processQueue.getLockConsume().lock();</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">this</span>.processQueue.isDropped())&#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  status = messageListener.consumeMessage(Collections.unmodifieableList(msgs), context);</span><br><span class="line">&#125;<span class="keyword">catch</span>(Throwable e)&#123;</span><br><span class="line">  hasException - <span class="keyword">true</span>;</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.processQueue.getLockConsume().unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="RocketMQ-普通消息发送实现"><a href="#RocketMQ-普通消息发送实现" class="headerlink" title="RocketMQ 普通消息发送实现"></a>RocketMQ 普通消息发送实现</h4><p>普通消息在队列选择可以由两种机制:</p>
<ul>
<li>轮询机制：轮流使用每个队列发送消息</li>
<li>故障规避机制： </li>
</ul>
<h4 id="RocketMQ-消息并发消费实现"><a href="#RocketMQ-消息并发消费实现" class="headerlink" title="RocketMQ 消息并发消费实现"></a>RocketMQ 消息并发消费实现</h4><p>并发消费场景下，消息队列允许Consumer的线程消费池可以向同一个队列消费信息，并且每个消费线程消费信息会有自己的进度信息。</p>
<h4 id="RocketMQ-分布式事务消息实现"><a href="#RocketMQ-分布式事务消息实现" class="headerlink" title="RocketMQ 分布式事务消息实现"></a>RocketMQ 分布式事务消息实现</h4><p>为分布式事务处理提供了通信基础。</p>
<p><img src="/2020/12/07/Microservices-via-Spring-Cloud/RocketMQ.png" alt="RMQ"></p>
<p>Rocket发送事务消息：</p>
<p>Rocket发送事务消息是二次提交的，第一次发送prepare提交到服务器时消息主题会替换为RMQ_SYS_TRANS_HALF_TOPIC。等到本地事务执行完毕以后才进行二次提交，这时会发送给原本消息的topic。</p>
<ol>
<li><p>由producer发送prepare（半消息）给MQ的broker。MQ会把消息记录到本地，然后回复prepare消息状态给producer。</p>
</li>
<li><p>prepare消息发送以后获取发送状态，如果是成功则执行本地业务（本地事务），根据本地事务执行结果手动返回相应状态（RocketMQLocalTransactionState.COMMIT、RocketMQLocalTransactionState.ROLLBACK等）给MQ。</p>
</li>
<li><p>如果是COMMIT则说明本地事务执行成功，prepare为可提交状态，MQ收到COMMIT消息就会发送给consumer，然后consumer执行本地业务。如果是ROLLBACK则会删除prepare消息。</p>
</li>
<li><p>如果MQ一直没收到返回状态则会启动定时任务检查本地事务状态</p>
</li>
<li><p>消费者、生产者的事务各由开发者自己保证。MQ的事务是由MQ保证，这里会根据使用者配置的参数来决定如何执行。</p>
</li>
</ol>
<h4 id="RocketMQ消费模式"><a href="#RocketMQ消费模式" class="headerlink" title="RocketMQ消费模式"></a>RocketMQ消费模式</h4><ul>
<li>at-most-once最多一次</li>
<li>at-least-once最少一次，RocketMQ通过消费者ACK机制支持至少一次</li>
<li>exactly-only-once仅此一次</li>
</ul>
<h3 id="RocketMQ实现原理"><a href="#RocketMQ实现原理" class="headerlink" title="RocketMQ实现原理"></a>RocketMQ实现原理</h3><h4 id="高性能设计"><a href="#高性能设计" class="headerlink" title="高性能设计"></a>高性能设计</h4><h4 id="高可用设计"><a href="#高可用设计" class="headerlink" title="高可用设计"></a>高可用设计</h4>
          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sunnyhll.github.io/2020/11/16/Authentication/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="果核&肉肉">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="微观天下">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/11/16/Authentication/" class="post-title-link" itemprop="https://sunnyhll.github.io/index.html">Authentication</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-11-16 22:49:49" itemprop="dateCreated datePublished" datetime="2020-11-16T22:49:49+08:00">2020-11-16</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Authentication服务鉴权机制"><a href="#Authentication服务鉴权机制" class="headerlink" title="Authentication服务鉴权机制"></a>Authentication服务鉴权机制</h1><p>用户在访问系统或者服务时，服务器端需要验证用户是否拥有访问的权力，这个过程称为鉴权。在服务器-客户端架构的软件系统中，当一个没有经过鉴权的用户登录时，服务器可能会返回鉴权请求。鉴权是一种客户端和服务器协同认证的方式，有多种方式可以实现：</p>
<ul>
<li>HTTP Basic Authentication</li>
<li>session-cookie</li>
<li>Token 验证(JWT)</li>
<li>OAuth(开放授权)</li>
</ul>
<h1 id="HTTP-Basic-Authentication"><a href="#HTTP-Basic-Authentication" class="headerlink" title="HTTP Basic Authentication"></a>HTTP Basic Authentication</h1><p>HTTP认证时一种无状态的认证模式，因此用户在提供相关凭据的请求中能够得到认证用户的访问，而服务器本身在接下来的请求中并不能持续保持登录状态。</p>
<p>HTTP基本认证的具体流程如下:</p>
<p>在你访问一个需要HTTP Basic Authentication的URL的时候，如果你没有提供用户名和密码，服务器就会返回401，返回Header中会包含类似”WWW-Authenticate: Basic realm=”test””信息。如果你直接在浏览器中打开，浏览器会弹出对话框提示你输入用户名和密码。</p>
<p>要在发送请求的时候添加HTTP Basic Authentication认证信息到请求中，有两种方法:</p>
<ol>
<li>在请求头中添加Authorization信息：Authorization: “Basic {用户名:密码}的base64加密字符串”。</li>
<li>在url中添加用户名和密码。</li>
</ol>
<p>其中，鉴权机制中的身份验证并非一定要依赖Basic方式的用户名密码作为凭据，可以通过如下方式：</p>
<ol>
<li><p>“WWW-Authenticate: Negotiate” SPNEGO协议,支持Kerberos, NTLM点对点认证方式完成。在协商过程中：</p>
<ul>
<li>可以请求 Authorization: Negotiate {kerberos票据}进行Kerberos验证</li>
<li>或者也能读取返回头中的 Authorization: Negotiate NTLMSSP{八字节质询码} ，并在请求头部中加入 Authorization: Negotiate NTLM{加密的质询码和明码用户名}</li>
</ul>
</li>
<li><p>“WWW-Authenticate: Digest realm=”test”,qop=”auth”,nonce=”{md5加密时间},opaque=”{不透明字符串}”摘要认证协议，能避免明文传输数据。</p>
<ul>
<li>在请求中需要加入 Authoriztion: Digest username=”guest”,realm=”test”,nonce=”{同上},qop=”auth”,nc=”00000001”,response=”{通过md5加密的user paswd httpmethod uri等信息}”,cnonce=”{客户端提供的非明文字符串}”,uri=”{uri信息}”</li>
<li>服务器需要检查时间在允许范围内，而且response匹配本地生成值。使用MD5算法的优势在于可以很快正向哈希，而无法短时间内逆向哈希得出用户密码等信息。</li>
</ul>
</li>
</ol>
<h1 id="session-cookie鉴权"><a href="#session-cookie鉴权" class="headerlink" title="session-cookie鉴权"></a>session-cookie鉴权</h1><p>Session是HTTP协议中为了支持有状态的通信而发明的会话机制，本质上是通过服务器为用户建立sessionid从而保证用户的状态信息能够在服务器端保存。用户不需要反复进行登录认证就能保持会话。</p>
<p>而Cookie则是一种特殊的HTTP头部，能够在HTTP通信中保存一定的用户信息，如sessionid从而达到认证用户的目的。由于Cookie本身是针对某一域名而产生的，所以在发送Cookie过程中必须提供正确域名的sessionid才行。</p>
<p>具体流程如下：</p>
<p><img src="/2020/11/16/Authentication/CookieAuth.jpg" alt="cookieAuth"></p>
<p>Cookie鉴权常用Single Sign On场景，例如，于对于企业中的不同子域名的验证，可以通过结合SAML, CAS等协议完成。对于不同网络更加广泛的第三方验证则有OIDC协议支持。</p>
<h1 id="Token-验证-JWT"><a href="#Token-验证-JWT" class="headerlink" title="Token 验证(JWT)"></a>Token 验证(JWT)</h1><p>Token验证方式和Seesion验证方式很类似，不同的是Token本身包含一些有意义的信息：用户名、密码、过期时间等。Token本身由服务器签发，客户端请求的发送中需要包含 Authorization : JWT “{jwt token}”，服务器提取token信息通过相同的算法验证即可。相较于Session验证方式节约了分布式系统中服务器存储sessionid和用户信息的开销，只需要服务器拥有相同的密钥即可。</p>
<p>具体流程如下:</p>
<p><img src="/2020/11/16/Authentication/TokenAuth.png" alt="tokenAuth"></p>
<p>JWT(json-web-token)算法细节：</p>
<p>JWT由三部分”{header}.{payload}.{signature}’,两种算法生成，公式如下：<br>    signature = sha256(base64(header)+’.’+base64(payload),{服务器密钥})</p>
<ol>
<li>header包含算法和类别信息, </li>
<li>payload为加密部分，包含公有声明和私有声明，公有声明为约定的key，私有为公司定制key，</li>
<li>signature，算法签名。</li>
<li>sha256为header中写的加密算法，基于服务器密钥生成不同的加密签名,具有不可逆性</li>
<li>base64为编码算法，可逆运算</li>
</ol>
<h1 id="OAuth2-OIDC认证"><a href="#OAuth2-OIDC认证" class="headerlink" title="OAuth2/OIDC认证"></a>OAuth2/OIDC认证</h1><p>OIDC 即Open ID Connect, 是一种基于OAuth2授权流程，并且扩展了身份认证层的一种新的认证机制。</p>
<p>OIDC认证模型主要包含如下四个角色和一个令牌（完整术语参见<a href="http://openid.net/specs/openid-connect-core-1_0.html#Terminology）：" target="_blank" rel="noopener">http://openid.net/specs/openid-connect-core-1_0.html#Terminology）：</a></p>
<ul>
<li>EU用户：End User：一个人类用户。</li>
<li>RP客户端：Relying Party ,用来代指OAuth2中的受信任的客户端，身份认证和授权信息的消费方；</li>
<li>OP认证服务器：OpenID Provider，有能力提供EU认证的服务（比如OAuth2中的授权服务），用来为RP提供EU的ID Token身份认证信息和Access Token访问令牌；</li>
<li>UE用户资源服务器：UserInfo Endpoint用户信息接口（受OAuth2保护），当RP使用Access Token访问时，返回授权用户的信息，此接口必须使用HTTPS。</li>
<li>ID Token认证令牌：JWT格式的数据，包含EU身份认证的信息。通过OP提供。</li>
</ul>
<p>认证流程如下：</p>
<p><img src="/2020/11/16/Authentication/OIDCAuth.jpg" alt="OIDCAuth"></p>
<p>其中，UserIndo EndPoint是一个受OAuth2保护的资源。在RP得到Access Token后可以请求此资源，然后获得一组EU相关的Claims，这些信息可以说是ID Token的扩展，比如如果你觉得ID Token中只需包含EU的唯一标识sub即可（避免ID Token过于庞大），然后通过此接口获取完整的EU的信息。此资源必须部署在TLS之上。</p>
<p>OIDC的支持的授权流程如下：</p>
<ol>
<li>Authorization Code(授权码模式)：使用OAuth2的授权码来换取Id Token和Access Token。</li>
<li>Implicit (简化模式)：使用OAuth2的Implicit流程获取Id Token和Access Token。</li>
<li>Hybrid(混合模式)：混合Authorization Code +Implicit。</li>
</ol>
<h2 id="OAuth2授权模型"><a href="#OAuth2授权模型" class="headerlink" title="OAuth2授权模型"></a>OAuth2授权模型</h2><p>OAuth2的授权模型时为了已登录用户通过第三方应用访问资源服务器进行授权的流程，授权模型和OIDC相似，包含如下四个角色:</p>
<ul>
<li>资源拥有者（User） - 指应用的用户，比如github的一个账户拥有者</li>
<li>认证服务器 （Authorization Server） - 提供登录认证接口的服务器，比如：github等</li>
<li>资源服务器 （Resources Server） - 提供资源接口及服务的服务器，通常和认证服务器是同    一个应用。</li>
<li>第三方客户端（Client） - 第三方应用，希望使用资源服务器提供的资源，比如你的一个支持通过github账户登录的应用</li>
<li>服务提供商(Provider): 认证服务和资源服务归属于一个机构，该机构就是服务提供商，比如github公司</li>
</ul>
<p>OAuth2具有四种授权模式，下文将分述这四种模式具体流程：</p>
<ul>
<li>授权码模式（authorization code）</li>
<li>简化模式（implicit）</li>
<li>密码模式（resource owner password credentials）</li>
<li>客户端模式（client credentials）</li>
</ul>
<h3 id="授权码模式-最为常见"><a href="#授权码模式-最为常见" class="headerlink" title="授权码模式(最为常见)"></a>授权码模式(最为常见)</h3><ol>
<li>用户访问客户端应用</li>
<li>引导用户到认证服务器进行登录（此步骤需要携带客户端应用的clientId，可以是html直接转发认证服务器），用户输入用户名、密码</li>
<li>认证成功后，认证服务器向客户端应用发一个授权码code</li>
<li>客户端应用拿着授权码code，和clientId，clientSecret，去换取access_token</li>
<li>返回access_token给客户端应用 </li>
</ol>
<p><img src="/2020/11/16/Authentication/AuthorizationCodeOAuth.png" alt="AuthorizationCodeOAuth"></p>
<p>这种场景下，用户名、密码、客户端应用信息，都没有直接暴露在浏览器，是web下是最安全的。</p>
<h3 id="简化模式"><a href="#简化模式" class="headerlink" title="简化模式"></a>简化模式</h3><p>授权码模式的简化，用户认证成功后，直接将token返回给浏览器。因为某些应用没有前端服务器，只有一堆静态的html（很少见），这种模式，一般不用。</p>
<p><img src="/2020/11/16/Authentication/ImplicitOAuth.png" alt="ImplicitOAuth"></p>
<h3 id="密码模式"><a href="#密码模式" class="headerlink" title="密码模式"></a>密码模式</h3><p>适用场景：手机app ，这个客户端应用是你完全可以信任的，你的app就是自己公司开发的。但是这个模式并不适合在web场景下用，在web下，用户名密码并不是直接填给自己写的应用的，而是填在浏览器呈现的一个页面上的，这个浏览器是客户端应用的一个代理，浏览器是没法保证安全性的。</p>
<p><img src="/2020/11/16/Authentication/PasswordOAuth.png" alt="PasswordOAuth"></p>
<h3 id="客户端证书模式"><a href="#客户端证书模式" class="headerlink" title="客户端证书模式"></a>客户端证书模式</h3><p>客户端应用直接发 clientId、clientSecret给认证服务器，发的令牌是针对客户端应用的，不是针对用户的。跟没授权一样，令牌不能识别用户身份。</p>
<p><img src="/2020/11/16/Authentication/ClientCertOAuth.png" alt="ClientOAuth"></p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sunnyhll.github.io/2020/11/07/Office-365-Addin-ESC-POC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="果核&肉肉">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="微观天下">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/11/07/Office-365-Addin-ESC-POC/" class="post-title-link" itemprop="https://sunnyhll.github.io/index.html">Office 365 Addin ESC POC</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-11-07 09:45:41 / 修改时间：10:12:49" itemprop="dateCreated datePublished" datetime="2020-11-07T09:45:41+08:00">2020-11-07</time>
            

            
              

              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="project-bootstrap"><a href="#project-bootstrap" class="headerlink" title="project bootstrap"></a>project bootstrap</h1><p> Demo项目是通过VS2019自带的Addin模板生成。默认debug模式部署在一个o365 dev tenant上。目前已有Github demo项目也可以直接下载，相关<a href="https://docs.microsoft.com/en-us/office/dev/add-ins/outlook/outlook-on-send-addins?tabs=windows#install-outlook-add-ins-that-use-on-send" target="_blank" rel="noopener">链接</a>。</p>
<h2 id="Demo-项目原型简述"><a href="#Demo-项目原型简述" class="headerlink" title="Demo 项目原型简述"></a>Demo 项目原型简述</h2><p>引入demo项目是一个查看邮件各种属性的ESCPOC项目，在读取一封邮件时，可以点击ESCPOC按钮查看邮件的属性。在启动debug并上传manifest后，点击Ribbon上的MyAddinGroup按钮，显示如下图所示：</p>
<p> <img src="/2020/11/07/Office-365-Addin-ESC-POC/ESCPOC.PNG" alt="ESCPOCDemo"></p>
<p>我们的目标POC项目是一个非常简单的发送弹框程序，需要订阅每一封邮件的发送事件itemsend并且根据Web API调用结果显示一个web UI.</p>
<h3 id="ESCPOC-xml-修改剖析"><a href="#ESCPOC-xml-修改剖析" class="headerlink" title="ESCPOC.xml 修改剖析"></a>ESCPOC.xml 修改剖析</h3><p>Manifest文件是O365插件加载的关键配置，需要完全符合schema定义的规则才能正确显式UI以及相应的回调API。</p>
<ol>
<li>Validation<br>Manifest 文件具有很强的格式要求，需要运用微软提供的工具对自己的manifest文件进行语法检查。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#install latest version</span></span><br><span class="line">npm install -g office-addin-manifest</span><br><span class="line">office-addin-manifest validate PATH_MANIFEST_FILE</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>创建ItemSend相关配置<br>目前微软已经有开源的示例代码于<a href="https://github.com/OfficeDev/outlook-add-in-command-demo，可以作为参考。" target="_blank" rel="noopener">https://github.com/OfficeDev/outlook-add-in-command-demo，可以作为参考。</a><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Event</span> <span class="attr">Type</span>=<span class="string">"ItemSend"</span> <span class="attr">FunctionExecution</span>=<span class="string">"synchronous"</span> <span class="attr">FunctionName</span>=<span class="string">"itemSendHandler"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>注意配置上下文需要在VersionOverrides 1.1框架下。</p>
<h2 id="O365-环境准备"><a href="#O365-环境准备" class="headerlink" title="O365 环境准备"></a>O365 环境准备</h2><p>对于跨平台的O365 Addin，一个合法的O365账号是需要的，而且需要拥有上传插件的权限。在用用MSDN订阅的情况下，可以创建合适的E3等级Office Tenant。例如本文则使用<a href="mailto:huangsun@sunnyhll.onmicrosoft.com" target="_blank" rel="noopener">huangsun@sunnyhll.onmicrosoft.com</a>作为测试账号，密码为系统密码。</p>
<p>Web Addin查看可以点击Outlook桌面客户端的Manage Addin按钮，也可以在<a href="https://outlook.office365.com/owa/?path=/options/manageapps" target="_blank" rel="noopener">https://outlook.office365.com/owa/?path=/options/manageapps</a> 链接中看到。可以看到即使安装了很多插件，这些插件却不是实时安装在本地Outlook桌面客户端上的， 而是在需要访问的时候才进行加载执行的。</p>
<h3 id="开启ItemSend事件监听"><a href="#开启ItemSend事件监听" class="headerlink" title="开启ItemSend事件监听"></a>开启ItemSend事件监听</h3><p>相关<a href="https://docs.microsoft.com/en-us/powershell/exchange/exchange-online/connect-to-exchange-online-powershell/connect-to-exchange-online-powershell?view=exchange-ps" target="_blank" rel="noopener">链接</a>.</p>
<h3 id="“My-Custom-Roles”权限"><a href="#“My-Custom-Roles”权限" class="headerlink" title="“My Custom Roles”权限"></a>“My Custom Roles”权限</h3><p>对于个人O365账号，这里不需要进行权限获取，Microsoft Tenant默认每个客户的SideLoad权限开启。</p>
<h3 id="Web-Addin部署"><a href="#Web-Addin部署" class="headerlink" title="Web Addin部署"></a>Web Addin部署</h3><p>对于Outlook Web Addin, 主要分成两部分部署：</p>
<ul>
<li>Manifest配置文件部署，在Exchange Mailbox 上注册插件</li>
<li>插件服务部署，必须采用https协议，插件服务前后端本身需要在同一域名下。<br>部署完成即可进行测试。</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sunnyhll.github.io/2020/10/30/Effective-Java/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="果核&肉肉">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="微观天下">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/10/30/Effective-Java/" class="post-title-link" itemprop="https://sunnyhll.github.io/index.html">Effective Java</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-10-30 15:11:53 / 修改时间：15:11:54" itemprop="dateCreated datePublished" datetime="2020-10-30T15:11:53+08:00">2020-10-30</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本文是Effetive Java一书提出地90条Java代码规范建议，具体内容需要查看相应地书籍内容，本文仅作为索引复习回忆。</p>
<h1 id="创建与销毁对象"><a href="#创建与销毁对象" class="headerlink" title="创建与销毁对象"></a>创建与销毁对象</h1><ol>
<li><p>用静态工厂方法代替构造器</p>
</li>
<li><p>遇到多个构造器参数时要考虑使用构建器(builder)</p>
</li>
<li><p>用私有构造器或者枚举类型强化Singleton属性</p>
</li>
<li><p>通过私有构造器强化不可实例化的能力</p>
</li>
<li><p>优先考虑依赖注入来引用资源</p>
</li>
<li><p>避免创建不必要的对象</p>
</li>
<li><p>消除过期的对象引用</p>
</li>
<li><p>避免使用中介方法和清除方法</p>
</li>
<li><p>try-with-resources优先于try-finally</p>
</li>
</ol>
<h1 id="对于所有对象都通用的方法"><a href="#对于所有对象都通用的方法" class="headerlink" title="对于所有对象都通用的方法"></a>对于所有对象都通用的方法</h1><ol start="10">
<li><p>覆盖Equals时请遵守通用约定</p>
</li>
<li><p>覆盖equals时总要覆盖hashCode</p>
</li>
<li><p>始终要覆盖toString</p>
</li>
<li><p>谨慎的覆盖clone</p>
</li>
<li><p>考虑实现Comparable接口</p>
</li>
</ol>
<h1 id="类和接口"><a href="#类和接口" class="headerlink" title="类和接口"></a>类和接口</h1><ol start="15">
<li><p>使用类和成员的可访问性最小化</p>
</li>
<li><p>要在公有类而非公有域中使用访问方法</p>
</li>
<li><p>使可变性最小化</p>
</li>
<li><p>复合优先于集成</p>
</li>
<li><p>要么设计继承并提供文档说明，要么继承</p>
</li>
<li><p>接口优于抽象类</p>
</li>
<li><p>为后代设计接口</p>
</li>
<li><p>接口只用于定义类型</p>
</li>
<li><p>类层次优于标签类</p>
</li>
<li><p>静态成员类由于非静态成员类</p>
</li>
<li><p>限制源文件为单个顶级类</p>
</li>
</ol>
<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><ol start="26">
<li><p>请不要使用原生态类型</p>
</li>
<li><p>消除非受检的警告</p>
</li>
<li><p>列表由于数组</p>
</li>
<li><p>优先考虑泛型</p>
</li>
<li><p>优先考虑泛型方法</p>
</li>
<li><p>利用有限限制通配符来提升API的灵活性</p>
</li>
<li><p>谨慎并用泛型和可变参数</p>
</li>
<li><p>优先考虑类型安全的异构容器</p>
</li>
</ol>
<h1 id="枚举和注解"><a href="#枚举和注解" class="headerlink" title="枚举和注解"></a>枚举和注解</h1><ol start="34">
<li><p>用enum代替int常量</p>
</li>
<li><p>用实例域代替序数</p>
</li>
<li><p>用EnumSet代替位域</p>
</li>
<li><p>用EnumMap代替序数索引</p>
</li>
<li><p>用接口模拟可扩展的枚举</p>
</li>
<li><p>注解优先于明明模式</p>
</li>
<li><p>坚持使用Override注解</p>
</li>
<li><p>用标记接口定义类型</p>
</li>
</ol>
<h1 id="Lamda和stream"><a href="#Lamda和stream" class="headerlink" title="Lamda和stream"></a>Lamda和stream</h1><ol start="42">
<li><p>Lamda优先于匿名类</p>
</li>
<li><p>方法引用优先于Lamda</p>
</li>
<li><p>坚持使用标准的函数接口</p>
</li>
<li><p>谨慎使用Stream</p>
</li>
<li><p>优先选择Stream中无副作用的函数</p>
</li>
<li><p>Stream要优先用Collection作为返回类型</p>
</li>
<li><p>谨慎使用Stream并行</p>
</li>
</ol>
<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><ol start="49">
<li><p>检查参数的有效性</p>
</li>
<li><p>必要时进行保护性拷贝</p>
</li>
<li><p>谨慎设计方法签名</p>
</li>
<li><p>慎用重载</p>
</li>
<li><p>慎用可变参数</p>
</li>
<li><p>返回零长度的数组或者集合，而不是null</p>
</li>
<li><p>谨慎返回optional</p>
</li>
<li><p>为所有导出的API元素编写文档注释</p>
</li>
</ol>
<h1 id="通用编程"><a href="#通用编程" class="headerlink" title="通用编程"></a>通用编程</h1><ol start="57">
<li><p>将局部变量的作用域最小化</p>
</li>
<li><p>for-each循环优先传统的for循环</p>
</li>
<li><p>了解和使用类库</p>
</li>
<li><p>如果需要精确的答案，请避免使用float和double</p>
</li>
<li><p>基本类型优先于装箱基本类型</p>
</li>
<li><p>如果其他类型更适合，则尽量避免使用字符串</p>
</li>
<li><p>了解字符串连接的性能</p>
</li>
<li><p>通过接口引用对象</p>
</li>
<li><p>接口优先于反射机制</p>
</li>
<li><p>谨慎地使用本地方法</p>
</li>
<li><p>谨慎地进行优化</p>
</li>
<li><p>遵守普遍接受的命名惯例</p>
</li>
</ol>
<h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><ol start="69">
<li><p>只针对异常的情况才使用异常</p>
</li>
<li><p>对可恢复的情况使用受检异常，对编程错误使用运行时异常</p>
</li>
<li><p>避免不必要地使用受检异常</p>
</li>
<li><p>优先使用标准的异常</p>
</li>
<li><p>抛出与抽象对应的异常</p>
</li>
<li><p>每个方法抛出的所有异常都要建立文档</p>
</li>
<li><p>在细节消息中包含失败捕获信息</p>
</li>
<li><p>努力使失败保持原子性</p>
</li>
<li><p>不要忽略异常</p>
</li>
</ol>
<h1 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h1><ol start="78">
<li><p>同步访问共享的可变数据</p>
</li>
<li><p>避免过度同步</p>
</li>
<li><p>executor，task和stream优先于线程</p>
</li>
<li><p>并发工具优先于wait和notify</p>
</li>
<li><p>线程安全性的文档化</p>
</li>
<li><p>慎用延迟初始化</p>
</li>
<li><p>不要依赖于线程调度器</p>
</li>
</ol>
<h1 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h1><ol start="85">
<li><p>其他方法优先于Java序列化</p>
</li>
<li><p>谨慎地实现Serializable接口</p>
</li>
<li><p>考虑使用自定义地序列化形式</p>
</li>
<li><p>保护性地编写readOjbect方法</p>
</li>
<li><p>对于实例控制，枚举类型优先于readResolve</p>
</li>
<li><p>考虑用序列化代理代替序列化实例</p>
</li>
</ol>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sunnyhll.github.io/2020/02/22/Microservice-Architecture/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="果核&肉肉">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="微观天下">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/02/22/Microservice-Architecture/" class="post-title-link" itemprop="https://sunnyhll.github.io/index.html">Microservice Architecture</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-02-22 12:16:13" itemprop="dateCreated datePublished" datetime="2020-02-22T12:16:13+08:00">2020-02-22</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-04-04 23:09:36" itemprop="dateModified" datetime="2020-04-04T23:09:36+08:00">2020-04-04</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/架构/" itemprop="url" rel="index"><span itemprop="name">架构</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Why-Microservice"><a href="#Why-Microservice" class="headerlink" title="Why Microservice"></a>Why Microservice</h1><ul>
<li>Heterogenious technical stack：<br>支持多重技术栈，由于HTTP协议被多种编程语言支持，微服务可以用多种语言实现。</li>
<li>Robustness：整个App mesh网络不会因为单一的微服务的奔溃而停止工作。</li>
<li>Extensions：可以针对单一微服务进行扩展。</li>
<li>Simple deployment：微服务可以进行独立部署，不需要因为单一服务升级而多次部署。</li>
<li>Efficiency：微服务小团队开发高效敏捷。</li>
<li>More client support：多种前端客户端支持，可以重复利用同一个微服务后端网络。</li>
<li>Migration：基于单一微服务迁移的整体升级，阻碍更小。</li>
</ul>
<h1 id="What-is-Microservice"><a href="#What-is-Microservice" class="headerlink" title="What is Microservice"></a>What is Microservice</h1><p>微服务就是一些协同工作的小而自治的服务。</p>
<h1 id="How-to-architect-Microservices"><a href="#How-to-architect-Microservices" class="headerlink" title="How to architect Microservices"></a>How to architect Microservices</h1><h2 id="微服务特点"><a href="#微服务特点" class="headerlink" title="微服务特点"></a>微服务特点</h2><ul>
<li>Loose coupling松耦合</li>
</ul>
<ul>
<li>High Cohesion高内聚</li>
</ul>
<h2 id="上下文边界确定"><a href="#上下文边界确定" class="headerlink" title="上下文边界确定"></a>上下文边界确定</h2><p>业务或者职能的界限，往往也可以作为微服务架构中的服务边界。不同的业务只能之间的内部细节并不需要相互知晓。同一个事件，在不同的业务职能会有不同的体现，但是在内部细节上却没有相互交叉。</p>
<h2 id="共享和隐藏模型设计"><a href="#共享和隐藏模型设计" class="headerlink" title="共享和隐藏模型设计"></a>共享和隐藏模型设计</h2><p>限界上下文的确立，能够帮助确立共享模块，对于处于两个上下文边界上需要共同的消息，可以确立一个共享模块，专门进行信息共享。同时，对于上下文内部的逻辑，也能进行对应的逻辑模块设计，从而完成对于整个上下文的设计。</p>
<h2 id="切勿过早划分"><a href="#切勿过早划分" class="headerlink" title="切勿过早划分"></a>切勿过早划分</h2><p>对于一些过早划分的业务产品，警惕由于后期需求用例改变造成多个上下文之间的重叠。比较推荐的是先进行单体设计，不进行划分，在服务稳定之后再进行划分设计迁移，基于以有代码进行划分，比从头开始构建微服务简单得多。</p>
<h2 id="逐步划分上下文"><a href="#逐步划分上下文" class="headerlink" title="逐步划分上下文"></a>逐步划分上下文</h2><p>不断对上下文的界限进行迭代，从复杂的共享模型中慢慢抽出简单的共享模型，将嵌套的模块逐步上升到顶层模型，对其中某些紧密关联模型进行共享。当然，模型共享的粒度取决于代码是分开维护还是集中维护，如果是集中维护也未尝不可进行嵌套模型共享。</p>
<h1 id="微服务的集成"><a href="#微服务的集成" class="headerlink" title="微服务的集成"></a>微服务的集成</h1><p>微服务之间的通信机制，可以成为微服务的集成。微服务间的API相互调用设计需要注意一下几个方面：</p>
<ul>
<li><p>为用户创建接口</p>
<p>  用户上下文会触发一定特定的流程。</p>
</li>
<li><p>共享数据库</p>
<p>  数据库是多个微服务共享的，因为每个微服务都可能对同一个数据库进行修改。</p>
</li>
<li><p>同步与异步通信模式</p>
<p>  两种不同的通信模式中，同步模式会阻塞线程，而异步模式是基于事件响应请求的，能提降低耦合性，提高吞吐量。</p>
</li>
<li><p>编排与协同</p>
<p>  编排和协同是两种管理流程的架构风格。（同步）编排是通过一个中心执行者将每一步的步骤执行，知道获取最终的结果。（异步)协同则是以事件为机制进行执行，执行单元会订阅事件，API调用会触发一个事件，事件订阅者则会自动执行响应的流程。后者会需要监控服务，监控结果要映射到流程中，troubleshooting难度增加，这是一个难题。ATOM是一个符合REST规范的协议可以通过它提供资源feed的发布服务，客户端可以消费该信息。</p>
</li>
<li><p>RPC与REST</p>
<p>  远程调用允许进行本地调用，事实上是由某个远程服务器产生。RPC会有一定的技术耦合要求。protocol buffers, Thrift是比较推荐的RPC框架。REST则是RPC的一个替代方案。通过URI对客户端与服务器进行了松耦合。</p>
</li>
<li><p>Json与XML</p>
<p>  JSON与XML都是一种有效的数据序列化格式，前者更加流行XML对超媒体控制更加好。</p>
</li>
<li><p>API重定向</p>
<p>  API的重定向常常发生在多个API版本共存的时候，当老版本的API准备deco时，需要绞杀者模式将旧的API拦截，选择是否替换成新版本的实现。当旧版本的访问完全消失时，再删除旧的API。</p>
</li>
</ul>
<h1 id="拆分成微服务"><a href="#拆分成微服务" class="headerlink" title="拆分成微服务"></a>拆分成微服务</h1><ol>
<li>寻找独立的上下文边界——接缝</li>
<li>拆分数据库表格的混合加载功能，放弃直接利用数据库命令访问上下文边界间的外键，改为由代码（微服务服务API）</li>
<li>共享的静态数据改由配置维护关联。</li>
<li>针对共享数据，建立合适的领域进行关联，例如代码中建立客户关系，来维护财务——客户——仓库关系。</li>
<li>共享表格，对于有大量列信息的表格，可以根据上下文边界将表格拆分成两个。</li>
<li>自数据库开始进行代码重构。</li>
<li>事务的边界重构，对于多表的修改操作，需要协同处理错误，或者利用分布式事务处理工具代为管理事务。</li>
<li>拆分后的数据库在制作报表时会出现问题，因为不再能用sql语言进行表格操作。解决方法可以是主动定期导出表格合并，或者基于修改时间订阅导出行为。</li>
</ol>
<h1 id="部署微服务"><a href="#部署微服务" class="headerlink" title="部署微服务"></a>部署微服务</h1><ol>
<li>准备CI系统，流水线，自动化流程</li>
<li>Paas，Docker打包部署</li>
</ol>
<h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><ol>
<li>单元测试</li>
<li>服务测试(mock/打桩)</li>
<li>E2E测试 —— 消费者驱动的测试</li>
<li>上线 —— 金丝雀发布法</li>
</ol>
<h1 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h1><p>微服务的监控难度高于单一服务器应用。微服务包含多个服务，而每个服务的实例个数不等。关联标识可以帮忙关联同一个事件服务调用的日志，采用统一标准化的格式能够更快的辅助错误定位。</p>
<p>监控的内容包括CPU，响应时间，以及合理的语义监控（合成事务监控）。</p>
<h1 id="微服务安全"><a href="#微服务安全" class="headerlink" title="微服务安全"></a>微服务安全</h1><ol>
<li>身份验证和授权</li>
</ol>
<p>身份雅正确认了登录者的身份。授权机制能够确定登录者可以访问和进行的操作。常见的单点登录（Single Sign-On)，企业级标准为SAML和OpenID Connect，前者基于SOAP标准，后者基于OAuth2.0. 身份提供者可以是外部系统或者内部目录服务，如LDAP/AD等。</p>
<p>微服务的身份认证和授权部分可以依托于网关，网关可以作为认证代理，通过网管认证的所有查询和操作都可以发送到微服务集群任意一个实例中处理。微服务内部可以决定身份可以授权的操作。</p>
<ol start="2">
<li>服务间的身份验证和授权</li>
</ol>
<p>服务之间的身份验证是指微服务的各个服务之间的身份验证和授权，一般来说有如下几种方式管理:</p>
<ul>
<li>在微服务边界内允许一切</li>
<li>HTTP(S)基本身份验证（HTTP明文传输认证信息，如果基于SSL认证则需要管理多台服务器之间的自签发证书。）</li>
<li>使用SAML或OpenID Connect认证授权，可以有效的避免中间人攻击，这样每个服务也需要一个身份。</li>
<li>客户端证书（采用客户端X.509证书，通过TLS层协议对服务器验证进行保证。)</li>
<li>HMAC（Hash-based Message Authentication Code,请求主题和私有密钥一起被哈希处理后进行发送，服务器使用请求主题和自己私钥副本重建哈希值。如果匹配则接收，防止的中间人攻击。)</li>
<li>JWT(JSON Web Token,JWT的原则是在服务器身份验证之后，将生成一个JSON对象并将其发送回用户。当用户与服务器通信时，客户在请求中发回JSON对象。服务器仅依赖于这个JSON对象来标识用户。为了防止用户篡改数据，服务器将在生成对象时添加签名。)</li>
<li>API密钥(API密钥是给予某种形式的秘密令牌的名称，该秘密令牌与Web服务（或类似）请求一起提交以便识别请求的来源。密钥可以包括在请求内容的一些摘要中，以进一步验证原点并防止篡改值。)</li>
</ul>
<ol start="3">
<li>数据加密（现存多种算法进行数据加密，密钥可以通过加盐哈希保护）</li>
<li>深度防御</li>
</ol>
<ul>
<li>防火墙</li>
<li>日志</li>
<li>入侵监测</li>
<li>网络隔离</li>
<li>操作系统安全</li>
<li>OWASP标准(Open Web Application Security Project开放式Web应用程序安全项目,<a href="https://www.owasp.org" target="_blank" rel="noopener">https://www.owasp.org</a>)</li>
</ul>
<h1 id="系统设计与组织架构"><a href="#系统设计与组织架构" class="headerlink" title="系统设计与组织架构"></a>系统设计与组织架构</h1><p>公司团队的组织架构会影响系统设计。</p>
<ul>
<li><p>单地域的团队拥有更加好的灵活性和效率，因此对于异地团队最好的办法是想办法合理拆分，让不同的团队负责不同的松耦合模块。</p>
</li>
<li><p>每个团队需要负责对服务的需求，更改，构建，部署到运维，自治的团队能够很好的激励团队的效率。</p>
</li>
<li><p>小团队规模，少于10个人的团队能够对其所负责的系统整个生命周期负责，技术选择和实现上具有灵活性。当然这个对服务的高效构建部署效率很高，比如利用云服务的Infra来轻松构建CI/CD流程。</p>
</li>
</ul>
<h1 id="规模化微服务"><a href="#规模化微服务" class="headerlink" title="规模化微服务"></a>规模化微服务</h1><ul>
<li><p>允许故障无处不在，故障永远会在意想不到的时候发生，所以微服务本身需要能够允许故障出现，硬件上也不用为避免故障作特殊设计。</p>
</li>
<li><p>服务平行扩容阈值控制，需要参考一些系统参数，响应时间/延迟，可用性，数据持久性（丢包率）。</p>
</li>
<li><p>当故障出现时，适当的服务功能降级，允许应用能够在其他方面能够正确运行而不是直接返回错误界面。</p>
</li>
<li><p>微服务延迟的影响控制，通常会导致worker线程池的阻塞队列超长，最终线程池没有可用的线程而宕机。合理设置线程池的舱壁bulkhead，在舱位线程用尽后断路该服务，避免因为单个服务的延迟影响导致所有的线程都阻塞于同一个服务。</p>
</li>
<li><p>数据库扩展，当数据库需要服务于高吞吐量服务时，可以通过数据库副本，RDBMS系统，扩展写操作，独立CQRS读写分离系统，等多种方式扩展。</p>
</li>
<li><p>缓存可以优化重复请求，氛围哭护短、代理和服务器端缓存。</p>
</li>
<li><p>自动伸缩，当云管理能够强大到自动调整微服务实例个数，就可以基于当前流量进行自动调整。</p>
</li>
<li><p>CAP定理(一致性consistency、可用性availability和分区容忍性partition tolerance)是分布式系统中需要控制好的三个平衡。</p>
</li>
<li><p>服务发现，可以通过DNS服务器进行关联，负载均衡服务器将查询分发到不同的IP服务器上。</p>
</li>
<li><p>动态服务注册，新加入的微服务实例的IP应用信息需要能共享给其他服务，Zookeeper，consul和Eureka等服务可以管理配置管理和服务发现。</p>
</li>
<li><p>文档服务，为API构建合适的文档，Swagger可以很好的自动生成API文档，HAL和HAL浏览器也可以客户端逐步探索API。</p>
</li>
<li><p>自描述系统（UDDI Universal Description Discovery and Integration通用描述发现与集成服务），这个标准能帮助了解哪些服务正在运行。</p>
</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sunnyhll.github.io/2019/12/24/Java-Concurrency-In-Depth/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="果核&肉肉">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="微观天下">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/12/24/Java-Concurrency-In-Depth/" class="post-title-link" itemprop="https://sunnyhll.github.io/index.html">Java Concurrency In Depth</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-12-24 16:29:19" itemprop="dateCreated datePublished" datetime="2019-12-24T16:29:19+08:00">2019-12-24</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-12-09 13:19:57" itemprop="dateModified" datetime="2020-12-09T13:19:57+08:00">2020-12-09</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本文将从计算机底层实现的角度描述Java目前的并发工具的实现细节。</p>
<h1 id="Synchronized实现细节"><a href="#Synchronized实现细节" class="headerlink" title="Synchronized实现细节"></a>Synchronized实现细节</h1><p>JVM基于进入和退出Monitor对象来实现方法同步和代码块同步。即使用monitorenter和monitorexit指令实现的。</p>
<ul>
<li>monitorenter指令是在编译后插入到同步代码块的开始位置，而monitorexit是插入到方法结束处和异常处。</li>
<li>线程执行到monitorenter指令时会尝试获取对象所对应的monitor的所有权/对象锁。</li>
</ul>
<p>Synchronized用的锁是存在与Java对象头里。Java对象头的结构于<a href="/2018/11/07/JVM-memory-management-and-GC/#对象头">这里</a>。</p>
<p>锁一共有4种状态，级别从低到高分别是：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态。</p>
<p>偏向锁：</p>
<pre><code>1. 设置:当一个线程获取锁，对象锁从无锁状态变成偏向锁，允许该线程反复拿锁。（已经有identity hashcode的对象不会使用偏向锁）

2. 撤销：当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，撤销后变成无锁状态，膨胀成轻量级锁。（偏向对象如果需要identity hashcode则会膨胀成重量级锁）
</code></pre><p>** identity hash code： 未被覆写的 java.lang.Object.hashCode() 或者 java.lang.System.identityHashCode(Object) 所返回的值。</p>
<p>轻量级锁：</p>
<pre><code>1. 设置：JVM在当前线程栈帧中创建用于存储锁纪录的空间，并将对象头的MarkWord复制到锁纪录中。然后尝试用CAS操作将指向锁纪录指针放入MarkWord空间。如果成功，则获得锁，如果失败，则自旋来获取锁。

2. 解锁: CAS操作将Displaced MarkWord
放回到对象头，如果成功，表示没有竞争。如果失败说明存在竞争,即两个线程中解锁线程无法将MarkWord取回，因为另一个自旋线程已经尝试将MarkWord放到自己线程的锁记录中，CAS会发现MW的owner不是自己，膨胀成重量级锁。阻塞所有没拿到锁的线程。
</code></pre><p>重量级锁：</p>
<pre><code>1. 设置：重量级锁会阻塞拿不到锁的所有线程，减少了自旋带来的CPU开销。一旦升级成重量级锁，将不会降级锁。
</code></pre><h1 id="原子操作的实现原理"><a href="#原子操作的实现原理" class="headerlink" title="原子操作的实现原理"></a>原子操作的实现原理</h1><p>原子操作主要依赖的是计算机的如下几个CPU基本操作：</p>
<p><img src="/2019/12/24/Java-Concurrency-In-Depth/AtomicFundamentals.jpg" alt="AtomicFundamentals"></p>
<p>为了达到原子操作的目的，CPU会通过如下两种方式确保在某一时刻，只有一个CPU对共享内存中的数据进行写操作：</p>
<ol>
<li>通过总线锁保证原子性：CPU会提供一个LOCK #信号，将其他处理器的内存访问请求阻塞住，从而独占共享内存。</li>
<li>通过缓存所定保证原子性：需要处理器支持，开销较小，CPU修改缓存行进行缓存锁定，那么另一个CPU就不能同时缓存该内存数据，这是通过处理器的缓存以执行机制来保证的。</li>
</ol>
<p>JVM中是可以通过锁和循环CAS操作来保证该变量的赋值成功的。</p>
<p>其中循环CAS操作可能带来如下问题：</p>
<ol>
<li>ABA问题，值已经变化，但CAS的旧值比较返回true，解决方法是加入变量版本号。</li>
<li>循环时间开销大，可以通过JVM支持CPU的pause指令提升效率。</li>
<li>只能保证单一共享变量的原子性，可以通过AtomicReference方式合并变量成为一个新的对象处理。</li>
</ol>
<p>锁机制，除了偏向锁，锁本身就是通过循环CAS实现拿/释放锁。</p>
<h1 id="Lock锁实现细节"><a href="#Lock锁实现细节" class="headerlink" title="Lock锁实现细节"></a>Lock锁实现细节</h1><p>对比与synchronized中采用的锁，  Lock有如下不同之处:</p>
<p><img src="/2019/12/24/Java-Concurrency-In-Depth/LockSynchronized.png" alt="LockSynchronized"></p>
<p>以下是Lock的API介绍，本文将展示API的实现细节：<br><img src="/2019/12/24/Java-Concurrency-In-Depth/LockAPI.png" alt="LockAPI"></p>
<p>ReentrantLock的实现依赖于Java同步器框架，下面将着重讲解同步器框架的实现。对于公平锁和非公平锁的实现，AQS基本实现都一样，除了在公平锁释放节点是会调用hasQueuedPredecessors()方法判定是否队列中用等待节点，从而保证不会有线程在释放阶段竞争到锁，让线程串行化拿锁。</p>
<h2 id="队列同步器AQS框架实现细节"><a href="#队列同步器AQS框架实现细节" class="headerlink" title="队列同步器AQS框架实现细节"></a>队列同步器AQS框架实现细节</h2><blockquote>
<p><a href="http://www.cnblogs.com/waterystone/p/4920797.html" target="_blank" rel="noopener">http://www.cnblogs.com/waterystone/p/4920797.html</a></p>
</blockquote>
<p>类如其名，抽象的队列式的同步器，AQS定义了一套多线程访问共享资源的同步器框架，许多同步类实现都依赖于它，如常用的ReentrantLock/Semaphore/CountDownLatch。</p>
<p>实现细节在另一篇<a href="Java-Memory-Model/##实现细节">文章</a>已讲述。</p>
<p>同步器本身是一个抽象类，实现了同步器的类可以完成线程同步，包括：同步队列，独占式同步状态获取与释放，共享式同步状态获取与释放及超时获取同步状态。队列同步器使用了一个int成员变量表示同步状态，通过内置的FIFO队列来完成资源获取线程的排队工作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractQueueSynchronizer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标记锁状态， 0是无锁状态，非0则是同步队列有被阻塞节点/线程。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line">    <span class="comment">//同步状态相关方法</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> in <span class="title">getState</span><span class="params">()</span></span>; <span class="comment">// 获取当前的同步状态</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> newState)</span></span>; <span class="comment">//设置当前的同步状态</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span></span>; <span class="comment">//使用CAS设置当前状态，能够保证状态设置的原子性</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//支持重写的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> arg)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusive</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//模板方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquireNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanos)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquireSharedNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanos)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Collection&lt;Thread&gt; <span class="title">getQueuedThreads</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>支持重写方法的不同重写可以实现不同的锁，具体如下：<br><img src="/2019/12/24/Java-Concurrency-In-Depth/AQSoverride.png" alt="AQSoverride"></p>
<p>在实现重写方法可以调用模板方法，具体如下：<br><img src="/2019/12/24/Java-Concurrency-In-Depth/AQStemplate.png" alt="AQStemplate"></p>
<p>下文将分类别讲述模板方法的实现:</p>
<h3 id="同步队列"><a href="#同步队列" class="headerlink" title="同步队列"></a>同步队列</h3><p>同步器内部有一个同步队列（FIFO双向队列）进行同步状态管理。当前线程获取同步状态失败时，同步器会将当前线程及等待状态等信息构造成为一个节点并将其加入同步队列，同时会阻塞当前线程，当同步状态释放时，会把节点中的线程唤醒，使其再次尝试获取同步状态。</p>
<p><img src="/2019/12/24/Java-Concurrency-In-Depth/AQSQueue.png" alt="AQSQueue"></p>
<p>compareAndSetTail(…)方法基于CAS设置尾节点，保证队列更新的线程安全。<br>而头节点的更新是由获得锁的线程更新的，因此不需要作同步处理，是线程安全的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line">    <span class="keyword">private</span> Node prev;</span><br><span class="line">    <span class="keyword">private</span> Node next;</span><br><span class="line">    <span class="keyword">private</span> Node nextWaiter;</span><br><span class="line">    <span class="keyword">private</span> Thread thread;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体描述如下图所示：</p>
<p><img src="/2019/12/24/Java-Concurrency-In-Depth/Node.png" alt="Node"></p>
<ol>
<li>当首节点的线程成功地获取了同步状态/锁，该线程会将首节点设置为后继节点，并且将本节点的next引用断开即可。然后线程执行任务，任务完成后唤醒后继节点。具体的节点处理实现由锁的类型(独占/共享)的模板方法Release/ReleaseShared实现。</li>
</ol>
<p><img src="/2019/12/24/Java-Concurrency-In-Depth/Deque.jpg" alt="Dequeue"></p>
<ol start="2">
<li>当一个线程无法获取到同步状态，会被构造成节点加入到同步队列尾部，CAS设置能保证节点加入过程的线程安全。过程图如图所示。</li>
</ol>
<p><img src="/2019/12/24/Java-Concurrency-In-Depth/Enque.jpg" alt="Enqueue"></p>
<p>节点操作由具体的模板方法AcquireQueued/AcquireShared等实现，而节点封装和入队细节如下列代码所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Node head;</span><br><span class="line">    <span class="keyword">private</span> Node tail;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span></span>&#123;</span><br><span class="line">        Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">        <span class="comment">//快速尝试在尾部添加</span></span><br><span class="line">        Node pred = tail;</span><br><span class="line">        <span class="keyword">if</span>( pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">            node.prev = pred;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(pred, node))&#123;</span><br><span class="line">                pred.next = node;</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        enq(node);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 死循环保证了节点的添加在有并发冲突的情况也能成功</span></span><br><span class="line">        <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">            Node t = tail;</span><br><span class="line">            <span class="keyword">if</span>(t == <span class="keyword">null</span>)&#123;<span class="comment">//Must initialize</span></span><br><span class="line">                <span class="keyword">if</span>(compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                    tail = head;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                node.prev = t;</span><br><span class="line">                <span class="keyword">if</span>(compareAndSetTail(t, node))&#123;</span><br><span class="line">                    t.next = node;</span><br><span class="line">                    <span class="keyword">return</span> t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="独占式同步状态获取与释放"><a href="#独占式同步状态获取与释放" class="headerlink" title="独占式同步状态获取与释放"></a>独占式同步状态获取与释放</h3><p>独占式同步状态，是指在同一时刻只能有一个线程成功获取同步状态，锁的获取是排他的，不是共享的。</p>
<ol>
<li>独占式同步状态获取流程如图所示:<br><img src="/2019/12/24/Java-Concurrency-In-Depth/Acquire.jpg" alt="Acquire"></li>
</ol>
<p>相关的实现代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//在同步队列入队完成后，每个节点都在自旋等待，但是只有前驱是头节点的节点(头节点的next节点)才能有终端自旋的可能</span></span><br><span class="line">        <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span>(p == <span class="function">head $$ <span class="title">tryAcquire</span><span class="params">(arg)</span>)</span>&#123;</span><br><span class="line">                <span class="comment">//更新头节点</span></span><br><span class="line">                setHead(node);</span><br><span class="line">                <span class="comment">//断开头节点对后续节点的引用</span></span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">//help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(shouldParkAfterFailedAcquiredAcquire(p, node) &amp;&amp; parkAndCheckInterrupe())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol start="2">
<li>独占式同步状态释放<br>在当前线程获取了同步状态并执行后，需要释放同步状态，从而使得后续的同步节点可以获取同步状态。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tryRelease(arg))&#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span>(h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);<span class="comment">//使用lockSupport去唤醒等待状态的线程。</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="共享式同步状态获取与释放"><a href="#共享式同步状态获取与释放" class="headerlink" title="共享式同步状态获取与释放"></a>共享式同步状态获取与释放</h3><p>共享式获取与独占式获取最主要的区别在与同一时刻能否有多个线程同时获取到同步状态。以文件的读写为例，读操作可以是共享式访问，写操作则是独占式访问。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tryAcquireShared(arg) &lt; <span class="number">0</span>&gt;)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 自旋获取共享锁</span></span><br><span class="line">        <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head)&#123;</span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="comment">//获取到了同步状态</span></span><br><span class="line">                <span class="keyword">if</span>( r &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">if</span>(interrupted)</span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//tryReleaseShared通过自旋和CAS保证释放状态成功</span></span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        <span class="comment">//释放同步状态后，会唤醒处于等待状态的节点。</span></span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="独占式超时获取同步状态"><a href="#独占式超时获取同步状态" class="headerlink" title="独占式超时获取同步状态"></a>独占式超时获取同步状态</h3><p>超时获取同步状态，即在指定的时间段内获取同步状态，如果获取到同步状态则返回true，否则，返回false。具体流程如下: </p>
<p><img src="/2019/12/24/Java-Concurrency-In-Depth/Workflow.jpg" alt="Workflow"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">doAcquireNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">    <span class="keyword">long</span> lastTime = System.nanoTime();</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node,EXCLUSIVE);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">//确定时间内获取成功</span></span><br><span class="line">            <span class="keyword">if</span>(p == head &amp;&amp; tryAcquire(arg))&#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>;</span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//确定时间内获取失败</span></span><br><span class="line">            <span class="keyword">if</span>(nanosTimeout &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(shouldParkAfterFailedAcquire(p, node) &amp;&amp; nanosTimeout &gt; spinForTimeoutThreshold)</span><br><span class="line">                LockSupport.parkNanos(<span class="keyword">this</span> nanosTimeout);</span><br><span class="line">            <span class="keyword">long</span> now = System.nanoTime();</span><br><span class="line">            <span class="comment">// 计算lastTime到现在的睡眠时间，并且更新还应该睡眠的时间</span></span><br><span class="line">            nanosTimeout -= now - lastTime;</span><br><span class="line">            lastTime = now;</span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Condition实现细节"><a href="#Condition实现细节" class="headerlink" title="Condition实现细节"></a>Condition实现细节</h1><p>每个Condition对象都包含一个等待队列，Object包含一个AQS队列，两个队列节点是AQS中的Node，并用这个两个队列共同实现了wait/notify功能。</p>
<h2 id="等待"><a href="#等待" class="headerlink" title="等待"></a>等待</h2><p>Condition.await()让线程释放锁，构造新节点加入等待队列进入等待状态。返回的前提是重新获取了condition相关联的锁。底层是通过LockSupport的park()方法释放。</p>
<h2 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h2><p>Condition.signal()将等待队列中等待时间最长的节点加入同步队列，并用LockSupport.unpark()唤醒该节点。加入同步队列的节点通过tryAcquire()竞争获取锁，获取锁后从await()中返回继续执行。</p>
<h1 id="并发容器实现细节"><a href="#并发容器实现细节" class="headerlink" title="并发容器实现细节"></a>并发容器实现细节</h1><h2 id="ConcurrentHashMap实现细节"><a href="#ConcurrentHashMap实现细节" class="headerlink" title="ConcurrentHashMap实现细节"></a>ConcurrentHashMap实现细节</h2><blockquote>
<p>ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成。Segment是一种可重入锁ReentrantLock，在ConcurrentHashMap里扮演锁的角色，HashEntry则用于存储键值对数据。一个ConcurrentHashMap里包含一个Segment数组，Segment的结构和HashMap类似，是一种数组和链表结构， 一个Segment里包含一个HashEntry数组，每个HashEntry是一个链表结构的元素， 每个Segment守护者一个HashEntry数组里的元素,当对HashEntry数组的数据进行修改时，必须首先获得它对应的Segment锁。</p>
</blockquote>
<p><img src="/2019/12/24/Java-Concurrency-In-Depth/concurrentHashmap.png" alt="ConcurrentHashMap"></p>
<p>读取HashEntry信息是不需要拿锁，从而保证了并发读的高效性。HashMap中读取Map.Entry&lt;K,V&gt;是需要拿锁的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HashEntry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;  </span><br><span class="line">    <span class="keyword">final</span> K key; <span class="comment">// immutable field保证链表稳定性，新节点头插入,或者替换已有的值（不能重复value）。  </span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;  </span><br><span class="line">    <span class="keyword">volatile</span> V value;  <span class="comment">//volatile保证可见性，删除需要O(n)倒序复制被删节点前的list。</span></span><br><span class="line">    <span class="keyword">final</span> HashEntry&lt;K,V&gt; next;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在Hash中，会进行分段哈希从而保证segment中数组的均匀性，会对hash值的高字段和低字段进行分段处理，前半段获取segment位置，后端确定segment中数组中未知。</p>
<ul>
<li>get()操作不需要枷锁，除非读到的值为空才会加锁重读。</li>
<li>put()操作需要对加锁操作。扩容时，只会对某segment中的数组进行扩种。</li>
<li>size()操作会两次不加锁计算，当操作数没有变化，则直接返回，如果变化则加锁获取size。</li>
</ul>
<h2 id="阻塞队列实现原理"><a href="#阻塞队列实现原理" class="headerlink" title="阻塞队列实现原理"></a>阻塞队列实现原理</h2><h1 id="线程池并行执行机制Executor"><a href="#线程池并行执行机制Executor" class="headerlink" title="线程池并行执行机制Executor"></a>线程池并行执行机制Executor</h1><p>Java线程即是工作单元，也是执行机制。工作单元包括Runnable和Callable，而执行机制由Executor框架提供。应用程序通过Executor框架控制上层的调度，下层的调度由操作系统内核控制，下层调度不受应用程序的控制。<br><img src="/2019/12/24/Java-Concurrency-In-Depth/ExecutorMechanism.jpg" alt="Executor"></p>
<p>Executor接收<code>Runnable/Callable&lt;T&gt;</code>接口的实例的任务，返回<code>Future&lt;T&gt;</code>接口的<code>FutureTask&lt;T&gt;</code>实例，当任务完成时，可以获取任务执行结果。</p>
<h2 id="ThreadPoolExecutor-线程池-框架和实现原理"><a href="#ThreadPoolExecutor-线程池-框架和实现原理" class="headerlink" title="ThreadPoolExecutor (线程池)框架和实现原理"></a>ThreadPoolExecutor (线程池)框架和实现原理</h2><p>ThreadPoolExecutor可以有三种: FixedThreadPool, SingleThreadExecutor, CachedThreadPool。这三种是不同配置的ThreadPoolExecutor，并非不同子类型。</p>
<ul>
<li><p>FixedThreadPool:<br>FixedThreadPool是使用固定线程数的线程池，适用于为了满足资源管理的需求，而需要限制当前线程数量的应用场景，适用于负载较重的服务器。<br><img src="/2019/12/24/Java-Concurrency-In-Depth/FixedThreadPool.jpg" alt="FixedThreadPool"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads, <span class="number">0L</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());<span class="comment">//无界队列</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads, ThreadFactory threadFactory)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>SingleThreadExecutor:<br>SingleThreadExecutor是单个线程的线程“池”，适用于需要保证顺序执行的各个任务，并且保证没有多个线程活动的应用场景。<br><img src="/2019/12/24/Java-Concurrency-In-Depth/SingleThreadExecutor.jpg" alt="SingleThreadExecutor"></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">SingleThreadExecutor</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// FinalizableDelegatedExecutorService 增加对gc时停掉线程池的功能</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService(<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0L</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">SingleThreadExecutor</span><span class="params">(ThreadFactory threadFactory)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>CachedThreadPool:<br>CachedThreadPool是大小无界的线程池，适用于执行多的短期异步任务的小程序，适合负载较轻的服务器。<br><img src="/2019/12/24/Java-Concurrency-In-Depth/CachedThreadPool.jpg" alt="CachedThreadPool"></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">CachedThreadPool</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE, <span class="number">60L</span>, TimeUnit.SECONDS,<span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());<span class="comment">//使用没有容量的工作队列，因为线程数没有限制。</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">CachedThreadPool</span><span class="params">(ThreadFactory threadFactory)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="ThreadPoolExecutor实现原理"><a href="#ThreadPoolExecutor实现原理" class="headerlink" title="ThreadPoolExecutor实现原理"></a>ThreadPoolExecutor实现原理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class ThreadPoolExecutor&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> corePool; <span class="comment">// 核心线程池大小，当前运行线程数少于此则创建新线程至预热完成。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maximumPool; <span class="comment">//最大线程池的大小，当前线程数不会超过此，多的任务会挂起在工作阻塞队列中。</span></span><br><span class="line">    <span class="keyword">private</span> BlockingQueue&lt;Runnable&gt; workQueue; <span class="comment">//保存任务的工作队列，只要队列不为空，空闲的线程会获取任务并执行，直到任务队列为空。</span></span><br><span class="line">    <span class="keyword">private</span> RejectedExecutionHandler handler; <span class="comment">// 工作队列饱和时调用的handler</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> keepAliveTime; <span class="comment">//空闲线程存活时间</span></span><br><span class="line">    <span class="keyword">private</span> TimeUnit unit; <span class="comment">//空闲时间单位</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ScheduledThreadPoolExecutor-调度线程池）框架实现原理"><a href="#ScheduledThreadPoolExecutor-调度线程池）框架实现原理" class="headerlink" title="ScheduledThreadPoolExecutor (调度线程池）框架实现原理"></a>ScheduledThreadPoolExecutor (调度线程池）框架实现原理</h2><p>调度线程池是线程池实现的扩展，主要在给定的延迟后运行任务，或者定期执行任务。<br>ScheduledThreadPoolExecutor有两种: ScheduledThreadPoolExecutor和SingleThreadScheduledExecutor。</p>
<ul>
<li><p>ScheduledThreadPoolExecutor:<br>ScheduledThreadPoolExecutor是固定个数线程的调度线程池，适用于需要多个后台线程执行周期任务，同时为了满足资源管理的需求而需要限制后台线程的数量的应用场景。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize, ThreadFactory threadFactory)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>SingleThreadScheduledExecutor:<br>SingleThreadScheduledExecutor是单个后台线程执行周期任务，同事需要保证顺序地执行各个任务的应用场景。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">SingleThreadScheduledExecutor</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">SingleThreadScheduledExecutor</span><span class="params">(ThreadFactory threadFactory)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="ScheduledThreadPoolExecutor实现原理"><a href="#ScheduledThreadPoolExecutor实现原理" class="headerlink" title="ScheduledThreadPoolExecutor实现原理"></a>ScheduledThreadPoolExecutor实现原理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title">ThreadPoolExecutor</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> time; <span class="comment">// 任务要被执行的具体时间，当前时间大于等于time值时被执行</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> sequenceNumber; <span class="comment">// 任务被添加到Executor时的序号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> period; <span class="comment">// 任务执行的间隔周期</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>提交任务<br>ScheduledThreadPoolExecutor接受实现了RunnableScheduledFuture接口的ScheduledFutureTask实例。通过scheduleAtFixedRate()方法或者scheduleWithFixedDelay()方法提交，放在<code>DelayQueue&lt;RunnableScheduledFuture&gt;</code>中。<br><img src="/2019/12/24/Java-Concurrency-In-Depth/ScheduledTaskSubmission.jpg" alt="ScheduledTask"></p>
</li>
<li><p>执行任务<br>DelayQueue封装了一个PriorityQueue, 对队列中的ScheduledFutureTask进行排序，time小的排在前面。如果time值相同，则sequenceNumber小的在前面。</p>
</li>
<li><p>放回任务<br>对于执行过的周期任务，time值被重置为下一次的执行时间，并且将task放回DelayQueue中。</p>
</li>
</ol>
<h3 id="DelayQueue部分实现原理"><a href="#DelayQueue部分实现原理" class="headerlink" title="DelayQueue部分实现原理"></a>DelayQueue部分实现原理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayQueue</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Delayed</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ReentrantLoc lock;</span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;E&gt; q;</span><br><span class="line">    <span class="keyword">private</span> Thread leader;</span><br><span class="line">    <span class="keyword">private</span> Condition available;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lockInterruptibly(); <span class="comment">// 处理队列需要获得锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">                E first = q.peek();<span class="comment">// 线程锁住等待直到有task出现</span></span><br><span class="line">                <span class="keyword">if</span>( first == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    available.await();</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">long</span> deplay = first.getDelay(TimeUnit.NANOSECONDS);</span><br><span class="line">                    <span class="keyword">if</span>(delay &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="keyword">long</span> tl = available.awaitNanos(delay); <span class="comment">// wait nanoseonds for task to be ready to execute.</span></span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        E x = q.poll(); <span class="comment">// when task is ready, take the task and do</span></span><br><span class="line">                        <span class="keyword">assert</span> x != <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">if</span>( q.size() != <span class="number">0</span>)</span><br><span class="line">                            available.signalAll(); <span class="comment">//release condition</span></span><br><span class="line">                        <span class="keyword">return</span> x;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">offer</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            E first = q.peek(); </span><br><span class="line">            q.offer(e); <span class="comment">// 拿到锁后放入这个queue</span></span><br><span class="line">            <span class="keyword">if</span>(first == <span class="keyword">null</span>) || e.compareTo(first) &lt; <span class="number">0</span>)</span><br><span class="line">                available.singalAll(); <span class="comment">// 检查task是否到期可以执行，如果ready触发take的线程。</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ForkJoinPool-框架实现原理"><a href="#ForkJoinPool-框架实现原理" class="headerlink" title="ForkJoinPool 框架实现原理"></a>ForkJoinPool 框架实现原理</h2><p>ForkJoinPool由ForkJoinTask数组和ForkJoinWorkerThread数组组成，前者用于存放程序提交的任务，ForkJoinWorkerThread数组负责执行任务。</p>
<p>算法执行分两段，fork阶段将任务分割到足够小，创建/唤醒一个工作线程执行；join阶段将任务的结果收集合并结果得到最后的结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinTask</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ForkJoinTask&lt;V&gt; <span class="title">fork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ((ForkJoinWorkerThread) Thread.currentThread()).pushTask(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">join</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(doJoin() != NORMAL)</span><br><span class="line">            <span class="keyword">return</span> reportResult();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> getRawResult();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> V <span class="title">reportResult</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s; Throwable ex;</span><br><span class="line">        <span class="keyword">if</span>((s = status) == CANCELLED)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> CancellationException();</span><br><span class="line">        <span class="keyword">if</span>(s == EXCEPTIONAL &amp;&amp; (ex = getThrowableException()) != <span class="keyword">null</span>)</span><br><span class="line">            UNSAFE.throwException(ex);</span><br><span class="line">        <span class="keyword">return</span> getRawResult();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">doJoin</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Thread t; ForkJoinWorkerTHread w; <span class="keyword">int</span> s; <span class="keyword">boolean</span> completed;</span><br><span class="line">        <span class="keyword">if</span>((t = Thread.currentThread()) <span class="keyword">instanceof</span> ForkJoinWorkThread) &#123;</span><br><span class="line">            <span class="keyword">if</span> (( s = STATUS)  &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> s;</span><br><span class="line">            <span class="keyword">if</span>( ((w = (ForkJoineWorkerThread)t).unpushTask(<span class="keyword">this</span>))) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    completed = exec();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable rex) &#123;</span><br><span class="line">                    <span class="keyword">return</span>  setExceptionalCompletion( rex);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(completed)</span><br><span class="line">                    <span class="keyword">return</span> setCompletion(NORMAL);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> w.joinTask(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> exeternalAwaitDone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinWorkerThread</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">pushTask</span><span class="params">(ForkJoinTask&lt;?&gt; t)</span> </span>&#123;</span><br><span class="line">        ForkJoinTask&lt;?&gt;[] q; <span class="keyword">int</span> s, m;</span><br><span class="line">        <span class="keyword">if</span>((q = quque) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> u = (((s = queueTop) &amp; (m = q.length - <span class="number">1</span>)) &lt;&lt; ASHIFT) + ABASE;</span><br><span class="line">            UNSAFE.putOrderObject(q, u, t);</span><br><span class="line">            queueTop = s + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> ((s -= queueBase) &lt;= <span class="number">2</span>)</span><br><span class="line">                pool.singalWork();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s == m)</span><br><span class="line">                growQuque();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="异步执行机制"><a href="#异步执行机制" class="headerlink" title="异步执行机制"></a>异步执行机制</h1><h2 id="FutureTask实现原理"><a href="#FutureTask实现原理" class="headerlink" title="FutureTask实现原理"></a>FutureTask实现原理</h2><p>FutureTask实现了Future, Runnable接口。是Executor的执行任务单元，也可以由调用线程直接执行FutureTask.run()。FutureTask的get方法能阻塞当前线程，等待任务执行结果再执行下文。</p>
<p>FutureTask通过内部聚合的AQS的子类实现完成FUtureTask的获取和释放操作。队列中的每个FutureTask实例的get方法并不以一定需要在run方法之前执行，get方法会阻塞调用线程直到run方法被执行完成。每个任务只会执行一次，并且会有定义好的执行顺序，从get方法调用线程恢复执行上下文，从而达到异步调用的效果。类似.NET中的beginInvoke和endInvoke方法。<br><img src="/2019/12/24/Java-Concurrency-In-Depth/FutureTask.jpg" alt="Future"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt;, <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Sync sync;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        Callable.call();</span><br><span class="line">        ...</span><br><span class="line">        AQS.compareAndSetState(<span class="keyword">int</span> expect, <span class="keyword">int</span> update);</span><br><span class="line">        ...</span><br><span class="line">        AQS.releaseShared(<span class="keyword">int</span> arg);</span><br><span class="line">        ...</span><br><span class="line">        FutureTask.done();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        AQS.acquireSharedInterruptily(<span class="keyword">int</span> arg);</span><br><span class="line">        ...</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> V <span class="title">innerGet</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">innerRun</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">innerCancel</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="CompletableFuture实现原理"><a href="#CompletableFuture实现原理" class="headerlink" title="CompletableFuture实现原理"></a>CompletableFuture实现原理</h2><p>CompletableFuture实现了Future，CompletionStage接口，后者接口增加了更多对任务流程的控制接口，可以直接通过接口实现回调函数的定义。</p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sunnyhll.github.io/2019/10/19/Angular-Observables/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="果核&肉肉">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="微观天下">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/10/19/Angular-Observables/" class="post-title-link" itemprop="https://sunnyhll.github.io/index.html">Angular Observables</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-10-19 20:16:06" itemprop="dateCreated datePublished" datetime="2019-10-19T20:16:06+08:00">2019-10-19</time>
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="What-is-Observable"><a href="#What-is-Observable" class="headerlink" title="What is Observable"></a>What is Observable</h1><p>Observable利用观察者模式，建立了发布者publisher和订阅者subscriber之间的联系。联系本身不会修改发布的信息，只是定义声明了订阅者对发布信息的处理方式。</p>
<p>使用目的：</p>
<ol>
<li><p>流式处理本身是延迟执行的，即在需要数据的一刻进行处理，并且不改变数据本身而是生成一个新的流。多流处理的支持。</p>
</li>
<li><p>异步回调保证了流式处理结果的实时渲染，因此Observable是高性能前端的重要概念。可以将同步方法转换成异步方法。</p>
</li>
<li><p>支持事件处理，动态注册事件及句柄。</p>
</li>
</ol>
<h2 id="创建Observable"><a href="#创建Observable" class="headerlink" title="创建Observable"></a>创建Observable</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Observable&#125; <span class="keyword">from</span> <span class="string">'rxjs'</span>;</span><br><span class="line"><span class="comment">// subscriber/observer is callback functions for this observable.</span></span><br><span class="line"><span class="comment">// &#123;next, error, complete&#125;</span></span><br><span class="line"><span class="keyword">const</span> observable = <span class="keyword">new</span> Observable(<span class="function"><span class="params">subscriber</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// observable can decide how frequency next/error/complete callback is called.</span></span><br><span class="line">    subscriber.next(<span class="number">1</span>);</span><br><span class="line">    subscriber.next(<span class="number">2</span>);</span><br><span class="line">    subscriber.next(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        subscriber.next(<span class="number">4</span>);</span><br><span class="line">        subscriber.complete();</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;unsubscribe() &#123;&#125;&#125;;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="传入Observable回调函数-创建一个subscriber"><a href="#传入Observable回调函数-创建一个subscriber" class="headerlink" title="传入Observable回调函数/创建一个subscriber"></a>传入Observable回调函数/创建一个subscriber</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">observable.subscribe(&#123;</span><br><span class="line">    x =&gt; <span class="built_in">console</span>.log(<span class="string">'got value '</span> + x),</span><br><span class="line">    err =&gt; <span class="built_in">console</span>.error(<span class="string">'got error '</span> + err),</span><br><span class="line">    () =&gt; <span class="built_in">console</span>.log(<span class="string">'done'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="创建multicast-Observable"><a href="#创建multicast-Observable" class="headerlink" title="创建multicast Observable"></a>创建multicast Observable</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multicastSequenceSubscriber</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> observers = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> timeoutId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">observer</span>) =&gt;</span> &#123;</span><br><span class="line">        observers.push(observer);</span><br><span class="line">        <span class="comment">// start the sequence when firstly subscribed.</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( observers.length === <span class="number">1</span>) &#123;</span><br><span class="line">            timeoutId = doSequence(&#123;</span><br><span class="line">                next(val) &#123;</span><br><span class="line">                    <span class="comment">// 将所有observer封装成一个observer</span></span><br><span class="line">                    observers.forEach(<span class="function"><span class="params">obs</span> =&gt;</span> obs.next(val));</span><br><span class="line">                &#125;,</span><br><span class="line"></span><br><span class="line">                complete() &#123;</span><br><span class="line">                    observers.slice(<span class="number">0</span>).forEach( <span class="function"><span class="params">obs</span> =&gt;</span> obs.complete());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, seq, <span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            unsubscribe() &#123;</span><br><span class="line">                <span class="comment">//remove observer</span></span><br><span class="line">                observers.splice(observers.indexOf(observer), <span class="number">1</span>);</span><br><span class="line">                <span class="comment">// cancel subscription if no observers.</span></span><br><span class="line">                <span class="keyword">if</span>(observers.length === <span class="number">0</span>)&#123;</span><br><span class="line">                    clearTimeout(timeoutId);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> multicastObservable = <span class="keyword">new</span> Observerble(multicastSequenceSubscriber())</span><br><span class="line"></span><br><span class="line"><span class="comment">// subscribe to this observable</span></span><br><span class="line">multicastObservable.subscribe(&#123;</span><br><span class="line">    next(num) &#123; <span class="built_in">console</span>.log(num)&#125;</span><br><span class="line">    complete()&#123;&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">multicastObservable.subscribe(&#123;</span><br><span class="line">    next(num) &#123; <span class="built_in">console</span>.log(<span class="string">'second: '</span> + num)&#125;</span><br><span class="line">    complete()&#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="Observable关系操作符"><a href="#Observable关系操作符" class="headerlink" title="Observable关系操作符"></a>Observable关系操作符</h2><table>
<thead>
<tr>
<th style="text-align:left">Area</th>
<th style="text-align:center">Operator</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Creation</td>
<td style="text-align:center">from, fromEvent, of</td>
</tr>
<tr>
<td style="text-align:left">Comibination</td>
<td style="text-align:center">combineLatest,concat, merge, startWith, withLatestFrom, zip</td>
</tr>
<tr>
<td style="text-align:left">Filtering</td>
<td style="text-align:center">debounceTime, distinctUtilChanged, filter, take, takeUtil</td>
</tr>
<tr>
<td style="text-align:left">Transformation</td>
<td style="text-align:center">bufferTime, concatMap, map, mergeMap, scan, switchMap</td>
</tr>
<tr>
<td style="text-align:left">Utility</td>
<td style="text-align:center">tap</td>
</tr>
<tr>
<td style="text-align:left">Multicasting</td>
<td style="text-align:center">share</td>
</tr>
</tbody>
</table>
<p>Observable的关系操作符，是通过.pipe()引入的，更多的操作符，可以参考rxjs官方API文档<a href="https://www.learnrxjs.io/operators/" target="_blank" rel="noopener">here</a>。</p>
<h1 id="Using-observables-in-Angular"><a href="#Using-observables-in-Angular" class="headerlink" title="Using observables in Angular"></a>Using observables in Angular</h1><ul>
<li>EventEmitter</li>
<li>HTTP模块处理AJAX requests</li>
<li>Router, Forms 模块监听/响应用户输入</li>
</ul>
<h1 id="Observable-v-s-Promise"><a href="#Observable-v-s-Promise" class="headerlink" title="Observable v.s. Promise"></a>Observable v.s. Promise</h1><ul>
<li>共同点</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">方面</th>
<th style="text-align:center">细节</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">异步处理</td>
<td style="text-align:center">subscribe/then callback</td>
</tr>
<tr>
<td style="text-align:left">使用语言</td>
<td style="text-align:center">支持typescript, javascript</td>
</tr>
<tr>
<td style="text-align:left">支持HTTP</td>
<td style="text-align:center">通过Angular httpClient支持, observable.toPromise()</td>
</tr>
</tbody>
</table>
<ul>
<li>不同点</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">方面</th>
<th style="text-align:center">细节</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">使用场景</td>
<td style="text-align:center">O: 事件处理句柄, 流式处理； P: 链式处理</td>
</tr>
<tr>
<td style="text-align:left">操作符复杂度</td>
<td style="text-align:center">O:多样化； P:单一</td>
</tr>
</tbody>
</table>
<h1 id="Reactive-Programming"><a href="#Reactive-Programming" class="headerlink" title="Reactive Programming"></a>Reactive Programming</h1><p>使用异步数据流进行编程，通过代码来忠实反映业务之间的关系。</p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sunnyhll.github.io/2019/08/11/HTTP-protocol-introduction/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="果核&肉肉">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="微观天下">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/08/11/HTTP-protocol-introduction/" class="post-title-link" itemprop="https://sunnyhll.github.io/index.html">HTTP protocol introduction</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-08-11 21:57:54 / 修改时间：21:58:11" itemprop="dateCreated datePublished" datetime="2019-08-11T21:57:54+08:00">2019-08-11</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/HTTP/" itemprop="url" rel="index"><span itemprop="name">HTTP</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="HTTP-协议"><a href="#HTTP-协议" class="headerlink" title="HTTP 协议"></a>HTTP 协议</h1><p>HTTP协议属于应用层协议，其设计目的是为了方便文本内容的分享与发布。HTTP协议是Web资源共享的基础，与URL(文档地址定位符)，HTML共同构建了Web世界。</p>
<p>HTTP协议属于点到点通信协议，请求访问资源的一端称为客户端，提供资源相应的一端称为服务器。</p>
<h2 id="HTTP协议方法"><a href="#HTTP协议方法" class="headerlink" title="HTTP协议方法"></a>HTTP协议方法</h2><ul>
<li>GET：请求访问资源。</li>
<li>POST：传输主体内容。</li>
<li>PUT：传输内容，幂等传输。</li>
<li>HEAD: 获得报文首部，用于确认资源有效性和更新日期。</li>
<li>DELETE: 删除内容。</li>
<li>OPTIONS: 询问资源支持方法。</li>
<li>TRACE：追踪路径，用于计算客户端到服务器端的跳数。</li>
<li>CONNECT: 要求用socket协议连接代理。</li>
</ul>
<p>HTTP方法本身是无状态协议，为了支持复杂有状态场景，引入了Cookie技术，确保认证客户端通信的上下文是连续的。</p>
<h2 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h2><table>
<thead>
<tr>
<th style="text-align:left"></th>
<th style="text-align:left">类别</th>
<th style="text-align:left">原因短语</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1XX</td>
<td style="text-align:left">Informational(信息性状态码)</td>
<td style="text-align:left">接收的请求正在处理</td>
</tr>
<tr>
<td style="text-align:left">2XX</td>
<td style="text-align:left">Success（成功状态码）</td>
<td style="text-align:left">请求正常处理完毕</td>
</tr>
<tr>
<td style="text-align:left">3XX</td>
<td style="text-align:left">Redirection（重定向状态码）</td>
<td style="text-align:left">需要进行附加操作以完成请求</td>
</tr>
<tr>
<td style="text-align:left">4XX</td>
<td style="text-align:left">Client Error（客户端错误状态码）</td>
<td style="text-align:left">服务器无法处理请求</td>
</tr>
<tr>
<td style="text-align:left">5XX</td>
<td style="text-align:left">Server Error(服务器错误状态码)</td>
<td style="text-align:left">服务器处理请求出错</td>
</tr>
</tbody>
</table>
<h2 id="HTTP协议架构中的转发功能节点"><a href="#HTTP协议架构中的转发功能节点" class="headerlink" title="HTTP协议架构中的转发功能节点"></a>HTTP协议架构中的转发功能节点</h2><ul>
<li>代理：代理服务器的基本行为是接收客户端发送的请求转发给其他服务器，不改变请求URI。分为两类：<ol>
<li>缓存代理：缓存内容。</li>
<li>透明代理：纯粹内容转发，不做缓存。</li>
</ol>
</li>
<li>网关：网关为通信链路上的服务器提供非HTTP协议连接，例如与信用卡结算系统联动，数据库联动等。</li>
<li>隧道：隧道的建立能够确保客户端与服务器之间安全的通信。也能扩展HTTP通信协议，例如支持推送功能等等。</li>
</ul>
<h1 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h1><h2 id="HTTP协议的缺点："><a href="#HTTP协议的缺点：" class="headerlink" title="HTTP协议的缺点："></a>HTTP协议的缺点：</h2><ol>
<li>明文信息会被窃听；</li>
<li>无法验证通信方身份，会被伪装；</li>
<li>无法验证报文的完整性，会被篡改。</li>
</ol>
<h2 id="HTTP-over-SSL-TSL"><a href="#HTTP-over-SSL-TSL" class="headerlink" title="HTTP over SSL/TSL"></a>HTTP over SSL/TSL</h2><p>SSL/TSL协议独立与HTTP协议，存在于HTTP和TCP协议之间，在建立HTTP连接之前，先建立SSL通信机制，交换加密密钥，从而在HTTP通信报文可以进行加密传输。</p>
<p>HTTPS 协议通信握手/分手协议步骤：</p>
<p><img src="/2019/08/11/HTTP-protocol-introduction/HTTPS.jpg" alt="HTTPS"></p>
<p>握手主要分为4个阶段:</p>
<ol>
<li>SSL证书请求，及公钥获取。&lt;= 由于非对称加密机制的效率较低，安全性高，只用作密钥交互。</li>
<li>客户端密钥加密发送。</li>
<li>服务器端密钥确认。</li>
<li>数据传输… &lt;= 数据传输阶段的加密是基于协商确定的对称密钥发送，效率较高。</li>
</ol>
<h1 id="WebSocket协议"><a href="#WebSocket协议" class="headerlink" title="WebSocket协议"></a>WebSocket协议</h1><p>Web浏览器支持的全双工通信协议，在HTTP部首加入upgrade：websocket字段，服务器通过返回状态码101 swtiching protocols响应连接，一旦服务器与客户端建立WebSocket协议的通信连接，之后所有的通信都用这个专用协议进行。</p>
<ul>
<li>推送功能： 服务器可以直接发送数据到客户端。</li>
<li>减少通信量：保持连接的状态减少HTTP协议的连接开销。</li>
</ul>
<h1 id="用户认证问题"><a href="#用户认证问题" class="headerlink" title="用户认证问题"></a>用户认证问题</h1><p>HTTP/1.1常见的认证方式如下：</p>
<ul>
<li>BASIC认证：直接提交用户名密码完成认证。<br><img src="/2019/08/11/HTTP-protocol-introduction/BASIC.jpg" alt="BASIC"></li>
<li>DIGEST认证：客户端根据服务器端的质询码生成响应码完成认证。<br><img src="/2019/08/11/HTTP-protocol-introduction/DIGEST.jpg" alt="DIGEST"></li>
<li>SSL客户端认证：凭借HTTPS的客户端认证证书完成认证。</li>
<li>FormBase认证：在用户登录信息以表单形式提交后，服务器端发放Session ID用于用户认证状态的绑定和保持。<br><img src="/2019/08/11/HTTP-protocol-introduction/FORMBASED.jpg" alt="FORM"></li>
<li>Kerberos认证：</li>
<li>NTLM认证：</li>
<li>SSO认证：</li>
</ul>
<h1 id="Web安全问题"><a href="#Web安全问题" class="headerlink" title="Web安全问题"></a>Web安全问题</h1><ul>
<li>跨站脚本工具XSS：通过执行非法HTML标签/JS脚本进行攻击。<ol>
<li>表单中插入非法标签执行JS脚本。</li>
<li>基于用户Cookie的窃取攻击</li>
</ol>
</li>
<li>SQL注入攻击：通过加入SQL结束符，强制加入SQL语句执行。</li>
<li>OS命令攻击:通过Shell脚本注入执行系统命令。</li>
<li>HTTP部首注入攻击：通过访问URL加入换行符，注入HTTP首部字段进行攻击。<ol>
<li>Cookie设置字段生效。</li>
<li>HTTP响应截断攻击，强制显示伪造内容。</li>
</ol>
</li>
<li>邮件首部注入攻击: <ol>
<li>BCC邮件泄露。</li>
</ol>
</li>
<li>目录遍历攻击: 访问无疑公开的文件目录。</li>
<li>远程文件包含漏洞：引入其他包，例如System包进行代码污染。</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sunnyhll.github.io/2019/04/24/Java-Xml-Libraries/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="果核&肉肉">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="微观天下">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/04/24/Java-Xml-Libraries/" class="post-title-link" itemprop="https://sunnyhll.github.io/index.html">Java Xml Libraries</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-04-24 22:14:19" itemprop="dateCreated datePublished" datetime="2019-04-24T22:14:19+08:00">2019-04-24</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-05-06 22:15:35" itemprop="dateModified" datetime="2019-05-06T22:15:35+08:00">2019-05-06</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本文描述了当前主流的Java Xml libraries，以及对比区别。</p>
<blockquote>
<p>下文摘取自<a href="https://www.baeldung.com/java-xml-libraries" target="_blank" rel="noopener">https://www.baeldung.com/java-xml-libraries</a></p>
</blockquote>
<ul>
<li><p>SAX: It is an event based parsing API, it provides a low level access, is memory efficient and faster than DOM since it doesn’t load the whole document tree in memory but it doesn’t provide support for navigation like the one provided by XPath, although it is more efficient it is harder to use too.</p>
</li>
<li><p>DOM(DOM4J and JDOM): It as model based parser that loads a tree structure document in memory, so we have the original elements order, we can navigate our document both directions, it provides an API for reading and writing, it offers XML manipulation and it is very easy to use although the price is high strain on memory resources.</p>
</li>
<li><p>StAX: It offers the ease of DOM and the efficiency of SAX but it lacks of some functionality provided by DOM like XML manipulation and it only allows us to navigate the document forward.</p>
</li>
<li><p>JAXB: It allows us to navigate the document in both directions, it is more efficient than DOM, it allows conversion from XML to java types and it supports XML manipulation but it can only parse a valid XML document.</p>
</li>
</ul>
<p><img src="/2019/04/24/Java-Xml-Libraries/JavaXmlLibs.png" alt="JavaXmlLibs"></p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">果核&肉肉</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">30</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">8</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">15</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">果核&肉肉</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v6.5.0</div>




        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv" title="总访客量">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
    </span>
  

  
    <span class="site-pv" title="总访问量">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
    </span>
  
</div>









        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.5.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.5.0"></script>



  



  










  





  

  

  

  

  

  
  

  

  

  

  

  

  

</body>
</html>
