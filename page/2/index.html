<!DOCTYPE html>












  


<html class="theme-next muse use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.5.0" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.5.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.5.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.5.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.5.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '6.5.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta property="og:type" content="website">
<meta property="og:title" content="微观天下">
<meta property="og:url" content="https://sunnyhll.github.io/page/2/index.html">
<meta property="og:site_name" content="微观天下">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="微观天下">






  <link rel="canonical" href="https://sunnyhll.github.io/page/2/">



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>微观天下</title>
  











  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">微观天下</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sunnyhll.github.io/2019/04/24/Java-Xml-Libraries/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="果核&肉肉">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="微观天下">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/04/24/Java-Xml-Libraries/" class="post-title-link" itemprop="https://sunnyhll.github.io/page/2/index.html">Java Xml Libraries</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-04-24 22:14:19" itemprop="dateCreated datePublished" datetime="2019-04-24T22:14:19+08:00">2019-04-24</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-05-06 22:15:35" itemprop="dateModified" datetime="2019-05-06T22:15:35+08:00">2019-05-06</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本文描述了当前主流的Java Xml libraries，以及对比区别。</p>
<blockquote>
<p>下文摘取自<a href="https://www.baeldung.com/java-xml-libraries" target="_blank" rel="noopener">https://www.baeldung.com/java-xml-libraries</a></p>
</blockquote>
<ul>
<li><p>SAX: It is an event based parsing API, it provides a low level access, is memory efficient and faster than DOM since it doesn’t load the whole document tree in memory but it doesn’t provide support for navigation like the one provided by XPath, although it is more efficient it is harder to use too.</p>
</li>
<li><p>DOM(DOM4J and JDOM): It as model based parser that loads a tree structure document in memory, so we have the original elements order, we can navigate our document both directions, it provides an API for reading and writing, it offers XML manipulation and it is very easy to use although the price is high strain on memory resources.</p>
</li>
<li><p>StAX: It offers the ease of DOM and the efficiency of SAX but it lacks of some functionality provided by DOM like XML manipulation and it only allows us to navigate the document forward.</p>
</li>
<li><p>JAXB: It allows us to navigate the document in both directions, it is more efficient than DOM, it allows conversion from XML to java types and it supports XML manipulation but it can only parse a valid XML document.</p>
</li>
</ul>
<p><img src="/2019/04/24/Java-Xml-Libraries/JavaXmlLibs.png" alt="JavaXmlLibs"></p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sunnyhll.github.io/2019/04/12/Office-365-Addin-development-guide/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="果核&肉肉">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="微观天下">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/04/12/Office-365-Addin-development-guide/" class="post-title-link" itemprop="https://sunnyhll.github.io/page/2/index.html">Office 365 Addin development guide</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-04-12 22:16:53" itemprop="dateCreated datePublished" datetime="2019-04-12T22:16:53+08:00">2019-04-12</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-07-15 16:20:03" itemprop="dateModified" datetime="2019-07-15T16:20:03+08:00">2019-07-15</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>This is a guide for how to develop Office 365 cross platform addin.</p>
<h1 id="Front-end-UI-framework"><a href="#Front-end-UI-framework" class="headerlink" title="Front end UI framework"></a>Front end UI framework</h1><p>Microsoft has provided offical Office UI framework: Office Fabric UI. The office site is at <a href="https://developer.microsoft.com/en-us/fabric" target="_blank" rel="noopener">https://developer.microsoft.com/en-us/fabric</a>. The are three directions of the UI project future roadmap. All the three projects are implementation of UI components, demos are available at <a href="https://developer.microsoft.com/en-us/fabric#/components" target="_blank" rel="noopener">https://developer.microsoft.com/en-us/fabric#/components</a>.</p>
<ol>
<li>Fabric React (Official support)</li>
<li>AngularJS (Community version, no updates)</li>
<li>Fabric iOS</li>
<li>Fabric JS (Stop support from MSFT)</li>
</ol>
<p>New UI design sytem is called fluent, the website is at <a href="https://www.microsoft.com/design/fluent/" target="_blank" rel="noopener">https://www.microsoft.com/design/fluent/</a>. It can help let developer know how to design an Windows style application UI and the guide of UWP web app design. </p>
<p>Fabric.js is an open source js framework using canvas as the basic style of UI components, the official site is at <a href="http://fabricjs.com/" target="_blank" rel="noopener">http://fabricjs.com/</a>.</p>
<h2 id="Useful-links"><a href="#Useful-links" class="headerlink" title="Useful links:"></a>Useful links:</h2><p>Directly reuse existing Microsoft designed and implemented components is very convinient as long as your application can work well with these codes.</p>
<ul>
<li>Office UI Fabric Core (Style and fonts): <a href="https://github.com/OfficeDev/office-ui-fabric-core" target="_blank" rel="noopener">https://github.com/OfficeDev/office-ui-fabric-core</a></li>
<li>Office UI Fabric React (Full components): <a href="https://github.com/OfficeDev/office-ui-fabric-react" target="_blank" rel="noopener">https://github.com/OfficeDev/office-ui-fabric-react</a></li>
<li>Office UI Fabric JS (Full components in JS): <a href="https://github.com/OfficeDev/office-ui-fabric-js/" target="_blank" rel="noopener">https://github.com/OfficeDev/office-ui-fabric-js/</a></li>
</ul>
<p>Except Windows style UI frameworks, there are other frameworks using morden components:</p>
<ul>
<li>Material-UI: <a href="https://www.jianshu.com/p/b3cfaca94596" target="_blank" rel="noopener">https://www.jianshu.com/p/b3cfaca94596</a> , <a href="https://material-ui.com/getting-started/example-projects/" target="_blank" rel="noopener">https://material-ui.com/getting-started/example-projects/</a></li>
<li>PrimeNG: <a href="https://www.primefaces.org/primeng" target="_blank" rel="noopener">https://www.primefaces.org/primeng</a> </li>
</ul>
<h1 id="Front-end-Office-js-framework"><a href="#Front-end-Office-js-framework" class="headerlink" title="Front end Office.js framework"></a>Front end Office.js framework</h1><p>Office.js is the JavaScript based Office model provided by Microsoft, there are also Excel-15.js or Outlook-15.js for application respectively.</p>
<h2 id="Office-JavaScript-API-object-model"><a href="#Office-JavaScript-API-object-model" class="headerlink" title="Office JavaScript API object model"></a>Office JavaScript API object model</h2><p>This doc <a href="https://docs.microsoft.com/en-us/office/dev/add-ins/develop/office-javascript-api-object-model" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/office/dev/add-ins/develop/office-javascript-api-object-model</a> explains the API model for new O365 addin JS model.</p>
<p>The object is still under active development, there are more and more new features added, reading the documents can get the updated information. As for now, there are below bullet points:</p>
<p><img src="/2019/04/12/Office-365-Addin-development-guide/AddinJSModel.PNG" alt="JSAddinFeatures"></p>
<p>This is also guide for how to develop Addin with Angular front end. <a href="https://docs.microsoft.com/en-us/office/dev/add-ins/develop/add-ins-with-angular2" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/office/dev/add-ins/develop/add-ins-with-angular2</a></p>
<p>Office appication has its own object model, so developers can read the related documents for detailed guide.</p>
<h2 id="Outlook-Backend-service"><a href="#Outlook-Backend-service" class="headerlink" title="Outlook Backend service"></a>Outlook Backend service</h2><p>Except the general Office JS API model, Outlook has its own API. The development guide is at <a href="https://docs.microsoft.com/en-us/outlook/add-ins/" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/outlook/add-ins/</a>. </p>
<h3 id="Manifest-version-and-corresponding-clients-support"><a href="#Manifest-version-and-corresponding-clients-support" class="headerlink" title="Manifest version and corresponding clients support"></a>Manifest version and corresponding clients support</h3><p><img src="/2019/04/12/Office-365-Addin-development-guide/ClientSupport.PNG" alt="ClientSupport"></p>
<p>Troubleshooting manifest file <a href="https://docs.microsoft.com/en-us/office/dev/add-ins/testing/troubleshoot-manifest#to-use-the-office-add-in-validator-to-validate-your-manifest" target="_blank" rel="noopener">here</a></p>
<h3 id="Outlook-Web-Addin-Catalogs"><a href="#Outlook-Web-Addin-Catalogs" class="headerlink" title="Outlook Web Addin Catalogs"></a>Outlook Web Addin Catalogs</h3><p>Outlook Addin has its own concepts and there are many aspects:</p>
<p><img src="/2019/04/12/Office-365-Addin-development-guide/OutlookConcepts.PNG" alt="OutlookCatalog"></p>
<h3 id="Sample-Addins-for-Outlook"><a href="#Sample-Addins-for-Outlook" class="headerlink" title="Sample Addins for Outlook"></a>Sample Addins for Outlook</h3><p><a href="https://developer.microsoft.com/zh-cn/outlook/gallery/?filterBy=Outlook,Samples,Add-ins" target="_blank" rel="noopener">https://developer.microsoft.com/zh-cn/outlook/gallery/?filterBy=Outlook,Samples,Add-ins</a> </p>
<h1 id="Other-Office-Web-Addin-Demos"><a href="#Other-Office-Web-Addin-Demos" class="headerlink" title="Other Office Web Addin Demos"></a>Other Office Web Addin Demos</h1><ul>
<li>Word Style Checker: <a href="https://github.com/OfficeDev/Word-Add-in-Angular2-StyleChecker" target="_blank" rel="noopener">https://github.com/OfficeDev/Word-Add-in-Angular2-StyleChecker</a></li>
<li>Word task pane add-in: <a href="https://github.com/OfficeDev/Office-Add-in-Fabric-UI-Sample" target="_blank" rel="noopener">https://github.com/OfficeDev/Office-Add-in-Fabric-UI-Sample</a></li>
<li>Outlook Addin: <a href="https://github.com/OfficeDev/outlook-add-in-attachments-demo" target="_blank" rel="noopener">https://github.com/OfficeDev/outlook-add-in-attachments-demo</a></li>
<li>Word dialog Addin: <a href="https://github.com/OfficeDev/Office-Add-in-Dialog-API-Simple-Example" target="_blank" rel="noopener">https://github.com/OfficeDev/Office-Add-in-Dialog-API-Simple-Example</a></li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sunnyhll.github.io/2019/03/29/Git-best-practices/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="果核&肉肉">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="微观天下">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/03/29/Git-best-practices/" class="post-title-link" itemprop="https://sunnyhll.github.io/page/2/index.html">Git best practices</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-03-29 22:37:46" itemprop="dateCreated datePublished" datetime="2019-03-29T22:37:46+08:00">2019-03-29</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-05-06 22:15:34" itemprop="dateModified" datetime="2019-05-06T22:15:34+08:00">2019-05-06</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Git/" itemprop="url" rel="index"><span itemprop="name">Git</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Git-基本操作"><a href="#Git-基本操作" class="headerlink" title="Git 基本操作"></a>Git 基本操作</h1><h2 id="创建Git仓库"><a href="#创建Git仓库" class="headerlink" title="创建Git仓库"></a>创建Git仓库</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>
<h2 id="查看代码情况"><a href="#查看代码情况" class="headerlink" title="查看代码情况"></a>查看代码情况</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br><span class="line">git diff &#123;filepath&#125;</span><br></pre></td></tr></table></figure>
<h2 id="提交代码"><a href="#提交代码" class="headerlink" title="提交代码"></a>提交代码</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> &#123;clone.git&#125;</span><br><span class="line">git add -A</span><br><span class="line">git commit -m <span class="string">"message"</span></span><br><span class="line">git push orgin master</span><br></pre></td></tr></table></figure>
<h2 id="保存-恢复临时修改文件"><a href="#保存-恢复临时修改文件" class="headerlink" title="保存/恢复临时修改文件"></a>保存/恢复临时修改文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git stash</span><br><span class="line">git checkout stash@&#123;0&#125; -- &#123;filepath&#125;</span><br></pre></td></tr></table></figure>
<h2 id="读取文件历史版本"><a href="#读取文件历史版本" class="headerlink" title="读取文件历史版本"></a>读取文件历史版本</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout &#123;commithash&#125; -- &#123;filepath&#125;</span><br></pre></td></tr></table></figure>
<h2 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git tag -a v1.0  <span class="comment"># tag most recent commit</span></span><br><span class="line">git tag -a v0.9 85fc7e7 <span class="comment"># tag on a specific commit</span></span><br><span class="line">git tag <span class="comment"># view tags</span></span><br></pre></td></tr></table></figure>
<h1 id="Pull-Fork工作流"><a href="#Pull-Fork工作流" class="headerlink" title="Pull/Fork工作流"></a>Pull/Fork工作流</h1><ol>
<li>fork from the github</li>
<li><p>clone to local and commit changes</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> &#123;clone.git&#125;</span><br><span class="line">git checkout -b feature</span><br><span class="line"><span class="comment"># make changes to this branch</span></span><br><span class="line">git add -p</span><br><span class="line">git commit -m <span class="string">"feature message"</span></span><br><span class="line">git push origin feature</span><br></pre></td></tr></table></figure>
</li>
<li><p>rebase commits after remote master</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git remote add upstream &#123;remote.git&#125;</span><br><span class="line">git pull upstream master</span><br><span class="line"><span class="comment"># no changes on master, then automatically git history is updated</span></span><br><span class="line">git checkout feature</span><br><span class="line">git pull --rebase origin master</span><br><span class="line"><span class="comment"># apply changes from origin master to feature newly commits</span></span><br><span class="line">git push origin feature --force</span><br></pre></td></tr></table></figure>
</li>
<li><p>raise pull request for code review</p>
</li>
</ol>
<h1 id="提交历史管理"><a href="#提交历史管理" class="headerlink" title="提交历史管理"></a>提交历史管理</h1><h2 id="缩减冗余commit-log"><a href="#缩减冗余commit-log" class="headerlink" title="缩减冗余commit log"></a>缩减冗余commit log</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># rewrite last 10 commit logs</span></span><br><span class="line">git rebase -i HEAD~10 feature</span><br><span class="line">git push orign feature --force</span><br></pre></td></tr></table></figure>
<h1 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h1><h2 id="创建新分支"><a href="#创建新分支" class="headerlink" title="创建新分支"></a>创建新分支</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b feature</span><br><span class="line"><span class="comment"># create a branch based on current branch</span></span><br></pre></td></tr></table></figure>
<h2 id="切换分支-从Detached-HEAD切换"><a href="#切换分支-从Detached-HEAD切换" class="headerlink" title="切换分支/从Detached HEAD切换"></a>切换分支/从Detached HEAD切换</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout feature</span><br></pre></td></tr></table></figure>
<h2 id="删除本地分支"><a href="#删除本地分支" class="headerlink" title="删除本地分支"></a>删除本地分支</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch -d feature</span><br><span class="line">git branch -D feature <span class="comment"># force delete</span></span><br></pre></td></tr></table></figure>
<h2 id="删除远程分支"><a href="#删除远程分支" class="headerlink" title="删除远程分支"></a>删除远程分支</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push orgin --delete feature</span><br></pre></td></tr></table></figure>
<h2 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git merge feature</span><br><span class="line"><span class="comment"># merge changes from feature branch to current master branch</span></span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sunnyhll.github.io/2019/02/13/JVM-Bytecode-Execution-Engine-Subsystem/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="果核&肉肉">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="微观天下">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/02/13/JVM-Bytecode-Execution-Engine-Subsystem/" class="post-title-link" itemprop="https://sunnyhll.github.io/page/2/index.html">JVM Bytecode Execution Engine Subsystem</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-02-13 22:44:35" itemprop="dateCreated datePublished" datetime="2019-02-13T22:44:35+08:00">2019-02-13</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-05-06 22:15:34" itemprop="dateModified" datetime="2019-05-06T22:15:34+08:00">2019-05-06</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>JVM执行引擎是Java虚拟机核心组件之一。物理机的执行引擎是直接建立在处理器、硬件、指令集和操作系统层面上，而虚拟机的执行引擎是自己实现的，可以自行制定指令集与执行引擎的结构体系，并且能够执行那些不被硬件直接支持的指令集格式。</p>
<h1 id="运行时栈帧结构"><a href="#运行时栈帧结构" class="headerlink" title="运行时栈帧结构"></a>运行时栈帧结构</h1><p>栈帧（Stack Frame）是用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时数据区中的虚拟机栈（Virtual Machine Stack）￼的栈元素。栈帧存储了方法的局部变量表、操作数栈、动态连接和方法返回地址等信息。每一个方法从调用开始至执行完成的过程，都对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程。</p>
<p>每一个栈帧都包括了局部变量表、操作数栈、动态连接、方法返回地址和一些额外的附加信息。在编译程序代码的时候，栈帧中需要多大的局部变量表，多深的操作数栈都已经完全确定了，并且写入到方法表的Code属性之中￼，因此一个栈帧需要分配多少内存，不会受到程序运行期变量数据的影响，而仅仅取决于具体的虚拟机实现。</p>
<p><img src="/2019/02/13/JVM-Bytecode-Execution-Engine-Subsystem/StackFrame.jpg" alt="StackFrame"></p>
<h2 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h2><p>局部变量表（Local Variable Table）是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量。在Java程序编译为Class文件时，就在方法的Code属性的max_locals数据项中确定了该方法所需要分配的局部变量表的最大容量。</p>
<p>局部变量表的容量以变量槽（Variable Slot，下称Slot）为最小单位，虚拟机规范中并没有明确指明一个Slot应占用的内存空间大小，只是很有导向性地说到每个Slot都应该能存放一个boolean、byte、char、short、int、float、reference或returnAddress类型的数据，这8种数据类型，都可以使用32位或更小的物理内存来存放。</p>
<p>方法执行时，如果执行的是实例方法，那局部变量表中第0位索引的默认是this的引用，即实例本身。</p>
<p>注1：与虚拟机模型设计不同的是，执行引擎的实现为了节约局部变量表的空间，局部变量表的Slothi可以重用的。</p>
<p><img src="/2019/02/13/JVM-Bytecode-Execution-Engine-Subsystem/LocalVariable.jpg" alt="LocalVariable"></p>
<p>注2：局部变量定义了但没有赋初始值是不能使用的，因为局部变量的加载没有类加载的准备和初始化阶段。</p>
<h2 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h2><p>操作数栈（Operand Stack）也常称为操作栈，它是一个后入先出（Last In First Out, LIFO）栈。同局部变量表一样，操作数栈的最大深度也在编译的时候写入到Code属性的max_stacks数据项中。操作数栈的每一个元素可以是任意的Java数据类型，包括long和double。</p>
<h2 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h2><p>每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接</p>
<h2 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h2><p>当一个方法开始执行后，只有两种方式可以退出这个方法。</p>
<p>第一种方式是执行引擎遇到任意一个方法返回的字节码指令，这时候可能会有返回值传递给上层的方法调用者（调用当前方法的方法称为调用者），是否有返回值和返回值的类型将根据遇到何种方法返回指令来决定，这种退出方法的方式称为正常完成出口（Normal Method Invocation Completion）。</p>
<p>另外一种退出方式是，在方法执行过程中遇到了异常，并且这个异常没有在方法体内得到处理，无论是Java虚拟机内部产生的异常，还是代码中使用athrow字节码指令产生的异常，只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，这种退出方法的方式称为异常完成出口（Abrupt Method Invocation Completion）。一个方法使用异常完成出口的方式退出，是不会给它的上层调用者产生任何返回值的。</p>
<h2 id="附加信息"><a href="#附加信息" class="headerlink" title="附加信息"></a>附加信息</h2><p>调试信息等，属于虚拟机可以自由实现的部分。</p>
<h1 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h1><p>方法调用阶段是确定被调用方法版本的过程。Java的编译过程并不存在连接过程，是在JVM运行时进行动态调用的。</p>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>在类加载的解析阶段，会将其中的一部分符号引用转化为直接引用，这种解析能成立的前提是：方法在程序真正运行之前就有一个可确定的调用版本，并且这个方法的调用版本在运行期是不可改变的。换句话说，调用目标在程序代码写好、编译器进行编译时就必须确定下来。这类方法的调用称为解析（Resolution）。</p>
<ul>
<li>invokestatic：调用静态方法。</li>
<li>invokespecial：调用实例构造器<code>&lt;init&gt;</code>方法、私有方法和父类方法。</li>
<li>invokevirtual：调用所有的虚方法。</li>
<li>invokeinterface：调用接口方法，会在运行时再确定一个实现此接口的对象。</li>
<li>invokedynamic：先在运行时动态解析出调用点限定符所引用的方法，然后再执行该方法，在此之前的4条调用指令，分派逻辑是固化在Java虚拟机内部的。其中只要能被invokestatic和invokespecial指令调用的方法（即非虚方法），都属于静态解析可以确定调用版本的，而invokedynamic指令的分派逻辑是由用户所设定的引导方法决定的。</li>
</ul>
<h2 id="分派Dispatch"><a href="#分派Dispatch" class="headerlink" title="分派Dispatch"></a>分派Dispatch</h2><p>分派调用过程是Java多态的一种基本体现，主要是有重载、重写两块。</p>
<h3 id="静态分派"><a href="#静态分派" class="headerlink" title="静态分派"></a>静态分派</h3><p>在编译阶段，依赖静态类型来定位方法执行版本的动作成为静态分派。典型应用是方法重载。但是，在很多情况下，重载版本并不唯一，所以虚拟机在运行时也会选更加合适的版本。</p>
<p>静态分派示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> org.fenixsoft.polymorphic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticDispatch</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Human guy)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello, guy!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Man guy)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello, gentleman!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Woman guy)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello, lady!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Human man = <span class="keyword">new</span> Man();</span><br><span class="line">        Human woman = <span class="keyword">new</span> Woman();</span><br><span class="line">        StaticDispatch sr = <span class="keyword">new</span> StaticDispatch();</span><br><span class="line">        sr.sayHello(man);</span><br><span class="line">        sr.sayHello(woman);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 实际类型变化，编译器并不能在编译时就这道，只能在运行时才可以确定的。</span></span><br><span class="line">        man = <span class="keyword">new</span> Woman();</span><br><span class="line">        sr.sayHello(man);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 静态类型变化</span></span><br><span class="line">        sr.sayHello((Woman) man);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hello, guy!</span><br><span class="line">hello, guy!</span><br><span class="line">hello, guy!</span><br><span class="line">hello, lady!</span><br></pre></td></tr></table></figure>
<p>重载方法匹配优先级代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.fenixsoft.polymorphic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Overload</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Object arg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello Object"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello int"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(<span class="keyword">long</span> arg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello long"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Character arg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello Character"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(<span class="keyword">char</span> arg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello char"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(<span class="keyword">char</span>... arg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello char ..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Serializable arg)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello Serializable"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        sayHello(<span class="string">'a'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>代码输出：</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello char</span><br></pre></td></tr></table></figure>
</li>
<li><p>注释掉sayHello(char arg)方法，代码输出：</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello int</span><br></pre></td></tr></table></figure>
</li>
<li><p>注释掉sayHello(int arg),代码输出：</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello long</span><br></pre></td></tr></table></figure>
</li>
<li><p>注释掉sayHello(long arg),代码输出：</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello Character</span><br></pre></td></tr></table></figure>
</li>
<li><p>注释掉sayHello(Character arg),代码输出：</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello Serializable</span><br></pre></td></tr></table></figure>
</li>
<li><p>注释掉sayHello(Serializable arg),代码输出：</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello Object</span><br></pre></td></tr></table></figure>
</li>
<li><p>注释掉sayHello(Object arg),代码输出：</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello char ...</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这个示例生动的展示了JVM在运行时静态分派时，是从继承关系中从下往上开始搜索，越接近上层的优先级越低。即使方法调用传入的参数值为null，这个规则仍然适用。变长参数的重载优先级是最低的。</p>
<h3 id="动态分派"><a href="#动态分派" class="headerlink" title="动态分派"></a>动态分派</h3><p>动态分派是重写的重要体现。</p>
<p>动态分派示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.fenixsoft.polymorphic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicDispatch</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"man say hello"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"woman say hello"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Human man = <span class="keyword">new</span> Man();</span><br><span class="line">        Human woman = <span class="keyword">new</span> Woman();</span><br><span class="line">        man.sayHello(); <span class="comment">// invokevirtual #21  // Method org/fenixsoft/polymorphic/Dynamic-Dispatch$Human.sayHello:()V</span></span><br><span class="line">        woman.sayHello(); <span class="comment">// invokevirtual #21</span></span><br><span class="line">        man = <span class="keyword">new</span> Woman();</span><br><span class="line">        man.sayHello(); <span class="comment">// invokevirtual #21</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">man say hello</span><br><span class="line">woman say hello</span><br><span class="line">woman say hello</span><br></pre></td></tr></table></figure></p>
<p>从字节码的角度来看， sayHello()方法均是通过invokevirtual指令触发，但是最终的执行方法版本却完全不同，invokevirtual执行的运行时解析过程如下：</p>
<ol>
<li>找到操作数栈顶的第一个元素所指向的对象的实际类型，记作C。</li>
<li>如果在类型C中找到与常量中的描述符和简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；如果不通过，则返回java.lang. IllegalAccessError异常。</li>
<li>否则，按照继承关系从下往上依次对C的各个父类进行第2步的搜索和验证过程。</li>
<li>如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodError异常。</li>
</ol>
<h3 id="单分派与多分派"><a href="#单分派与多分派" class="headerlink" title="单分派与多分派"></a>单分派与多分派</h3><p>方法的宗量，即方法的接收者与方法的参数统称。可以有单宗量分派，即根据一个宗量对目标方法进行选择。也可以有多宗量分派，即根据多个宗量对目标方法进行选择。Java的静态分派属于多分派类型。JVM在运行时动态分派属于单宗量分派。</p>
<p>单分派和多分派代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dispatch</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">QQ</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">_360</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hardChoice</span><span class="params">(QQ arg)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"father choose qq"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">                </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">hardChoice</span><span class="params">(_360 arg)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"father choose 360"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">hardChoice</span><span class="params">(QQ arg)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"son choose qq"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">hardChoice</span><span class="params">(_360 arg)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"son choose 360"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Father father = <span class="keyword">new</span> Father();</span><br><span class="line">        Father son = <span class="keyword">new</span> Son();</span><br><span class="line">        <span class="comment">// 静态分派：多宗量分派，方法接收者静态类型是Father,方法参数是_360 invokevirtual Father.hardChoice(360)</span></span><br><span class="line">        <span class="comment">// 动态分派：单宗量分派，方法接收者实际类型是Father，执行 Father.hardChoice(360)</span></span><br><span class="line">        father.hardChoice(<span class="keyword">new</span> _360());</span><br><span class="line">        <span class="comment">// 静态分派：静态类型是Father，方法参数是QQ invokevirtual Father.hardChoice(QQ)</span></span><br><span class="line">        <span class="comment">// 动态分派：实际类型是Son，执行Son.hardChoice(QQ)</span></span><br><span class="line">        son.hardChoice(<span class="keyword">new</span> QQ());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">father choose 360</span><br><span class="line">son choose qq</span><br></pre></td></tr></table></figure></p>
<h3 id="虚拟机动态分派的实现"><a href="#虚拟机动态分派的实现" class="headerlink" title="虚拟机动态分派的实现"></a>虚拟机动态分派的实现</h3><p>处于性能考虑，动态分派常用”稳定优化“手段：在类的方法区建立一个虚方法表(Virtual Method Table, vtable)，和接口方法表(Interface Method Table, itable)。从而虚拟机不需要进行元数据查找，直接通过虚方法表确定应该执行的方法版本。</p>
<p><img src="/2019/02/13/JVM-Bytecode-Execution-Engine-Subsystem/vtable.jpg" alt="vtable"></p>
<h2 id="动态类型语言支持"><a href="#动态类型语言支持" class="headerlink" title="动态类型语言支持"></a>动态类型语言支持</h2><p>动态语言的关键特征是它的类型检查的主体过程实在运行期而不是编译期，代码会更加简洁。而静态语言在编译器确定类型，最显著的好处是编译器可以提供严谨的类型检查，利于稳定性及代码达到更大规模。目前JVM支持的动态语言有Clojure, Groovy, Jython, JRuby等。</p>
<h1 id="字节码解释执行引擎"><a href="#字节码解释执行引擎" class="headerlink" title="字节码解释执行引擎"></a>字节码解释执行引擎</h1><p>本节探讨的是JVM将会如何对方法中的字节码进行解释执行的。</p>
<ul>
<li>传统编译过程是从程序源码到目标代码的一个过程，代表有C/C++语言。</li>
<li>Java是采用了现代的编译原理思路，把源码转化成抽象语法树，再由JVM进行解释执行，属于编译半独立实现。C#也是一种半独立实现的编译语言。</li>
<li>而有些语言则将词法分析，抽象语法树，解释执行都封装在一起，例如JavaScript执行器，这类语言一般属于动态语言。</li>
</ul>
<p><img src="/2019/02/13/JVM-Bytecode-Execution-Engine-Subsystem/JIT.jpg" alt="JIT"></p>
<h2 id="指令集架构"><a href="#指令集架构" class="headerlink" title="指令集架构"></a>指令集架构</h2><p>现在的指令执行主要有两种执行方式：</p>
<ol>
<li>基于栈的指令集架构<ul>
<li>可移植</li>
<li>执行速度相对较慢</li>
</ul>
</li>
<li>基于寄存器的指令集架构<ul>
<li>执行速度快</li>
</ul>
</li>
</ol>
<p>Java是基于栈的指令集架构。</p>
<h2 id="基于栈的解释器执行过程示例"><a href="#基于栈的解释器执行过程示例" class="headerlink" title="基于栈的解释器执行过程示例"></a>基于栈的解释器执行过程示例</h2>
          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sunnyhll.github.io/2019/02/10/JVM-Class-Loader-Subsystem/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="果核&肉肉">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="微观天下">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/02/10/JVM-Class-Loader-Subsystem/" class="post-title-link" itemprop="https://sunnyhll.github.io/page/2/index.html">JVM Class Loader Subsystem</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-02-10 20:44:33" itemprop="dateCreated datePublished" datetime="2019-02-10T20:44:33+08:00">2019-02-10</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-05-06 22:15:34" itemprop="dateModified" datetime="2019-05-06T22:15:34+08:00">2019-05-06</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Class文件结构"><a href="#Class文件结构" class="headerlink" title="Class文件结构"></a>Class文件结构</h1><p>Class文件时一组以8位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在Class文件之中，中间没有添加任何分隔符，这使得整个Class文件中存储的内容几乎全部是程序运行的必要数据。</p>
<p>Class文件本身是由下图的这些数据类型组成，这些数据项之间并没有分隔符，而是通过约定好的规范和表结构填入对应的信息，从而将Java语言代码翻译成字节码。Class文件数据项包含如下这些类型。</p>
<p><img src="/2019/02/10/JVM-Class-Loader-Subsystem/ClassFileDataType.jpg" alt="ClassFileDataType"></p>
<h2 id="1-魔数"><a href="#1-魔数" class="headerlink" title="1. 魔数"></a>1. 魔数</h2><p>第1~4字节：0xCAFEBABE</p>
<h2 id="2-Class文件的版本"><a href="#2-Class文件的版本" class="headerlink" title="2. Class文件的版本"></a>2. Class文件的版本</h2><p>第5、6字节：次版本号（4x.0~4x.65535）</p>
<p>第7、8字节：主版本号 （45~）</p>
<h2 id="3-常量池"><a href="#3-常量池" class="headerlink" title="3. 常量池"></a>3. 常量池</h2><p>常量池入口放置一项u2类型的数据，代表常量池容量计数值，从1开始。0作为没有常量池的表述。</p>
<ul>
<li><p>字面量：接近Java语言层面常量概念，如文本字符串、声明为final的常量值等。</p>
</li>
<li><p>符号引用：<strong>编译原理</strong>概念，包括三类常量：</p>
<ol>
<li>类和接口的全限定名</li>
<li>字段的名称和描述符</li>
<li>方法的名称和描述符</li>
</ol>
</li>
</ul>
<p>常量池中每一项常量都是一个表。JDK中定义了14种结构的表结构数据，如下图所示：</p>
<p><img src="/2019/02/10/JVM-Class-Loader-Subsystem/ConstantFlag.jpg" alt="ConstantFlag"></p>
<p>表开始的第一位都是一个u1类型的标志位（binary 0000 0000 0000 0000 中某几位为1），代表本表属于哪种常量类型，而后则遵从常量表自己的格式填入数据，结构总表如下所示。</p>
<p><img src="/2019/02/10/JVM-Class-Loader-Subsystem/ConstantPool.jpg" alt="ConstantPool"></p>
<h2 id="4-访问标志"><a href="#4-访问标志" class="headerlink" title="4. 访问标志"></a>4. 访问标志</h2><p>常量池后面两个字节：以16个标志位识别类或接口层次的访问信息，包括：</p>
<pre><code>1. Class是类还是接口；
2. 是否为public类型；
3. 是否为abstract类型；
4. 如果是类的话，是否被声明为final。
</code></pre><p>访问标志本身总共由16个标志位可以使用，具体代表如下图所示：</p>
<p><img src="/2019/02/10/JVM-Class-Loader-Subsystem/ClassAccessFlag.jpg" alt="AccessFlag"></p>
<h2 id="5-类索引、父类索引和接口索引集合"><a href="#5-类索引、父类索引和接口索引集合" class="headerlink" title="5. 类索引、父类索引和接口索引集合"></a>5. 类索引、父类索引和接口索引集合</h2><p>类索引和父类索引都是一个u2类型的数据，而接口索引集合是一组u2类型的数据的集合，Class文件中由这三项数据确定这个类的全限定名。</p>
<p>类索引和父类索引都指向了一个CONSTANT_Class_info类，而接口所以则第一位是接口的个数，后面跟了相应个数的索引分别指向CONSTANT_Class_info类。</p>
<h2 id="6-字段表集合"><a href="#6-字段表集合" class="headerlink" title="6. 字段表集合"></a>6. 字段表集合</h2><p>字段表用于描述接口或者类中声明的变量。字段包括类级变量以及实例级变量，但不包括在方法内部声明的局部变量。</p>
<p>字段结构如下所示：</p>
<p><img src="/2019/02/10/JVM-Class-Loader-Subsystem/Field.jpg" alt="Field"></p>
<p>字段的访问标志位有如下这些表格，标志位值和Class访问标志定义一样，但是支持的标志个数不一样：</p>
<p><img src="/2019/02/10/JVM-Class-Loader-Subsystem/FieldAccessFlag.jpg" alt="FieldAccessFlag"></p>
<ol>
<li><p>name_index保存的是对常量池CONSTANT_Utf8的引用，保存了方法简单名称。</p>
<p> 全限定名和简单名称很好理解，“org/fenixsoft/clazz/TestClass”是这个类的全限定名，仅仅是把类全名中的“.”替换成了“/”而已，为了使连续的多个全限定名之间不产生混淆，在使用时最后一般会加入一个“;”表示全限定名结束。简单名称是指没有类型和参数修饰的方法或者字段名称，这个类中的inc()方法和m字段的简单名称分别是“inc”和“m”。</p>
</li>
</ol>
<ol start="2">
<li><p>描述符引用指向了一个字段/方法描述符CONSTANT_Utf8。</p>
<ul>
<li><p>字段描述符，比如int实例变量的描述符是“I”;java.lang.Object 的实例描述符是 “Ljava/lang/Object;”，“double[][][]”的描述符为“[[[D”;</p>
</li>
<li><p>方法描述符，比如Object mymethod(int i, double d, Thread t)的描述符为 (IDLjava/lang/Thread;)Ljava/lang/Object;。</p>
<p>描述符支持如下类型：</p>
<p><img src="/2019/02/10/JVM-Class-Loader-Subsystem/Descriptor.jpg" alt="Descriptor"></p>
</li>
</ul>
</li>
</ol>
<h2 id="7-方法表集合"><a href="#7-方法表集合" class="headerlink" title="7. 方法表集合"></a>7. 方法表集合</h2><p>方法表用于描述接口或者类中声明的方法，包括类级方法以及实例方法。表结构跟字段表相似，在此不再赘述。</p>
<p><img src="/2019/02/10/JVM-Class-Loader-Subsystem/Field.jpg" alt="Field"></p>
<p>方法的访问标志与字段不同，如下图:</p>
<p><img src="/2019/02/10/JVM-Class-Loader-Subsystem/MethodAccessFlag.jpg" alt="MethodAccessFlag"></p>
<h2 id="8-属性表集合"><a href="#8-属性表集合" class="headerlink" title="8. 属性表集合"></a>8. 属性表集合</h2><p>属性表并不是单独存在的表，而是在Class文件、字段表、方法表都可以携带自己的属性表集合，用于描述某些场景专有的信息。属性表结构对后续属性进行了总表，结构如下:</p>
<p><img src="/2019/02/10/JVM-Class-Loader-Subsystem/AttributeInfo.jpg" alt="AttrubuteInfo"></p>
<p>目前虚拟机规范定义了下列属性：</p>
<p><img src="/2019/02/10/JVM-Class-Loader-Subsystem/AttributeCollection.jpg" alt="Attrubute_info"></p>
<h1 id="字节码指令"><a href="#字节码指令" class="headerlink" title="字节码指令"></a>字节码指令</h1><p>Java编译器将代码的操作本身处理生成了字节码指令，放在了Code属性中，JVM读取指令进行执行。JVM支持的字节码指令和操作数如表格所示:</p>
<p><img src="/2019/02/10/JVM-Class-Loader-Subsystem/OptCode.jpg" alt="OptCode"></p>
<h1 id="Class加载时机"><a href="#Class加载时机" class="headerlink" title="Class加载时机"></a>Class加载时机</h1><p>5大主动引用场景：</p>
<ol>
<li>遇到new、getstatic、putstatic或invokestatic这4条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。生成这4条指令的最常见的Java代码场景是：使用new关键字实例化对象的时候、读取或设置一个类的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）的时候，以及调用一个类的静态方法的时候。</li>
<li>使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。</li>
<li>当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</li>
<li>当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。</li>
<li>当使用JDK 1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。</li>
</ol>
<p>不会出发加载的三个被动引用例子：</p>
<ol>
<li>通过子类引用父类的静态字段，不会导致子类初始化。</li>
<li>通过数组定义来引用类，不会出发此类的初始化。</li>
<li>常量在编译阶段会存入调用类的常量池中，本质上没有直接引用到定义敞亮的类，因此不会触发定义常量的类的初始化。</li>
</ol>
<h1 id="Class加载过程"><a href="#Class加载过程" class="headerlink" title="Class加载过程"></a>Class加载过程</h1><p>类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）7个阶段。其中验证、准备、解析3个部分统称为连接（Linking），这7个阶段的发生顺序如下图所示。</p>
<p><img src="/2019/02/10/JVM-Class-Loader-Subsystem/ClassLoader.jpg" alt="ClassLoader"></p>
<h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><ol>
<li><p>通过一个类的全限定名来获取定义此类的二进制字节流</p>
</li>
<li><p>将字节流所代表的静态存储结构转化为方法区的运行时数据结构：</p>
<ul>
<li>如果是数组，JVM会直接创建数组类<ol>
<li>引用类型的数组： 递归采用类加载过程去加载这个类型</li>
<li>如果是非引用类型的数组：JVM将会把数组标记为引导类加载器关联。</li>
</ol>
</li>
</ul>
</li>
<li><p>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据访问入口。</p>
</li>
</ol>
<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><ol>
<li>文件格式验证</li>
</ol>
<p>验证字节流是否符合Class文件格式的规范。</p>
<ol start="2">
<li>元数据验证</li>
</ol>
<p>对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范要求。</p>
<ol start="3">
<li>字节码验证</li>
</ol>
<p>通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。</p>
<ol start="4">
<li>符号引用验证</li>
</ol>
<p>发生在符号引用转化为直接引用的时候，是对类自身意外（常量池里的各种符号引用）信息进行匹配性校验。</p>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>正式为变量分配内存并设置类变量为初始值阶段。引用类型的内存分配具体步骤参考<a href="/2018/11/07/JVM-memory-management-and-GC/#JVM对象的创建">JVM新对象创建</a>。</p>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>虚拟机将常量池内的符号引用替换为直接引用的过程。</p>
<ul>
<li><p>符号引用：符号引用以一组符号来描述引用的目标，符号可与是任何形式的字面量，只要能无歧义的定义到目标即可。</p>
</li>
<li><p>直接引用：直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。</p>
</li>
</ul>
<p>解析动作主要针对如下：</p>
<ol>
<li>类或接口 CONSTANT_Class_info</li>
<li>字段 CONSTANT_Fieldref_info</li>
<li>类方法 CONSTANT_Methodref_info</li>
<li>接口方法 CONSTANT_InterfaceMethodref_info</li>
<li>方法类型 CONSTANT_MethodType_info</li>
<li>方法句柄 CONSTANT_MethodHandle_info</li>
<li>和调用点限定符 CONSTANT_InvokeDynamic_info</li>
</ol>
<p>这7类符号引用进行。</p>
<ul>
<li><p>类或接口的解析</p>
<ol>
<li>如果C不是一个数组类型，那虚拟机将会把代表N的全限定名传递给D的类加载器去加载这个类C。在加载过程中，由于元数据验证、字节码验证的需要，又可能触发其他相关类的加载动作，例如加载这个类的父类或实现的接口。一旦这个加载过程出现了任何异常，解析过程就宣告失败。</li>
<li>如果C是一个数组类型，并且数组的元素类型为对象，也就是N的描述符会是类似“[Ljava/lang/Integer”的形式，那将会按照第1点的规则加载数组元素类型。如果N的描述符如前面所假设的形式，需要加载的元素类型就是“java.lang.Integer”，接着由虚拟机生成一个代表此数组维度和元素的数组对象。</li>
<li>如果上面的步骤没有出现任何异常，那么C在虚拟机中实际上已经成为一个有效的类或接口了，但在解析完成之前还要进行符号引用验证，确认D是否具备对C的访问权限。如果发现不具备访问权限，将抛出java.lang.IllegalAccessError异常。</li>
</ol>
</li>
<li><p>字段解析</p>
<ol start="0">
<li>首先将会对字段表内class_index￼项中索引的CONSTANT_Class_info符号引用进行解析，也就是字段所属的类或接口的符号引用。如果在解析这个类或接口符号引用的过程中出现了任何异常，都会导致字段符号引用解析的失败。</li>
<li>如果C本身就包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。</li>
<li>否则，如果在C中实现了接口，将会按照继承关系从下往上递归搜索各个接口和它的父接口，如果接口中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。</li>
<li>否则，如果C不是java.lang.Object的话，将会按照继承关系从下往上递归搜索其父类，如果在父类中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。</li>
<li>否则，查找失败，抛出java.lang.NoSuchFieldError异常。</li>
</ol>
</li>
<li><p>类方法解析</p>
<ol start="0">
<li>首先将会对字段表内class_index￼项中索引的CONSTANT_Class_info符号引用进行解析</li>
<li>类方法和接口方法符号引用的常量类型定义是分开的，如果在类方法表中发现class_index中索引的C是个接口，那就直接抛出java.lang.IncompatibleClassChangeError异常。</li>
<li>如果通过了第1步，在类C中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</li>
<li>否则，在类C的父类中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</li>
<li>否则，在类C实现的接口列表及它们的父接口之中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果存在匹配的方法，说明类C是一个抽象类，这时查找结束，抛出java.lang.AbstractMethodError异常。</li>
<li>否则，宣告方法查找失败，抛出java.lang.NoSuchMethodError。</li>
</ol>
</li>
<li><p>接口方法解析</p>
<ol start="0">
<li>首先将会对字段表内class_index￼项中索引的CONSTANT_Class_info符号引用进行解析</li>
<li>与类方法解析不同，如果在接口方法表中发现class_index中的索引C是个类而不是接口，那就直接抛出java.lang.IncompatibleClassChangeError异常。</li>
<li>否则，在接口C中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</li>
<li>否则，在接口C的父接口中递归查找，直到java.lang.Object类（查找范围会包括Object类）为止，看是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</li>
<li>否则，宣告方法查找失败，抛出java.lang.NoSuchMethodError异常。</li>
</ol>
</li>
</ul>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>类初始化阶段是类加载过程的最后一步，前面的类加载过程中，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的Java程序代码。</p>
<ul>
<li><p><code>&lt;clinit&gt;()</code>方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{}块）中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问。</p>
</li>
<li><p><code>&lt;clinit&gt;()</code>方法与类的构造函数（或者说实例构造器<code>&lt;init&gt;()</code>方法）不同，它不需要显式地调用父类构造器，虚拟机会保证在子类的<code>&lt;clinit&gt;()</code>方法执行之前，父类的<code>&lt;clinit&gt;()</code>方法已经执行完毕。因此在虚拟机中第一个被执行的<code>&lt;clinit&gt;()</code>方法的类肯定是java.lang.Object。</p>
</li>
<li><p>由于父类的<code>&lt;clinit&gt;()</code>方法先执行，也就意味着父类中定义的静态语句块要优先于子类的变量赋值操作，如下在代码清单中，字段B的值将会是2而不是1。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> A = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        A = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> B = A;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    System.out.println(Sub.B);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>&lt;clinit&gt;()</code>方法对于类或接口来说并不是必需的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成<code>&lt;clinit&gt;()</code>方法。</p>
</li>
<li><p>￼接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口与类一样都会生成<code>&lt;clinit&gt;()</code>方法。但接口与类不同的是，执行接口的<code>&lt;clinit&gt;()</code>方法不需要先执行父接口的<code>&lt;clinit&gt;()</code>方法。只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的<code>&lt;clinit&gt;()</code>方法。</p>
</li>
<li><p>虚拟机会保证一个类的<code>&lt;clinit&gt;()</code>方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的<code>&lt;clinit&gt;()</code>方法，其他线程都需要阻塞等待，直到活动线程执行<code>&lt;clinit&gt;()</code>方法完毕。如果在一个类的<code>&lt;clinit&gt;()</code>方法中有耗时很长的操作，就可能造成多个进程阻塞￼，在实际应用中这种阻塞往往是很隐蔽的。</p>
</li>
</ul>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h2 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h2><h1 id="Class加载器"><a href="#Class加载器" class="headerlink" title="Class加载器"></a>Class加载器</h1><p>虚拟机设计团队把类加载阶段中的“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类。这种实现便是类加载器。</p>
<blockquote>
<p>对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。</p>
</blockquote>
<p>类的相等语义，只有在这两个类是由同一个类加载器加载的前提下才有意义，只要类加载器不同，即使是加载自同一个Class文件，两个类也是不等的。（相等指的是，Class对象的equals(), isAssignableFrom(), isInstance()， instantof 的返回结果。例如下面代码运行结果则是：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class org.fenixsoft.classloading.ClassLoaderTest</span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> throw Exception </span>&#123;</span><br><span class="line">        <span class="comment">// Class ClassLoader define and override</span></span><br><span class="line">        ClassLoader myLoader = <span class="keyword">new</span> ClassLoader() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throw</span> ClassNotFoundException&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    String fileName = name.substring(name.lastIndextOf(<span class="string">"."</span>) + <span class="number">1</span>) + <span class="string">".class"</span>;</span><br><span class="line">                    InputStream is = getClass().getResourceAsStream(fileName);</span><br><span class="line">                    <span class="keyword">if</span>(is == <span class="keyword">null</span>)&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">super</span>.loadClasse(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">byte</span>[] b = <span class="keyword">new</span> bye[is.available()];</span><br><span class="line">                    is.read(b);</span><br><span class="line">                    <span class="keyword">return</span> defineClass(name, b, <span class="number">0</span>, b.length);</span><br><span class="line">                &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Object obj = myLoader.loadClass(<span class="string">"org.fenixsoft.classloading.ClassLoaderTest"</span>).newInstance();</span><br><span class="line"></span><br><span class="line">        System.out.println(obj.getClass());</span><br><span class="line">        System.out.println(obj <span class="keyword">instanceof</span> org.fenixsoft.classloading.ClassLoaderTest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="类加载器类型"><a href="#类加载器类型" class="headerlink" title="类加载器类型"></a>类加载器类型</h2><p>目前只存在两种不同的类加载器：一种是启动类加载器(Bootstrap ClassLoader)，C++语言实现，虚拟机自身的一部分；另一种就是所有其他类加载器，继承自抽象类java.lang.ClassLoader。</p>
<ul>
<li>启动类加载器（Bootstrap ClassLoader）：前面已经介绍过，这个类将器负责将存放在&lt;JAVA_HOME&gt;\lib目录中的，或者被-Xbootclasspath参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如rt.jar，名字不符合的类库即使放在lib目录中也不会被加载）类库加载到虚拟机内存中。启动类加载器无法被Java程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给引导类加载器，那直接使用null代替即可，如下列代码清单所示为java.lang.ClassLoader.getClassLoader()方法的代码片段。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ClassLoader <span class="title">getClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ClassLoader cl = getClassLoader0();</span><br><span class="line">    <span class="keyword">if</span>(cl == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    SecurityManager sm = System.getSecurityManger();</span><br><span class="line">    <span class="keyword">if</span>(sm != <span class="keyword">null</span>)&#123;</span><br><span class="line">        ClassLoader ccl = ClassLoader.getCallerClassLoader();</span><br><span class="line">        <span class="keyword">if</span>(ccl != <span class="keyword">null</span> &amp;&amp; ccl != cl &amp;&amp; !cl.isAncestor(ccl))&#123;</span><br><span class="line">            sm.checkPermission(SecurityConstants.GET_CLASSLOADER_PERMISSION);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>扩展类加载器（Extension ClassLoader）：这个加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载&lt;JAVA_HOME&gt;\lib\ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。</p>
</li>
<li><p>应用程序类加载器（Application ClassLoader）：这个类加载器由sun.misc.Launcher$App-ClassLoader实现。由于这个类加载器是ClassLoader中的getSystemClassLoader()方法的返回值，所以一般也称它为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</p>
</li>
</ul>
<h2 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h2><p>图中展示的类加载器之间的这种层次关系，称为类加载器的双亲委派模型（Parents Delegation Model）。双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。这里类加载器之间的父子关系一般不会以继承（Inheritance）的关系来实现，而是都使用组合（Composition）关系来复用父加载器的代码。</p>
<p><img src="/2019/02/10/JVM-Class-Loader-Subsystem/ParentsDelegationModel.jpg" alt="ParentDelegationModel"></p>
<p>双亲委派模型的工作过程是：</p>
<ol>
<li>所有的加载请求都委派给父类加载器去完成。</li>
<li>当父类加载器反馈自己无法完成加载请求，子加载器才会尝试自己加载。</li>
</ol>
<p>双亲委派模型保证了Java程序优先从启动类加载器进行搜索加载，使得java.lang.Object类型在程序的各种类加载环境中都是同一个类，能够稳定运行程序。</p>
<p>双亲委派模型实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">synchronized</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException&#123;</span><br><span class="line">    <span class="comment">//首先，检查请求的类是否已经加载过了</span></span><br><span class="line">    Class c = findLoadedClass(name);</span><br><span class="line">    <span class="keyword">if</span>( c == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(parent != <span class="keyword">null</span>)&#123;</span><br><span class="line">                c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                c = findBootstrapClassOrNull(name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="comment">// 如果父类加载器抛出异常，说明父类加载器不能加载，因此调用子类进行加载</span></span><br><span class="line">            c = findClass(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(resolve) &#123;</span><br><span class="line">        resolveClass(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="破坏双亲委派模型情况"><a href="#破坏双亲委派模型情况" class="headerlink" title="破坏双亲委派模型情况"></a>破坏双亲委派模型情况</h2><ol>
<li><p>loadClass没有按照双亲委派模型进行实现： 目前已经不推荐重写loadClass方法，而是重写findClass方法，从而保证模型安全。</p>
</li>
<li><p>第三方JNDI接口提供者/SPI的代码不能被启动类加载器加载：线程上下文类加载器(Tread Context ClassLoader)。可以通过java.lang.Thread类的setContextClassLoader()进行设置。如果父类及应用全局都没有设置过，则默认就是应用程序类加载器。这样就让父类加载器请求子类加载器去加载SPI的代码。</p>
</li>
<li><p>为程序动态性的追求导致：代码热替换(HotSwap),模块热部署(Hot Deployment)等。每一个程序模块都有自己的类加载器，当需要更换一块程序模块是，就把这块代码以及类加载器一起换掉以实现代码的热替换。OSGi收到类加载请求时：</p>
<ol>
<li>将以java.*开头的类委派给父类加载器加载。</li>
<li>否则，将委派列表名单内的类委派给父类加载器加载。</li>
<li>否则，将Import列表中的类委派给Export这个类的Bundle的类加载器加载。</li>
<li>否则，查找当前Bundle的ClassPath，使用自己的类加载器加载。</li>
<li>否则，查找类是否在自己的Fragment Bundle中，如果在，则委派给Fragment Bundle的类加载器加载。</li>
<li>否则，查找Dynamic Import列表的Bundle，委派给对应Bundle的类加载器加载。</li>
<li><p>否则，类查找失败。</p>
<p>此实现只有前两个点符合双亲委派模型，后面的都是平级的类加载器中进行。</p>
</li>
</ol>
</li>
</ol>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sunnyhll.github.io/2018/12/24/Java-Memory-Model/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="果核&肉肉">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="微观天下">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/12/24/Java-Memory-Model/" class="post-title-link" itemprop="https://sunnyhll.github.io/page/2/index.html">Java Memory Model</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-24 14:19:13" itemprop="dateCreated datePublished" datetime="2018-12-24T14:19:13+08:00">2018-12-24</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-11-20 09:14:07" itemprop="dateModified" datetime="2020-11-20T09:14:07+08:00">2020-11-20</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本文将从JMM的理论模型和系统设计角度切入讲述并发工具的内存语义与实现细节。</p>
<h1 id="JMM存在的目的"><a href="#JMM存在的目的" class="headerlink" title="JMM存在的目的"></a>JMM存在的目的</h1><p>Java虚拟机规范中试图定义一种Java内存模型来屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各个平台下都能达到一致的内存访问效果。</p>
<p><img src="/2018/12/24/Java-Memory-Model/JMM.jpg" alt="JMM"></p>
<h1 id="JVM内存模型操作"><a href="#JVM内存模型操作" class="headerlink" title="JVM内存模型操作"></a>JVM内存模型操作</h1><p><strong>主内存操作</strong></p>
<ul>
<li>lock：将一个变量表示为一条线程独占的状态。</li>
<li>unlock: 将一个处于锁定状态的变量释放，释放后的变量才可以被其他线程锁定。</li>
<li>read: 将一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用。</li>
<li>write: 将store操作从工作内存中得到的变量值放入主内存的变量中。</li>
</ul>
<p><strong>工作内存操作</strong></p>
<ul>
<li>load: 把read操作从主内存得到的变量值放入到工作内存的变量副本中。</li>
<li>use: 把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到需要使用变量复制的字节码指令时执行这个操作。</li>
<li>assign: 把一个执行引擎的接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。 </li>
<li>store: 把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用。</li>
</ul>
<h2 id="内存操作执行基本规则"><a href="#内存操作执行基本规则" class="headerlink" title="内存操作执行基本规则"></a>内存操作执行基本规则</h2><ul>
<li><p>不允许read和load、store和write操作之一单独出现，即不允许一个变量从主内存读取了但工作内存不接受，或者从工作内存发起回写了但主内存不接受的情况出现。</p>
</li>
<li><p>不允许一个线程丢弃它的最近的assign操作，即变量在工作内存中改变了之后必须把该变化同步回主内存。</p>
</li>
<li><p>不允许一个线程无原因地（没有发生过任何assign操作）把数据从线程的工作内存同步回主内存中。</p>
</li>
<li><p>一个新的变量只能在主内存中“诞生”，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量，换句话说，就是对一个变量实施use、store操作之前，必须先执行过了assign和load操作。</p>
</li>
<li><p>一个变量在同一个时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。</p>
</li>
<li><p>如果对一个变量执行lock操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或assign操作初始化变量的值。</p>
</li>
<li><p>如果一个变量事先没有被lock操作锁定，那就不允许对它执行unlock操作，也不允许去unlock一个被其他线程锁定住的变量。</p>
</li>
<li><p>对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行store、write操作）。</p>
</li>
</ul>
<h1 id="JVM内存模型特性"><a href="#JVM内存模型特性" class="headerlink" title="JVM内存模型特性"></a>JVM内存模型特性</h1><ul>
<li>原子性 JVM对基本数据类型的访问读写（上述操作）是具备原子性的。</li>
<li>可见性 当一个线程修改了共享变量的值，其他线程能够立刻知道这个修改。而volatile变量较普通变量能够保证多线程场景下线程在每次读写前都能刷新。</li>
<li>有序性 本线程内，操作都是有序；多线程场景下，线程间操作是无序的。</li>
</ul>
<h2 id="Happen-Before先行发生法则"><a href="#Happen-Before先行发生法则" class="headerlink" title="Happen-Before先行发生法则"></a>Happen-Before先行发生法则</h2><p>先行发生是JMM中定义的两项操作之前的偏序关系，如果说操作A先行发生于操作B，其实就是说发生操作B之前，操作A产生的影响能够被B观察到，“影响”包括修改了内存中共享变量的值、发送了消息、调用了方法等。</p>
<p>具体体现：</p>
<ul>
<li><p><strong>程序次序规则（Program Order Rule）</strong>：在一个线程内，按照程序代码顺序，书写在前面的操作先行发生于书写在后面的操作。准确地说，应该是控制流顺序而不是程序代码顺序，因为要考虑分支、循环等结构。</p>
</li>
<li><p><strong>管程锁定规则（Monitor Lock Rule）</strong>：一个unlock操作先行发生于后面对同一个锁的lock操作。这里必须强调的是同一个锁，而“后面”是指时间上的先后顺序。</p>
</li>
<li><p><strong>volatile变量规则（Volatile Variable Rule）</strong>：对一个volatile变量的写操作先行发生于后面对这个变量的读操作，这里的“后面”同样是指时间上的先后顺序。</p>
</li>
<li><p><strong>线程终止规则（Thread Termination Rule）</strong>：线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值等手段检测到线程已经终止执行。</p>
</li>
<li><p><strong>线程中断规则（Thread Interruption Rule）</strong>：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测到是否有中断发生。</p>
</li>
<li><p><strong>对象终结规则（Finalizer Rule）</strong>：一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize()方法的开始。</p>
</li>
<li><p><strong>传递性（Transitivity）</strong>：如果操作A先行发生于操作B，操作B先行发生于操作C，那就可以得出操作A先行发生于操作C的结论。</p>
</li>
</ul>
<h1 id="指令重排"><a href="#指令重排" class="headerlink" title="指令重排"></a>指令重排</h1><p>编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段。</p>
<h2 id="单线程重排序："><a href="#单线程重排序：" class="headerlink" title="单线程重排序："></a>单线程重排序：</h2><ul>
<li><strong>数据依赖性</strong>：程序的任意两个操作的执行是可能具有一定的依赖性，不能改变。</li>
<li><strong>as-if-serial语义</strong>：单线程程序的执行结果不能改变。</li>
<li><strong>程序顺序规则</strong>: happens-before的顺序规则不能修改。</li>
</ul>
<h2 id="多线程重排序："><a href="#多线程重排序：" class="headerlink" title="多线程重排序："></a>多线程重排序：</h2><ul>
<li><strong>顺序一致性模型</strong>：概念上模型只有一个单一的全局内存，所有操作线程在每一步操作后看到的内存内容都是一致的。实际上并不能完全保证，只能保证同步程序在进出临界区内代码各个线程的内存视图能够一致。</li>
</ul>
<h1 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h1><p>硬件层的内存屏障分为两种：Load Barrier 和 Store Barrier即读屏障和写屏障。<br>内存屏障有两个作用：</p>
<ol>
<li>阻止屏障两侧的指令重排序；</li>
<li>强制把写缓冲区/高速缓存中的脏数据等写回主内存，让缓存中相应的数据失效。</li>
</ol>
<p>对于Load Barrier来说，在指令前插入Load Barrier，可以让高速缓存中的数据失效，强制从新从主内存加载数据；</p>
<p>对于Store Barrier来说，在指令后插入Store Barrier，能让写入缓存中的最新数据更新写入主内存，让其他线程可见。</p>
<h2 id="java内存屏障"><a href="#java内存屏障" class="headerlink" title="java内存屏障"></a>java内存屏障</h2><p>java的内存屏障通常所谓的四种即LoadLoad,StoreStore,LoadStore,StoreLoad实际上也是上述两种的组合，完成一系列的屏障和数据同步功能。</p>
<ul>
<li>LoadLoad屏障：对于这样的语句Load1; LoadLoad; Load2，在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。</li>
<li>StoreStore屏障：对于这样的语句Store1; StoreStore; Store2，在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。</li>
<li>LoadStore屏障：对于这样的语句Load1; LoadStore; Store2，在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕。</li>
<li>StoreLoad屏障：对于这样的语句Store1; StoreLoad; Load2，在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。它的开销是四种屏障中最大的。在大多数处理器的实现中，这个屏障是个万能屏障，兼具其它三种内存屏障的功能</li>
</ul>
<h1 id="Java同步工具的内存语义及实现"><a href="#Java同步工具的内存语义及实现" class="headerlink" title="Java同步工具的内存语义及实现"></a>Java同步工具的内存语义及实现</h1><h2 id="锁的内存语义及实现"><a href="#锁的内存语义及实现" class="headerlink" title="锁的内存语义及实现"></a>锁的内存语义及实现</h2><p>锁的语义决定了临界区代码的执行具有原子性。</p>
<h3 id="内存语义"><a href="#内存语义" class="headerlink" title="内存语义"></a>内存语义</h3><p>锁的释放可以让线程向获取同一个锁的线程发送消息。<br>锁的获取可以让线程对应的内存失效使得临界代码必须从主内存获取共享变量。</p>
<h3 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h3><p>公平锁获取通过AbstractQueuedSynchronizer即AQS实现，通过一个整型的volatile变量state来维护同步状态。拿锁时，tryAcquire方法会查看state值是否为0，即无锁状态，并将state值设置为传入变量acquires，如果state不为0，且owner不是current线程，则返回false.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span></span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">  <span class="keyword">int</span> c = getState();</span><br><span class="line">  <span class="keyword">if</span>(c == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>( isFirst(current)) &amp;&amp; compareAndSetState(<span class="number">0</span>, acquires) &#123;</span><br><span class="line">      setExclusiveOwnerThread(current);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(current == getExclusiveOwnerThread())&#123;</span><br><span class="line">    <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">    <span class="keyword">if</span>(nextc &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Max lock count exceeded"</span>);</span><br><span class="line">      setState(nextc);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>非公平锁的获取不需要tryAcquire方法中通过isFirst(current))方法进行竞争，而是直接调用compareAndSetState(int expect, int update)。</p>
<p>(非)公平锁释放通过tryRelease(int releases)实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">  <span class="keyword">if</span>( Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IlleagalMonitorStateException();</span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span>( c == <span class="number">0</span>)&#123;</span><br><span class="line">      free = <span class="keyword">true</span>;</span><br><span class="line">      setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="CAS-内存语义及操作内容"><a href="#CAS-内存语义及操作内容" class="headerlink" title="CAS 内存语义及操作内容"></a>CAS 内存语义及操作内容</h2><h3 id="内存语义-1"><a href="#内存语义-1" class="headerlink" title="内存语义"></a>内存语义</h3><p>CAS更新操作，同时具有volatile读和volatile写的内存语义。</p>
<h3 id="操作内容"><a href="#操作内容" class="headerlink" title="操作内容"></a>操作内容</h3><p>CAS是处理器的一种操作，是native方法API。</p>
<ol>
<li>确保对内存读-改-写的原子性。</li>
<li>禁止CAS指令前后读写指令重排。</li>
<li>把缓存区的<strong>所有</strong>数据刷新到内存中。</li>
</ol>
<h2 id="volatile-内存语义及实现"><a href="#volatile-内存语义及实现" class="headerlink" title="volatile 内存语义及实现"></a>volatile 内存语义及实现</h2><h3 id="内存语义-2"><a href="#内存语义-2" class="headerlink" title="内存语义"></a>内存语义</h3><p>volatile写与锁的释放有相同的内存语义，volatile读与锁的获取有相同内存语义。</p>
<h3 id="实现细节-1"><a href="#实现细节-1" class="headerlink" title="实现细节"></a>实现细节</h3><ul>
<li>通过插入内存屏障，来组织编译器/操作系统进行指令重排序。</li>
<li><p>通过关联读/写操作和使用操作（用之前必须从主内存读，assign后必须写入主内存，以及写happens-before读规则）强制CPU的缓存失效来保证内存可见性。<br>volatile的内存屏障策略如下：</p>
</li>
<li><p>在每个volatile写操作前插入StoreStore屏障，在写操作后插入StoreLoad屏障；<br><img src="/2018/12/24/Java-Memory-Model/VolatileWrite.png" alt="volatile-write"></p>
</li>
<li>在每个volatile读操作后分别插入LoadLoad屏障，和LoadStore屏障；<br><img src="/2018/12/24/Java-Memory-Model/VolatileRead.png" alt="volatile-read"></li>
</ul>
<p>由于内存屏障的作用，避免了volatile变量和其它指令重排序、线程之间实现了通信，使得volatile表现出了锁的特性。</p>
<p>volatile强制缓存失效策略如下:</p>
<ul>
<li><p><strong>线程的Load、read和Use进行关联</strong>:只有当线程T对变量V执行的前一个动作是load的时候，线程T才能对变量V执行use动作；并且，只有当线程T对变量V执行的后一个动作是use的时候，线程T才能对变量V执行load动作。线程T对变量V的use动作可以认为是和线程T对变量V的load、read动作相关联，必须连续一起出现（这条规则要求在工作内存中，每次使用V前都必须先从主内存刷新最新的值，用于保证能看见其他线程对变量V所做的修改后的值）。</p>
</li>
<li><p><strong>Assign和所有线程的store，write进行关联</strong>只有当线程T对变量V执行的前一个动作是assign的时候，线程T才能对变量V执行store动作；并且，只有当线程T对变量V执行的后一个动作是store的时候，线程T才能对变量V执行assign动作。线程T对变量V的assign动作可以认为是和线程T对变量V的store、write动作相关联，必须连续一起出现（这条规则要求在工作内存中，每次修改V后都必须立刻同步回主内存中，用于保证其他线程可以看到自己对变量V所做的修改）。</p>
</li>
<li><p><strong>不同变量的上述的两段操作顺序一致</strong>假定动作A是线程T对变量V实施的use或assign动作，假定动作F是和动作A相关联的load或store动作，假定动作P是和动作F相应的对变量V的read或write动作；类似的，假定动作B是线程T对变量W实施的use或assign动作，假定动作G是和动作B相关联的load或store动作，假定动作Q是和动作G相应的对变量W的read或write动作。如果A先于B，那么P先于Q（这条规则要求volatile修饰的变量不会被指令重排序优化，保证代码的执行顺序与程序的顺序相同）。</p>
<blockquote>
<p>Happens before法则: 前一个操作的执行结果要对第二个操作可见。</p>
</blockquote>
</li>
</ul>
<h2 id="final-内存语义与实现细节"><a href="#final-内存语义与实现细节" class="headerlink" title="final 内存语义与实现细节"></a>final 内存语义与实现细节</h2><p>final关键字可以放在static域，实例成员域，和局部变量三种变量前。其中final修饰的局部变量的可以作为线程的局部变量传递给子线程。也能保证并发情况下的内存语义。</p>
<h3 id="内存语义-3"><a href="#内存语义-3" class="headerlink" title="内存语义"></a>内存语义</h3><p>对于final域，编译器和CPU会遵循两个重排序规则：</p>
<ul>
<li>新建对象过程中，构造体中对final域的初始化写入和这个对象赋值给其他引用变量，这两个操作不能重排序；（废话嘛）</li>
<li>初次读包含final域的对象引用和读取这个final域，这两个操作不能重排序；（晦涩，意思就是先赋值引用，再调用final值）</li>
</ul>
<p>总之上面规则的意思可以这样理解，必需保证一个对象的所有final域被写入完毕后才能引用和读取。这也是内存屏障的起的作用：</p>
<h3 id="实现细节-2"><a href="#实现细节-2" class="headerlink" title="实现细节"></a>实现细节</h3><ul>
<li><p>写final域：在编译器写final域完毕，构造体结束之前，会插入一个StoreStore屏障，保证前面的对final写入对其他线程/CPU可见，并阻止this指针赋值与final域写被重排序(this = new Object(){ finalField = …})。（如果没有，普通域的写可以被重排到构造函数外）<br><img src="/2018/12/24/Java-Memory-Model/FinalWrite.png" alt="final-write"></p>
</li>
<li><p>写final域的成员域:构造函数内对一个final引用的对象的成员域的写入，与随后在构造函数外把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。<br><img src="/2018/12/24/Java-Memory-Model/FinalElementWrite.png" alt="final-element-write"></p>
</li>
<li><p>读final域：在上述规则2中，两步操作不能重排序的机理就是在读final域前插入了LoadLoad屏障，这个阻止了读取this引用和读取final域的重排序（isntance.finalField）。<br><img src="/2018/12/24/Java-Memory-Model/FinalRead.png" alt="final-read"></p>
</li>
</ul>
<p>X86处理器中，由于CPU不会对写-写操作进行重排序，所以StoreStore屏障会被省略；而X86也不会对逻辑上有先后依赖关系的操作进行重排序，所以LoadLoad也会变省略。</p>
<blockquote>
<p>只要对象是正确构造的（被构造对象的引用在构造函数中没有“逸出”），那么不需要使用同步（指 lock 和 volatile 的使用），就可以保证任意线程都能看到这个 final 域在构造函数中被初始化之后的值。</p>
</blockquote>
<p>this逸出代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalReferenceEscapeExample</span> </span>&#123;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">static</span> FinalReferenceEscapeExample obj;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FinalReferenceEscapeExample</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    i = <span class="number">1</span>;                              <span class="comment">//1写final域</span></span><br><span class="line">    obj = <span class="keyword">this</span>;                          <span class="comment">//2 this引用在此“逸出”</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> FinalReferenceEscapeExample ();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> reader &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj != <span class="keyword">null</span>) &#123;                     <span class="comment">//3</span></span><br><span class="line">        <span class="keyword">int</span> temp = obj.i;                 <span class="comment">//4</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Concurrent包的内存语义及实现"><a href="#Concurrent包的内存语义及实现" class="headerlink" title="Concurrent包的内存语义及实现"></a>Concurrent包的内存语义及实现</h2><p>Concurrent包底层实现依赖如下图所示：</p>
<p><img src="/2018/12/24/Java-Memory-Model/Concurrent.png" alt="Cocurrent"></p>
<h1 id="延迟初始化问题讨论"><a href="#延迟初始化问题讨论" class="headerlink" title="延迟初始化问题讨论"></a>延迟初始化问题讨论</h1><p>延迟初始化是在需要实例的时候再进行初始化，从而达到提升程序初始化性能的目的。然而延迟初始化需要考虑多线程并发访问，和指令重排序问题。</p>
<h2 id="静态域延迟初始化"><a href="#静态域延迟初始化" class="headerlink" title="静态域延迟初始化"></a>静态域延迟初始化</h2><p>静态域的延迟初始化能通过final关键词实现，因为final静态域能保证多线程安全初始化，同事也能保证computeFieldValue()方法不会溢出FieldHolder的构造方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FieldHolder</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> FieldType field = computeFieldValue();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> FieldType <span class="title">getField</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> FieldHolder.field;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="成员域延迟初始化"><a href="#成员域延迟初始化" class="headerlink" title="成员域延迟初始化"></a>成员域延迟初始化</h2><h3 id="单重检查模式"><a href="#单重检查模式" class="headerlink" title="单重检查模式"></a>单重检查模式</h3><p>单重检查模式能够确保大多数情况的fiel的同步，但是当computeFieldValue()执行和field赋值可以重排序，导致在第一次检查时其他线程可能看到不完整的field值，并返回。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> FieldType field;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> FieldType <span class="title">getField</span><span class="params">()</span></span>&#123;</span><br><span class="line">  FieldType result = field;</span><br><span class="line">  <span class="keyword">if</span>(result == <span class="keyword">null</span>)&#123;</span><br><span class="line">    field = result = computeFieldValue();</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="双重检查模式"><a href="#双重检查模式" class="headerlink" title="双重检查模式"></a>双重检查模式</h3><p>双重检查模式通过synchronized和volatile的内存语义，3, 4对其他线程可见，且其他线程在1处的读不会重排序到2语块的内部，能够确保在线程更新field值时，与其他线程查看field值之间的读写能够顺序执行。</p>
<p>局部变量result的使用能够保证尽量少次数的访问field和取锁，提升运行效率。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> FieldType field;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> FieldType <span class="title">getField</span><span class="params">()</span></span>&#123;</span><br><span class="line">  FieldType result = field;</span><br><span class="line">  <span class="keyword">if</span>(result == <span class="keyword">null</span>)&#123;</span><br><span class="line">    result = field;</span><br><span class="line">    <span class="keyword">if</span>(result == <span class="keyword">null</span>)&#123; <span class="comment">// 1</span></span><br><span class="line">      synchornized(<span class="keyword">this</span>)&#123; <span class="comment">// 2</span></span><br><span class="line">        field = result = computeFieldValue(); <span class="comment">//3, 4</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sunnyhll.github.io/2018/12/12/Java-Concurrency/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="果核&肉肉">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="微观天下">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/12/12/Java-Concurrency/" class="post-title-link" itemprop="https://sunnyhll.github.io/page/2/index.html">Java Concurrency</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-12 17:21:07" itemprop="dateCreated datePublished" datetime="2018-12-12T17:21:07+08:00">2018-12-12</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-12-18 10:23:24" itemprop="dateModified" datetime="2020-12-18T10:23:24+08:00">2020-12-18</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="线程概念"><a href="#线程概念" class="headerlink" title="线程概念"></a>线程概念</h1><p>线程是一种轻量级的进程内的执行单元，线程共用进程中的内存地址空间，但是拥有自己的调用栈，寄存器，程序计数器和局部变量。线程状态如下：</p>
<p><img src="/2018/12/12/Java-Concurrency/ThreadStatus.jpg" alt="ThreadStatus"></p>
<ol>
<li>新建状态(New) : 线程对象被创建后，就进入了新建状态。例如，Thread thread = new Thread()。</li>
<li>就绪状态(Runnable): 也被称为“可执行状态”。线程对象被创建后，其它线程调用了该对象的start()方法，从而来启动该线程。例如，thread.start()。处于就绪状态的线程，随时可能被CPU调度执行。</li>
<li>运行状态(Running) : 线程获取CPU权限进行执行。需要注意的是，线程只能从就绪状态进入到运行状态。</li>
<li>阻塞状态(Blocked)  : 阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种：<ol>
<li>等待阻塞 – 通过调用线程的wait()方法，让线程等待某工作的完成。</li>
<li>同步阻塞 – 线程在获取synchronized同步锁失败(因为锁被其它线程所占用)，它会进入同步阻塞状态。</li>
<li>其他阻塞 – 通过调用线程的sleep()或join()或发出了I/O请求时，线程会进入到阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。</li>
</ol>
</li>
<li>死亡状态(Dead/Terminated)    : 线程执行完了或者因异常退出了run()方法，该线程结束生命周期。</li>
</ol>
<h1 id="多线程概念"><a href="#多线程概念" class="headerlink" title="多线程概念"></a>多线程概念</h1><p>多线程是利用线程并行和并发处理的优势提升程序性能的一种编程方法。</p>
<p>优点：</p>
<ol>
<li>可以使每个线程做自己的任务，代码上语义更明确</li>
<li>利用多核CPU的优势</li>
<li>可以把占据时间长如阻塞UI的任务放到后台处理从而保证界面/线程响应</li>
<li>可以提升CPU利用率，通过回调方式而不是阻塞方式处理IO操作</li>
</ol>
<p>缺点：</p>
<ol>
<li>线程安全问题（脏数据，死锁）</li>
<li>性能问题（活锁，饥饿，上下文切换开销）</li>
<li>线程本身需要更多的内存</li>
</ol>
<h1 id="线程管理的基本工具（及Executor框架）"><a href="#线程管理的基本工具（及Executor框架）" class="headerlink" title="线程管理的基本工具（及Executor框架）"></a>线程管理的基本工具（及Executor框架）</h1><h2 id="创建一个新线程"><a href="#创建一个新线程" class="headerlink" title="创建一个新线程"></a>创建一个新线程</h2><ol>
<li><p>Thread类是一个实体类，继承Thread类，重写RUN方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 也可以 public class MyThread extends Thread &#123;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Object o = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>;i++)&#123;</span><br><span class="line">            sychronized(o)&#123;</span><br><span class="line">                number++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>实现RUNABLE 接口，实例对象作为THREAD的构造函数的传参。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyThread());</span><br><span class="line">t.start();</span><br></pre></td></tr></table></figure>
</li>
<li><p>实现CALLABLE接口，通过FUTURETASK来创建</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="comment">//return the thread name executing this callable task</span></span><br><span class="line">        <span class="keyword">return</span> Thread.currentThread().getName();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    Callable&lt;String&gt; oneCallable = <span class="keyword">new</span> MyCallable();</span><br><span class="line">    FutureTask&lt;String&gt; oneTask = <span class="keyword">new</span> FutureTask&lt;String&gt;(oneCallable);</span><br><span class="line"></span><br><span class="line">    Thread t = <span class="keyword">new</span> Thread(oneTask);</span><br><span class="line">    System.out.println(Thead.currentThread().getName());</span><br><span class="line"></span><br><span class="line">    t.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li><p>通过线程池本身ThreadPoolExecutor进行task管理。线程池是一个功能强大的多线程工具，在每一个新的Runnable提交的时候，会有如下流程处理：<img src="/2018/12/12/Java-Concurrency/workflow.jpg" alt="Workflow"><br>在线程池处理task过程中，会需要如下参数控制流程：<img src="/2018/12/12/Java-Concurrency/Threadpool.jpg" alt="ThreadPool.jpg"></p>
</li>
<li><p>通过线程池工厂Executors生成<a href="https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ExecutorService.html" target="_blank" rel="noopener">ExecutorService</a>接口下的实例,创建并执行任务。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> POOL_NUM = <span class="number">5</span>;</span><br><span class="line"><span class="comment">// 通过 Executors 静态方法创建一个线程池</span></span><br><span class="line">ExecutorService es = Executors.newFixedThreadPool(POOL_NUM);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; POOL_NUM); i++) &#123;</span><br><span class="line">    es.execute(oneTask);</span><br><span class="line">    <span class="comment">//Future&lt;String&gt; anotherTask = es.submit(oneCallabe);也可以执行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//类似Task in c#</span></span><br><span class="line"><span class="keyword">while</span>(oneTask.isDone())&#123;</span><br><span class="line">    System.out.println(oneTask.get());</span><br><span class="line">&#125;</span><br><span class="line">es.shutdown();</span><br></pre></td></tr></table></figure>
<h2 id="通过Object方法控制线程并发"><a href="#通过Object方法控制线程并发" class="headerlink" title="通过Object方法控制线程并发"></a>通过Object方法控制线程并发</h2><p>wait/notify(wait(), await(), notify() notifyAll())是Object的方法，运用了实例本身的锁功能控制多线程的并发访问和修改问题。</p>
<pre><code>* wait的语义是释放当前拿到的锁，让本线程进入睡眠状态。
* notify的语义是通知其他线程唤醒，让原本是waiting状态的线程变成了blocked（同步块中释放锁，重新等待拿锁恢复同步块内代码wait()后继续执行）。
</code></pre><p>一般的应用场景是，wait释放锁，notify别的线程来拿锁，并唤醒继续执行。这些方法必须在已经获得锁的同步块中书写，否则会抛出illeagalmonitorStateException。这属于线程的基本工具，一般推荐使用已有的并发框架，而非此类方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// the standard idiom for using the wait method</span></span><br><span class="line">synchonized(o)&#123;</span><br><span class="line">    <span class="comment">// 防止线程被无意唤醒，需要while loop保证代码安全</span></span><br><span class="line">    <span class="keyword">while</span>(!condition)&#123;</span><br><span class="line">        o.wait();</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">        <span class="comment">// notifyAll能保证需要被唤醒的线程的活性。如果都在等待同一个条件，可以用notify()</span></span><br><span class="line">        o.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// do something when condition is fulfilled.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="线程调度器Scheduler"><a href="#线程调度器Scheduler" class="headerlink" title="线程调度器Scheduler"></a>线程调度器Scheduler</h2><ol>
<li>static Thread.yeild()：可以让步出当前线程的优先级，让其他同优先级的线程先跑。</li>
<li><p>Thread.join(): 当前线程等待一个线程t（join的实例）完成后再继续执行。类似于</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">    <span class="comment">// if t is alive, keep waiting</span></span><br><span class="line">    <span class="keyword">while</span>(isAlive())&#123;</span><br><span class="line">        wait();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// continue current thread</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>static Thread.sleep(): 保持拿锁，线程睡眠一定时间。与wait()不同之处在于前者锁并没有释放。</p>
</li>
<li>Thread.interrupt(): 调用中断的线程去中断别的线程，被中断的线程如果处于等待/睡眠状态，会抛出InterrupException，如果处于阻塞于IO状态，会抛出ClosedByInterruptException，并且连接中断，如果阻塞与selector，则会出发selector’s wakeup方法，并且状态Thread.interrupted()变成true。其他情况，直接Thread.isInterrupted()/static Thread.interrupted()变成true。在异常处理完毕后，线程的中断标志位会复位，从而允许再一次中断。</li>
<li>Deprecated方法有suspend(),resume()，stop()能让线程暂停,恢复运行和完全停止。需要留意的是线程被suspend和stop并不会释放线程已经拿到的锁，所以不是一个很好的终止线程的方法，而中断则可以在异常捕捉处理好锁释放，资源释放的逻辑。</li>
</ol>
<h2 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h2><ol>
<li><p>volatile, synchronized（略）</p>
</li>
<li><p>wait/notify(略)</p>
</li>
<li><p>pipewriter/pipereader：将管道的输出连接到其他线程的输入从而达到通信目的。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Piped</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        PipedWriter out = <span class="keyword">new</span> PipedWriter();</span><br><span class="line">        PipedReader in = <span class="keyword">new</span> PipedReader();</span><br><span class="line">        <span class="comment">//连接</span></span><br><span class="line">        out.connect(in);</span><br><span class="line"></span><br><span class="line">        Thread printThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Print(in), <span class="string">"PrintThread"</span>);</span><br><span class="line">        printThread.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> receive = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>((receive = System.in.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">                out.write(receive);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">            out.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Print</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> PipedReader in;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Print</span><span class="params">(PipedReader in)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.in = in;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">int</span> receive = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">while</span>((receive = in.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">                    System.out.print((<span class="keyword">char</span>) receive);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">catch</span>(IOException ex)&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>join（略）</p>
</li>
<li><p>ThreadLocal: ThreadLocal集合类型可以为线程提供局部变量，在多线程场景下，保证线程自由变量的安全。常用于AOP代码，例如计时器。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Profiler</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Long&gt; TIME_THREADLOCAL = <span class="keyword">new</span> ThreadLocal&lt;Long&gt;()&#123;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Long <span class="title">initialValue</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> System.currentTimeMillis();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">begin</span><span class="params">()</span></span>&#123;</span><br><span class="line">        TIME_THREADLOCAL.set(Stystem.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">end</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> System.currentTimeMillis() - TIME_THREADLOCAL.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Profiler.begin();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">"Cost: "</span> + Profiler.end() + <span class="string">" mills"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Exchanger类: Exchanger是一个用于线程间协作的工具类。Exchanger创建了一个同步点，当两个线程都到达同步点时，数据进行交换。应用场景如下：</p>
</li>
</ol>
<ul>
<li>遗传算法（1/2基因数据交换)</li>
<li><p>校对工作（AB岗两人进行录入对稿）</p>
<p>  Exchanger使用示例：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExchangerTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Exchanger&lt;String&gt; exgr = <span class="keyword">new</span> Exchanger&lt;String&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        threadPool.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    String A = <span class="string">"流水数据A"</span>;</span><br><span class="line">                    <span class="comment">//A录入银行流水数据</span></span><br><span class="line">                    exgr.exchange(A);</span><br><span class="line">                &#125;<span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        threadPool.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    String B = <span class="string">"流水数据B"</span>;</span><br><span class="line">                    <span class="comment">//B录入银行流水</span></span><br><span class="line">                    String A = exgr.exchange(B);</span><br><span class="line">                    System.out.println(<span class="string">"A和B数据是否一致："</span> + A.equals(B));</span><br><span class="line">                &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="线程上下文管理工具"><a href="#线程上下文管理工具" class="headerlink" title="线程上下文管理工具"></a>线程上下文管理工具</h2><ol>
<li><p>Executor框架</p>
<p> Executor框架定义了各个Task在线程池/单线程执行的上下文。Developer可以自己实现Executor框架来自定义Task执行上下文。Executor支持的线程池框架有ThreadPoolExecutor和ScheduleThreadPoolExecutor，主要负责处理相对独立的任务。</p>
<p> 在新线程执行</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPerTask</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">( Runnable task)</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(task).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 在同一个线程执行</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InThreadTask</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">( Runnable task)</span></span>&#123;</span><br><span class="line">        task.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> ExecutorService接口扩展了Executor接口，支持更加多的接口去控制executor的周期。当ExecutorService被shutdown()后，不再接受submit(),当其执行完所有task后，就终止。</p>
<ul>
<li>Running ===&gt;</li>
<li>Shutting down ===&gt;</li>
<li><p>Terminated</p>
</li>
<li><p>CoompletionService</p>
<p>Executor和BlockingQueue的组合。</p>
</li>
</ul>
</li>
<li><p>Fork/Join框架</p>
<p> Fork/Join框架适合大量task并发执行,由于task可以在不同的线程进行根据空闲程度自由调度，所以具有特定的执行设计场景（一般是只读场景）:</p>
<ol>
<li>归并排序</li>
<li>map/reduce</li>
<li><p>递归多线程计算</p>
<p>ForkJoinPool线程池是Fork/Join执行框架的线程池，也是Executor框架的一种。</p>
<p>Fork/Join使用示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THRESHOLD = <span class="number">2</span>; <span class="comment">//阈值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> start;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> end;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CountTask</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Integer <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果任务足够小就计算任务</span></span><br><span class="line">        <span class="keyword">boolean</span> canCompute = (end - start) &lt;= THRESHOLD;</span><br><span class="line">        <span class="keyword">if</span> ( canCompute) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果任务大于阈值，就分裂成两个子任务计算</span></span><br><span class="line">            <span class="keyword">int</span> middle = (start + end) / <span class="number">2</span>;</span><br><span class="line">            CountTask leftTask = <span class="keyword">new</span> CountTask(start, middle);</span><br><span class="line">            CountTask rightTask = <span class="keyword">new</span> CountTask(middle + <span class="number">1</span>, end);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//执行子任务</span></span><br><span class="line">            leftTask.fork();</span><br><span class="line">            rightTask.fork();</span><br><span class="line">            <span class="comment">//等待子任务执行完，并取到结果</span></span><br><span class="line">            <span class="keyword">int</span> leftResult = leftTask.join();</span><br><span class="line">            <span class="keyword">int</span> rightResult = rightTask.join();</span><br><span class="line">            <span class="comment">//合并结果</span></span><br><span class="line">            sum = leftResult + rightResult;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        ForkJoinPool forkJoinPool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">        <span class="comment">//生成一个计算任务，负责计算1+2+3+4</span></span><br><span class="line">        CountTask task = <span class="keyword">new</span> CountTask(<span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line">        <span class="comment">//执行任务</span></span><br><span class="line">        Future&lt;Integer&gt; result = forkJoinPool.submit(task);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//检查task执行结果</span></span><br><span class="line">            <span class="keyword">if</span>(task.isCompletedAbnormally()) &#123;</span><br><span class="line">                System.out.println(task.getException());</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(result.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>BlockingQueue阻塞队列</p>
</li>
</ol>
<p>提供两个可以阻塞当前线程的方法扩展Queue的操作，常用于生产者和消费者场景。</p>
<ul>
<li>take() 移除元素，当队列为空时，获取元素的线程会等待队列变为非空。</li>
<li>put() 增加元素，当队列满的时候，队列会阻塞插入元素的线程，直到队列不满。</li>
</ul>
<p><img src="/2018/12/12/Java-Concurrency/BlockingQueue.png" alt="BlockingQueues"></p>
<p>阻塞队列支持四种处理方式，如上图所示，包含7个阻塞队列：</p>
<ol>
<li>ArrayBlockingQueue, 由数组结构组成的有界阻塞队列。</li>
<li>LinkedBlockingQueue, 由链表结构组成的有界阻塞队列。</li>
<li>PriorityBlockingQueue, 支持优先级排序的无界阻塞队列。</li>
<li>SynchronousQueue，一个不存储元素的阻塞队列。</li>
<li>DelayQueue, 使用优先级队列实现的无界阻塞队列。</li>
<li>LinkedTransferQueue, 链表结构组成的无界阻塞队列。</li>
<li>LinkedBlockingDeque, 链表结构组成的双向阻塞队列。</li>
</ol>
<h2 id="线程同步器Synchronizer"><a href="#线程同步器Synchronizer" class="headerlink" title="线程同步器Synchronizer"></a>线程同步器Synchronizer</h2><p>同步器是使线程能够等待另一个线程，允许他们协调动作的工具类。</p>
<ol>
<li>信号量Semaphore</li>
</ol>
<p>信号量是用来控制同时访问特定资源的线程数量的锁，某个时候只能由n个线程同时访问该同步资源，n=1时候信号量和简单互斥锁一样。</p>
<ol start="2">
<li>CountDownLatch</li>
</ol>
<p>CountDownLatch允许一个或多个线程等待其他线程完成操作。当这n个线程都完成时，当前等待线程再执行, CountDownLatch内部的计数器不能重置。</p>
<ol start="3">
<li>CyclicBarrier</li>
</ol>
<p>CyclicBarrier，让一组线程到达一个同步点后再一起继续运行，在其中任意一个线程未达到同步点，其他到达的线程均会被阻塞。</p>
<ol start="4">
<li>Phaser</li>
</ol>
<p>Phaser可以理解为CyclicBarrier的更复杂应用，通过控制每个阶段的锁来控制线程行为。Phaser在n个线程完成一个阶段后才进入下一个多线程阶段。</p>
<ol start="5">
<li>Condition 类</li>
</ol>
<p>Condition类提供了wait(), notify(), notifyAll()接口方法，可以灵活制定锁的行为，同时避免了锁和object的一对一对应关系。condition.wait()释放锁等待，condition.signal()唤醒等待的线程（需要尽快释放锁保证notify成功)。Condition类是BlockingQueue实现的关键类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoundedBuffer</span> </span>&#123;</span><br><span class="line">   <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">   <span class="keyword">final</span> Condition notFull  = lock.newCondition(); </span><br><span class="line">   <span class="keyword">final</span> Condition notEmpty = lock.newCondition(); </span><br><span class="line"></span><br><span class="line">   <span class="keyword">final</span> Object[] items = <span class="keyword">new</span> Object[<span class="number">100</span>];</span><br><span class="line">   <span class="keyword">int</span> putptr, takeptr, count;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Object x)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">     lock.lock();</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="keyword">while</span> (count == items.length)</span><br><span class="line">         notFull.await();</span><br><span class="line">       items[putptr] = x;</span><br><span class="line">       <span class="keyword">if</span> (++putptr == items.length) putptr = <span class="number">0</span>;</span><br><span class="line">       ++count;</span><br><span class="line">       notEmpty.signal();</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">       lock.unlock();</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">     lock.lock();</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">         notEmpty.await();</span><br><span class="line">       Object x = items[takeptr];</span><br><span class="line">       <span class="keyword">if</span> (++takeptr == items.length) takeptr = <span class="number">0</span>;</span><br><span class="line">       --count;</span><br><span class="line">       notFull.signal();</span><br><span class="line">       <span class="keyword">return</span> x;</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">       lock.unlock();</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<ol start="6">
<li>LockSupport 类<br>LockSupport定义了一组公共静态方法，是一个基础工具，提供了线程阻塞和唤醒功能。</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:left">方法名</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">park()</td>
<td style="text-align:center">阻塞当前线程，如果调用unpark()，park()才会返回</td>
</tr>
<tr>
<td style="text-align:left">parkNanos(long nanos</td>
<td style="text-align:center">阻塞当前线程不超过nanos秒</td>
</tr>
<tr>
<td style="text-align:left">parkUntil(long deadline)</td>
<td style="text-align:center">阻塞当前线程，直到deadline时间</td>
</tr>
<tr>
<td style="text-align:left">unpark(Thread t)</td>
<td style="text-align:center">唤醒处于阻塞状态的线程t</td>
</tr>
</tbody>
</table>
<h1 id="多线程问题"><a href="#多线程问题" class="headerlink" title="多线程问题"></a><strong>多线程问题</strong></h1><ol>
<li>数据访问问题（读写）</li>
<li>资源生产与消费问题（生产者-消费者模式）&lt;= 常用来解决数据的强耦合问题</li>
</ol>
<p>下文会展开描述这两类问题。</p>
<h2 id="多线程数据读写访问问题（同步-并发问题）"><a href="#多线程数据读写访问问题（同步-并发问题）" class="headerlink" title="多线程数据读写访问问题（同步/并发问题）"></a>多线程数据读写访问问题（同步/并发问题）</h2><p>由于多线程情况下JVM的内存模型，实际上是存在主内存和工作内存之间的同步问题。读写操作实际上是read-load, store-write操作，在多线程并发时，操作的并发会导致主内存和工作内存某变量值的不同步问题。</p>
<h3 id="synchronized-关键字"><a href="#synchronized-关键字" class="headerlink" title="synchronized 关键字"></a>synchronized 关键字</h3><p>synchronized可以在三个地方使用，一种是在方法体内部，可以进行instance level或者class level(通过synchronized(AccountSync.Class))进行锁定。最后一种是在一个代码块进行锁定，可以指定拿锁的object。</p>
<ul>
<li><p>当synchronized锁定在（静态）方法级别，所有（静态）method只能有一个method被线程调用，其他线程需要等待。同一个线程可重入synchronized区块/方法。</p>
</li>
<li><p>当synchronized锁定在instance级别时，取决于instance的状态，所有需要拿该instance的线程需要等待。也就是说，即使是同一个instance的不同的synchronized method，在某时刻，只能有一个线程访问其中某个synchronized method。</p>
</li>
<li><p>当synchronized锁定在block级别是，需要制定block的owner，即一个object，只有拿到了该object的锁，才能执行相应的block。只是比较推荐的方法，因为可以最小化同步块，同时也能避免基类方法和父类方法的访问造成的“互相绊住脚”的行为。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountSync</span> </span>&#123;</span><br><span class="line">    Object o = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [])</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(o)&#123;</span><br><span class="line">            <span class="comment">//synchronized block </span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">myMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// lock class level access</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><p><a href="https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/locks/Lock.html" target="_blank" rel="noopener">Lock</a>是java的一个interface，所有实现了该接口的类型都具有锁的特质。</p>
<ol>
<li><p>不可重入锁（简单锁）<br>Java底层为每个object提供了mutex，没有拿到锁的线程需要忙等待，没有优先级控制。<br>简单锁本身在java内部没有直接的实现，可以通过Semaphore计数值为1来实现。</p>
</li>
<li><p>可重入锁<a href="https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/locks/ReentrantLock.html" target="_blank" rel="noopener">ReentrantLock</a><br>同一个线程可以重复进入该锁（不会因为同步代码自己调用自己而被死锁）</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Lock l = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">l.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// must in finally 解锁。</span></span><br><span class="line">    l.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>读写锁<br>读写锁是两个锁，分别对应<br><a href="https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/locks/ReentrantReadWriteLock.ReadLock.html" target="_blank" rel="noopener">ReentrantReadWriteLock.ReadLock</a>,<a href="https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/locks/ReentrantReadWriteLock.WriteLock.html" target="_blank" rel="noopener">ReentrantReadWriteLock.WriteLock</a>。</li>
</ol>
<p>读锁，没有线程hold写锁的时候，写锁可以给出，或者读锁可以给多线程访问。<br>写锁，没有线程hold读锁和写锁的时候，读锁可以给出，一旦写锁先被hold，读锁是不允许再被hold。</p>
<p>读写锁的特性如下：</p>
<p><img src="/2018/12/12/Java-Concurrency/RWLock.png" alt="RWLock.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWriteMap</span></span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Map&lt;String, Data&gt; m = <span class="keyword">new</span> TreeMap&lt;String, Data&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ReentrantReadWriteLock rw1 = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">    <span class="keyword">final</span> Lock r = rw1.readLock();</span><br><span class="line">    <span class="keyword">final</span> Lock w = rw1.writeLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Data <span class="title">get</span> <span class="params">(String key)</span></span>&#123;</span><br><span class="line">        r.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> m.get(key)</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123; r.unlock();&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Data <span class="title">put</span> <span class="params">(String key, Data value)</span></span>&#123;</span><br><span class="line">        w.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> m.put(key, value);</span><br><span class="line">        &#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">            w.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="并发集合Concurrent-collection"><a href="#并发集合Concurrent-collection" class="headerlink" title="并发集合Concurrent collection"></a>并发集合Concurrent collection</h3><ol>
<li>ConcurrentHashMap</li>
</ol>
<blockquote>
<p><a href="https://www.cnblogs.com/ITtangtang/p/3948786.html" target="_blank" rel="noopener">https://www.cnblogs.com/ITtangtang/p/3948786.html</a></p>
</blockquote>
<p>HashMap并发问题：</p>
<blockquote>
<p> HashTable容器使用synchronized来保证线程安全，但在线程竞争激烈的情况下HashTable的效率非常低下。因为当一个线程访问HashTable的同步方法时，其他线程访问HashTable的同步方法时，可能会进入阻塞或轮询状态。如线程1使用put进行添加元素，线程2不但不能使用put方法添加元素，并且也不能使用get方法来获取元素，所以竞争越激烈效率越低。</p>
</blockquote>
<p>ConcurrentHashMap解决并发问题:</p>
<blockquote>
<p>ConcurrentHashMap所使用的锁分段技术，首先将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。有些方法需要跨段，比如size()和containsValue()，它们可能需要锁定整个表而而不仅仅是某个段，这需要按顺序锁定所有段，操作完毕后，又按顺序释放所有段的锁。这里“按顺序”是很重要的，否则极有可能出现死锁，在ConcurrentHashMap内部，段数组是final的，并且其成员变量实际上也是final的，但是，仅仅是将数组声明为final的并不保证数组成员也是final的，这需要实现上的保证。这可以确保不会出现死锁，因为获得锁的顺序是固定的。</p>
</blockquote>
<p>ConcurrentHashMap的使用和HashMap相同，API如下:</p>
<pre><code>|API名|操作含义|
|:---|:---:|
|get()|拿key对应的value|
|put()|放元素V|
|size()|获取大小|
|remove()|删除元素|
|putIfAbsent()|存放元素如果没有|
</code></pre><ol start="2">
<li>ConcurrentLinkedQueue<br>线程安全队列有两种实现方式，一种是阻塞算法加锁，另一种是使用循环CAS的方式。ConcurrentLinkedQueue采用的是后者，基于链接节点的无界限线程安全队列。</li>
</ol>
<p>offer()是入队，将节点添加到队尾。<br>poll()是出队，将首节点拿出。</p>
<p><strong>减少死锁优化</strong></p>
<ul>
<li>减少锁的持有时间（同步方法改同步块）</li>
<li>减少锁的粒度（CONCURRENT HASHMAP）</li>
<li>锁分离（读写锁，读锁写锁）（LinkedBlockingQueue，PUT一把锁，锁尾巴，TAKE一把锁锁头）</li>
</ul>
<h3 id="无锁并发工具"><a href="#无锁并发工具" class="headerlink" title="无锁并发工具"></a>无锁并发工具</h3><p>在多核操作系统中，Java提供了很多无锁并发工具。没有需要加锁的需要，避免了developer自己处理线程的阻塞行为，减少这部分开销。原来某些需要锁的场景，通过限制计算机指令执行和强制线程内部缓存失效，可以达到并发读写的需求，而不需要用锁来控制线程访问。</p>
<ol>
<li>volatile 关键字</li>
</ol>
<p>volatile的读写，可以看作是一个锁，对该变量的读写操作进行了同步。概括的说，保证内存可见性，防止指令重排序。</p>
<ol start="2">
<li>final 关键字</li>
</ol>
<p>凡是对成员变量或者本地变量(在方法中的或者代码块中的变量称为本地变量)声明为final的都叫作final变量。final变量经常和static关键字一起使用，作为常量。final变量能保证其初始化的同步操作。</p>
<ol start="3">
<li>原子操作</li>
</ol>
<p>原子操作是指不受多线程影响的最基本单元操作，可以保证同步。<br>Java在JVM层面也支持了同步，lock-free操作，利用CAS无所算法和乐观锁假设(仅在修改数据时候检查锁状态，适合并发修改比较少的情况)。底层是基于读写锁实现。</p>
<blockquote>
<p>CAS是利用CPU的CAS指令，同时借助JNI来完成Java的非阻塞算法,实现原子操作。是直接调用CPU 的cmpxchg（是汇编指令）指令。</p>
</blockquote>
<blockquote>
<p>CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。</p>
</blockquote>
<p>下列操作为原子操作：</p>
<ol>
<li>all assignment of primitive types except for long and double. （并不是说primitive types的所有操作都是原子操作）</li>
<li>all assignment of references</li>
<li>all operations of Java.Concurrent.Atomic.* classes</li>
<li>all assignments to volatile longs and doubles</li>
</ol>
<p><strong>原子类型by Java</strong></p>
<p>java.util.concurrent.atomic包提供了primitive类型的atomic类，它们可以自动的保证对于他们的操作是原子的并且不需要使用同步。但是使用方法和primitive类型完全不同，atomic类型里提供了各种操作方法保证方法/方法流执行的原子性。</p>
<ul>
<li>AtomicBoolean，AtomicInteger，AtomicLong，AtomicReference</li>
</ul>
<p>通过原子的方式更新数组里的某个元素，Atomic包提供了以3类</p>
<ul>
<li>AtomicIntegerArray，AtomicLongArray,AtomicReferenceArray</li>
</ul>
<p>如果需原子地更新某个类里的某个字段时，就需要使用原子更新字段类，Atomic包提供了以下3个类进行原子字段更新。</p>
<ul>
<li>AtomicLongFieldUpdater，AtomicIntegerFieldUpdater，AtomicReferenceFieldUpdater</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicIntegerFieldUpdaterTest</span> </span>&#123; </span><br><span class="line">    <span class="comment">// 创建原子更新器,并设置需要更新的对象类和对象的属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicIntegerFieldUpdater&lt;User&gt; a = </span><br><span class="line">            AtomicIntegerFieldUpdater.newUpdater(User.class, <span class="string">"old"</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;  </span><br><span class="line">        <span class="comment">// 设置柯南的年龄是10岁</span></span><br><span class="line">        User conan = <span class="keyword">new</span> User(<span class="string">"conan"</span>, <span class="number">10</span>);</span><br><span class="line">        <span class="comment">// 柯南长了一岁，但是仍然会输出旧的年龄</span></span><br><span class="line">        System.out.println(a.getAndIncrement(conan));</span><br><span class="line">        <span class="comment">// 输出柯南现在的年龄</span></span><br><span class="line">        System.out.println(a.get(conan));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">int</span> old;</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name, <span class="keyword">int</span> old)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">            <span class="keyword">this</span>.old = old;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOld</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> old;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="多线程的资源生产与消费问题"><a href="#多线程的资源生产与消费问题" class="headerlink" title="多线程的资源生产与消费问题"></a>多线程的资源生产与消费问题</h2><p>Java的Vector容器实际上是线程安全的数据结构，也就是说Vector的各个操作都能保证其原子性，但是也会存在多线程问题。这是因为在Vector的删除和添加操作中，如果存在多线程并发，删除操作的对象是可能是一个空Vector容器，造成问题。Developer需要有很好的上下文控制来避免这种生产消费问题。</p>
<h3 id="多线程管理工具"><a href="#多线程管理工具" class="headerlink" title="多线程管理工具"></a>多线程管理工具</h3><h4 id="Object方法"><a href="#Object方法" class="headerlink" title="Object方法"></a><a href="#通过Object方法控制线程并发">Object方法</a></h4><h4 id="线程调度器"><a href="#线程调度器" class="headerlink" title="线程调度器"></a><a href="#线程调度器Scheduler">线程调度器</a></h4><h4 id="线程同步器"><a href="#线程同步器" class="headerlink" title="线程同步器"></a><a href="#线程同步器Synchronizer">线程同步器</a></h4><h4 id="线程上下文管理工具-1"><a href="#线程上下文管理工具-1" class="headerlink" title="线程上下文管理工具"></a><a href="#线程上下文管理工具">线程上下文管理工具</a></h4><h1 id="题外话：C-多线程工具"><a href="#题外话：C-多线程工具" class="headerlink" title="题外话：C#多线程工具"></a>题外话：C#多线程工具</h1>
          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sunnyhll.github.io/2018/12/11/Java-Streams/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="果核&肉肉">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="微观天下">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/12/11/Java-Streams/" class="post-title-link" itemprop="https://sunnyhll.github.io/page/2/index.html">Java Stream API</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-11 18:09:56" itemprop="dateCreated datePublished" datetime="2018-12-11T18:09:56+08:00">2018-12-11</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-05-06 22:15:35" itemprop="dateModified" datetime="2019-05-06T22:15:35+08:00">2019-05-06</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Java-Streams"><a href="#Java-Streams" class="headerlink" title="Java Streams"></a>Java Streams</h1><p>Java在JDK1.8中引入了Stream API,支持对流的处理。流处理类似于对于数据库数据流进行只读操作后求得某种结果，有如下特点:</p>
<p><img src="/2018/12/11/Java-Streams/JavaStream.png" alt="Java-Streams"></p>
<ol>
<li>stream不存储数据</li>
<li>stream不改变源数据</li>
<li>stream的延迟执行特性</li>
</ol>
<h2 id="Stream-API-简述"><a href="#Stream-API-简述" class="headerlink" title="Stream API 简述"></a>Stream API 简述</h2><h3 id="创建Stream"><a href="#创建Stream" class="headerlink" title="创建Stream"></a>创建Stream</h3><p>Stream.of(Collection<t> collections)时Stream类的静态方法，可以将集合数据转化为Stream。</t></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Stream.of()</span></span><br><span class="line">Stream&lt;Student&gt; stream = Stream.of(stuArr);</span><br><span class="line"><span class="comment">//Arrays.stream</span></span><br><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">34</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    IntStream intStream = Arrays.stream(arr);</span><br></pre></td></tr></table></figure>
<h3 id="Stream操作"><a href="#Stream操作" class="headerlink" title="Stream操作"></a>Stream操作</h3><blockquote>
<p>Reference Link: <a href="https://www.cnblogs.com/CarpenterLee/p/6545321.html" target="_blank" rel="noopener">https://www.cnblogs.com/CarpenterLee/p/6545321.html</a></p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:left">操作类型</th>
<th style="text-align:center">接口方法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">中间操作</td>
<td style="text-align:center">concat() distinct() filter() flatMap() limit() map() peek() skip() sorted() parallel() sequential() unordered()</td>
</tr>
<tr>
<td style="text-align:left">结束操作</td>
<td style="text-align:center">allMatch() anyMatch() collect() count() findAny() findFirst() forEach() forEachOrdered() max() min() noneMatch() reduce() toArray()</td>
</tr>
</tbody>
</table>
<p>对于接口方法的传入参数，是各种函数接口，可以用lamda表达式方便的书写。下面介绍几个经典的API使用：</p>
<ol>
<li>forEach()</li>
</ol>
<p>forEach(Consumer&lt;? super E&gt; action)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用Stream.forEach()迭代</span></span><br><span class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">"I"</span>, <span class="string">"love"</span>, <span class="string">"you"</span>, <span class="string">"too"</span>);</span><br><span class="line">stream.forEach(str -&gt; System.out.println(str));</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>filter()</li>
</ol>
<p>filter(Predicate&lt;? super E&gt; predicate)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保留长度等于3的字符串</span></span><br><span class="line">Stream&lt;String&gt; stream= Stream.of(<span class="string">"I"</span>, <span class="string">"love"</span>, <span class="string">"you"</span>, <span class="string">"too"</span>);</span><br><span class="line">stream.filter(str -&gt; str.length()==<span class="number">3</span>)</span><br><span class="line">    .forEach(str -&gt; System.out.println(str));</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>map()</li>
</ol>
<p><r> Stream<r> map(Function&lt;? super T,? extends R&gt; mapper)</r></r></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; stream　= Stream.of(<span class="string">"I"</span>, <span class="string">"love"</span>, <span class="string">"you"</span>, <span class="string">"too"</span>);</span><br><span class="line">stream.map(str -&gt; str.toUpperCase())</span><br><span class="line">    .forEach(str -&gt; System.out.println(str));</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>reduce()</li>
</ol>
<blockquote>
<p>reference Link: <a href="http://www.cnblogs.com/CarpenterLee/p/6550212.html" target="_blank" rel="noopener">http://www.cnblogs.com/CarpenterLee/p/6550212.html</a></p>
</blockquote>
<ul>
<li>Optional<t> reduce(BinaryOperator<t> accumulator)</t></t></li>
<li>T reduce(T identity, BinaryOperator<t> accumulator)</t></li>
<li>\<u> U reduce(U identity, BiFunction&lt;U,? super T,U&gt; accumulator, BinaryOperator\<u> combiner)</u></u></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找出最长的单词</span></span><br><span class="line"></span><br><span class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">"I"</span>, <span class="string">"love"</span>, <span class="string">"you"</span>, <span class="string">"too"</span>);</span><br><span class="line">Optional&lt;String&gt; longest = stream.reduce((s1, s2) -&gt; s1.length()&gt;=s2.length() ? s1 : s2);</span><br><span class="line"><span class="comment">//Optional&lt;String&gt; longest = stream.max((s1, s2) -&gt; s1.length()-s2.length());</span></span><br><span class="line">System.out.println(longest.get());</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>collect()</li>
</ol>
<ul>
<li><r> R collect(Supplier<r> supplier, BiConsumer&lt;R,? super T&gt; accumulator, BiConsumer&lt;R,R&gt; combiner)</r></r></li>
<li>&lt;R,A&gt; R collect(Collector&lt;? super T,A,R&gt; collector)</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//　将Stream规约成List</span></span><br><span class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">"I"</span>, <span class="string">"love"</span>, <span class="string">"you"</span>, <span class="string">"too"</span>);</span><br><span class="line">List&lt;String&gt; list = stream.collect(ArrayList::<span class="keyword">new</span>, ArrayList::add, ArrayList::addAll);<span class="comment">// 方式１</span></span><br><span class="line"><span class="comment">//List&lt;String&gt; list = stream.collect(Collectors.toList());// 方式2</span></span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure>
<h2 id="LINQ-in-C"><a href="#LINQ-in-C" class="headerlink" title="LINQ in C#"></a>LINQ in C#</h2><p>与Java语言相比，C#引入了LINQ，lamda表达式和扩展方法来更好的支持chaining operation。LinQ支持所有实现了Enumberable接口的类型。</p>
<ol>
<li><p>ForEach()</p>
<p> .ForEach(Action<t> action)</t></p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;string&gt; stringList = new List&lt;string&gt;（）;</span><br><span class="line">   stringList.Add(&quot;I&quot;);</span><br><span class="line">   stringList.Add(&quot;love&quot;);</span><br><span class="line">   stringList.Add(&quot;you&quot;);</span><br><span class="line">   stringList.Add(&quot;too&quot;);</span><br><span class="line">   stringList.ForEach(a =&gt; Console.WriteLine(a));</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><p>Where()</p>
<p> .Where(Func&lt;T, bool&gt; function)</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stringList.Where( x=&gt; x.Length == 3)</span><br><span class="line">            .ForEach( x=&gt; Console.WriteLine(x));</span><br></pre></td></tr></table></figure>
<ol start="3">
<li><p>Select()</p>
<p> .Select(Func&lt;T, int, R&gt; function)</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stringList.Selct((x, i) =&gt; x.ToUpper())</span><br><span class="line">            .ForEach( x=&gt; Console.WriteLine(x));</span><br></pre></td></tr></table></figure>
<ol start="4">
<li><p>Aggregate()</p>
<p> .Aggregate(A, Func&lt;A, T, A&gt; function, Func&lt;A, R&gt; function2)</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stringList.Aggregate(&quot;&quot;, (cur, next) =&gt; cur.Length &gt; next.Length ? cur : next, x =&gt; Console.WriteLine(x));</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>扩展方法，Java collect()方法是.NET扩展方法功能的一种实现，C#通过定义扩展方法更好的支持LINQ的Chaining功能，使得Java Collectors的接口都可以直接通过相似的方法实现。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stringList.Select(x=&gt;x).toList();</span><br></pre></td></tr></table></figure>
          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sunnyhll.github.io/2018/12/08/Java-Collections/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="果核&肉肉">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="微观天下">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/12/08/Java-Collections/" class="post-title-link" itemprop="https://sunnyhll.github.io/page/2/index.html">Java集合框架</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-08 20:18:42" itemprop="dateCreated datePublished" datetime="2018-12-08T20:18:42+08:00">2018-12-08</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-12-21 13:36:15" itemprop="dateModified" datetime="2020-12-21T13:36:15+08:00">2020-12-21</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Java集合框架"><a href="#Java集合框架" class="headerlink" title="Java集合框架"></a>Java集合框架</h1><blockquote>
<p>Reference Link: <a href="http://www.runoob.com/java/java-collections.html" target="_blank" rel="noopener">http://www.runoob.com/java/java-collections.html</a></p>
</blockquote>
<p>集合框架被设计成要满足以下几个目标。</p>
<ul>
<li>该框架必须是高性能的。基本集合（动态数组，链表，树，哈希表）的实现也必须是高效的。</li>
<li>该框架允许不同类型的集合，以类似的方式工作，具有高度的互操作性。</li>
<li>对一个集合的扩展和适应必须是简单的。<br>为此，整个集合框架就围绕一组标准接口而设计。你可以直接使用这些接口的标准实现，如下图所示，诸如： LinkedList, HashSet, 和 TreeSet 等,除此之外你也可以通过这些接口实现自己的集合。</li>
</ul>
<p><img src="/2018/12/08/Java-Collections/JavaCollectionsUML.gif" alt="JavaCollectionsUML"></p>
<p>从上面的集合框架图可以看到，Java 集合框架主要包括两种类型的容器，一种是集合（Collection），存储一个元素集合，另一种是图（Map），存储键/值对映射。Collection 接口又有 3 种子类型，List、Set 和 Queue，再下面是一些抽象类，最后是具体实现类，常用的有 ArrayList、LinkedList、HashSet、LinkedHashSet、HashMap、LinkedHashMap 等等。</p>
<p>集合框架是一个用来代表和操纵集合的统一架构。所有的集合框架都包含如下内容：</p>
<ul>
<li>接口：是代表集合的抽象数据类型。例如 Collection、List、Set、Map 等。之所以定义多个接口，是为了以不同的方式操作集合对象</li>
<li>实现（类）：是集合接口的具体实现。从本质上讲，它们是可重复使用的数据结构，例如：ArrayList、LinkedList、HashSet、HashMap。</li>
<li>算法：是实现集合接口的对象里的方法执行的一些有用的计算，例如：搜索和排序。这些算法被称为多态，那是因为相同的方法可以在相似的接口上有着不同的实现。<br>除了集合，该框架也定义了几个 Map 接口和类。Map 里存储的是键/值对。尽管 Map 不是集合，但是它们完全整合在集合中。</li>
</ul>
<p>集合框架体系如图所示:</p>
<p><img src="/2018/12/08/Java-Collections/java-coll-architecture.png" alt="JavaCollArch"></p>
<h2 id="集合接口"><a href="#集合接口" class="headerlink" title="集合接口"></a>集合接口</h2><ol>
<li><a href="https://docs.oracle.com/javase/tutorial/collections/interfaces/collection.html" target="_blank" rel="noopener">Collection 接口</a></li>
</ol>
<p>Collection 是最基本的集合接口，一个 Collection 代表一组 Object，即 Collection 的元素, Java不提供直接继承自Collection的类，只提供继承于的子接口(如List和set)。<br>Collection 接口存储一组不唯一，无序的对象。</p>
<ol start="2">
<li><a href="https://docs.oracle.com/javase/7/docs/api/java/util/List.html" target="_blank" rel="noopener">List 接口</a></li>
</ol>
<p>List接口是一个有序的 Collection，使用此接口能够精确的控制每个元素插入的位置，能够通过索引(元素在List中位置，类似于数组的下标)来访问List中的元素，第一个元素的索引为 0，而且允许有相同的元素。<br>List 接口存储一组不唯一，有序（插入顺序）的对象。</p>
<ol start="3">
<li><a href="https://docs.oracle.com/javase/7/docs/api/java/util/Set.html" target="_blank" rel="noopener">Set 接口</a></li>
</ol>
<p>Set 具有与 Collection 完全一样的接口，只是行为上不同，Set 不保存重复的元素。<br>Set 接口存储一组唯一，无序的对象。</p>
<ol start="4">
<li><a href="https://docs.oracle.com/javase/7/docs/api/java/util/SortedSet.html" target="_blank" rel="noopener">SortedSet 接口</a></li>
</ol>
<p>继承于Set保存有序的集合。</p>
<ol start="5">
<li><a href="https://docs.oracle.com/javase/7/docs/api/java/util/Map.html" target="_blank" rel="noopener">Map 接口</a></li>
</ol>
<p>Map 接口存储一组键值对象，提供key（键）到value（值）的映射。</p>
<ol start="6">
<li><a href="https://docs.oracle.com/javase/7/docs/api/java/util/Map.Entry.html" target="_blank" rel="noopener">Map.Entry 接口</a></li>
</ol>
<p>描述在一个Map中的一个元素（键/值对）。是一个Map的内部类。</p>
<ol start="7">
<li><a href="https://docs.oracle.com/javase/7/docs/api/java/util/SortedMap.html" target="_blank" rel="noopener">SortedMap 接口</a></li>
</ol>
<p>继承于 Map，使 Key 保持在升序排列。</p>
<ol start="8">
<li><a href="https://www.tutorialspoint.com/java/java_enumeration_interface.htm" target="_blank" rel="noopener">Enumeration 接口</a></li>
</ol>
<p>这是一个传统的接口和定义的方法，通过它可以枚举（一次获得一个）对象集合中的元素。这个传统接口已被迭代器取代。</p>
<ol start="9">
<li><a href="https://docs.oracle.com/javase/tutorial/collections/interfaces/queue.html" target="_blank" rel="noopener">Queue 接口</a></li>
</ol>
<p>Queue是队列实现，实现了先进先出功能。</p>
<h2 id="集合实现类（集合类）"><a href="#集合实现类（集合类）" class="headerlink" title="集合实现类（集合类）"></a>集合实现类（集合类）</h2><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><table>
<thead>
<tr>
<th style="text-align:left">类名</th>
<th style="text-align:center">内容</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">AbstractCollection</td>
<td style="text-align:center">实现了大部分的集合接口。</td>
</tr>
<tr>
<td style="text-align:left">AbstractList</td>
<td style="text-align:center">继承于AbstractCollection 并且实现了大部分List接口。</td>
</tr>
<tr>
<td style="text-align:left">AbstractSequentialList</td>
<td style="text-align:center">继承于 AbstractList ，提供了对数据元素的链式访问而不是随机访问。</td>
</tr>
<tr>
<td style="text-align:left">AbstractSet</td>
<td style="text-align:center">继承于AbstractCollection 并且实现了大部分Set接口。</td>
</tr>
<tr>
<td style="text-align:left">AbstractMap</td>
<td style="text-align:center">实现了大部分的Map接口。</td>
</tr>
</tbody>
</table>
<h3 id="集合类"><a href="#集合类" class="headerlink" title="集合类"></a>集合类</h3><table>
<thead>
<tr>
<th style="text-align:left">类名</th>
<th style="text-align:center">内容</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">LinkedList</td>
<td style="text-align:center">该类实现了List接口，允许有null（空）元素。主要用于创建链表数据结构，该类没有同步方法，如果多个线程同时访问一个List，则必须自己实现访问同步，解决方法就是在创建List时候构造一个同步的List。例如: <code>Listlist=Collections.synchronizedList(newLinkedList(...));</code>LinkedList 查找效率低。</td>
</tr>
<tr>
<td style="text-align:left">ArrayList</td>
<td style="text-align:center">该类也是实现了List的接口，实现了可变大小的数组，随机访问和遍历元素时，提供更好的性能。该类也是非同步的,在多线程的情况下不要使用。ArrayList 增长当前长度的50%，插入删除效率低。</td>
</tr>
<tr>
<td style="text-align:left">HashSet</td>
<td style="text-align:center">该类实现了Set接口，不允许出现重复元素，不保证集合中元素的顺序，允许包含值为null的元素，但最多只能一个。</td>
</tr>
<tr>
<td style="text-align:left">LinkedHashSet</td>
<td style="text-align:center">具有可预知迭代顺序的 Set 接口的哈希表和链接列表实现。</td>
</tr>
<tr>
<td style="text-align:left">TreeSet</td>
<td style="text-align:center">该类实现了Set接口，可以实现排序等功能。</td>
</tr>
<tr>
<td style="text-align:left">HashMap</td>
<td style="text-align:center">HashMap 是一个散列表，它存储的内容是键值对(key-value)映射。该类实现了Map接口，根据键的HashCode值存储数据，具有很快的访问速度，最多允许一条记录的键为null，不支持线程同步。</td>
</tr>
<tr>
<td style="text-align:left">TreeMap</td>
<td style="text-align:center">继承了AbstractMap，并且使用一颗树。</td>
</tr>
<tr>
<td style="text-align:left">WeakHashMap</td>
<td style="text-align:center">继承AbstractMap类，使用弱密钥的哈希表。</td>
</tr>
<tr>
<td style="text-align:left">LinkedHashMap</td>
<td style="text-align:center">继承于HashMap，使用元素的自然顺序对元素进行排序.</td>
</tr>
<tr>
<td style="text-align:left">IdentityHashMap</td>
<td style="text-align:center">继承AbstractMap类，比较文档时使用引用相等。</td>
</tr>
</tbody>
</table>
<h3 id="其他：数据结构类"><a href="#其他：数据结构类" class="headerlink" title="其他：数据结构类"></a>其他：数据结构类</h3><table>
<thead>
<tr>
<th style="text-align:left">类名</th>
<th style="text-align:center">内容</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Vector</td>
<td style="text-align:center">该类和ArrayList非常相似，但是该类是同步的，可以用在多线程的情况，该类允许设置默认的增长长度，默认扩容方式为原来的2倍。</td>
</tr>
<tr>
<td style="text-align:left">Stack</td>
<td style="text-align:center">栈是Vector的一个子类，它实现了一个标准的后进先出的栈。</td>
</tr>
<tr>
<td style="text-align:left">Dictionary</td>
<td style="text-align:center">Dictionary 类是一个抽象类，用来存储键/值对，作用和Map类相似。</td>
</tr>
<tr>
<td style="text-align:left">Hashtable</td>
<td style="text-align:center">Hashtable 是 Dictionary(字典) 类的子类，位于 java.util 包中。</td>
</tr>
<tr>
<td style="text-align:left">Properties</td>
<td style="text-align:center">Properties 继承于 Hashtable，表示一个持久的属性集，属性列表中每个键及其对应值都是一个字符串。</td>
</tr>
<tr>
<td style="text-align:left">BitSet</td>
<td style="text-align:center">一个Bitset类创建一种特殊类型的数组来保存位值。BitSet中数组大小会随需要增加。</td>
</tr>
</tbody>
</table>
<h2 id="遍历示例代码"><a href="#遍历示例代码" class="headerlink" title="遍历示例代码"></a>遍历示例代码</h2><h3 id="遍历ArrayList"><a href="#遍历ArrayList" class="headerlink" title="遍历ArrayList"></a>遍历ArrayList</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">     List&lt;String&gt; list=<span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">     list.add(<span class="string">"Hello"</span>);</span><br><span class="line">     list.add(<span class="string">"World"</span>);</span><br><span class="line">     list.add(<span class="string">"HAHAHAHA"</span>);</span><br><span class="line">     <span class="comment">//第一种遍历方法使用foreach遍历List</span></span><br><span class="line">     <span class="keyword">for</span> (String str : list) &#123;            <span class="comment">//也可以改写for(int i=0;i&lt;list.size();i++)这种形式</span></span><br><span class="line">        System.out.println(str);</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">//第二种遍历，把链表变为数组相关的内容进行遍历</span></span><br><span class="line">     String[] strArray=<span class="keyword">new</span> String[list.size()];</span><br><span class="line">     list.toArray(strArray);</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;strArray.length;i++) <span class="comment">//这里也可以改写为  foreach(String str:strArray)这种形式</span></span><br><span class="line">     &#123;</span><br><span class="line">        System.out.println(strArray[i]);</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//第三种遍历 使用迭代器进行相关遍历</span></span><br><span class="line">     </span><br><span class="line">     Iterator&lt;String&gt; ite=list.iterator();</span><br><span class="line">     <span class="keyword">while</span>(ite.hasNext())<span class="comment">//判断下一个元素之后有值</span></span><br><span class="line">     &#123;</span><br><span class="line">         System.out.println(ite.next());</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="遍历Map"><a href="#遍历Map" class="headerlink" title="遍历Map"></a>遍历Map</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">      map.put(<span class="string">"1"</span>, <span class="string">"value1"</span>);</span><br><span class="line">      map.put(<span class="string">"2"</span>, <span class="string">"value2"</span>);</span><br><span class="line">      map.put(<span class="string">"3"</span>, <span class="string">"value3"</span>);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//第一种：普遍使用，二次取值</span></span><br><span class="line">      System.out.println(<span class="string">"通过Map.keySet遍历key和value："</span>);</span><br><span class="line">      <span class="keyword">for</span> (String key : map.keySet()) &#123;</span><br><span class="line">       System.out.println(<span class="string">"key= "</span>+ key + <span class="string">" and value= "</span> + map.get(key));</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//第二种</span></span><br><span class="line">      System.out.println(<span class="string">"通过Map.entrySet使用iterator遍历key和value："</span>);</span><br><span class="line">      Iterator&lt;Map.Entry&lt;String, String&gt;&gt; it = map.entrySet().iterator();</span><br><span class="line">      <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">       Map.Entry&lt;String, String&gt; entry = it.next();</span><br><span class="line">       System.out.println(<span class="string">"key= "</span> + entry.getKey() + <span class="string">" and value= "</span> + entry.getValue());</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//第三种：推荐，尤其是容量大时</span></span><br><span class="line">      System.out.println(<span class="string">"通过Map.entrySet遍历key和value"</span>);</span><br><span class="line">      <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : map.entrySet()) &#123;</span><br><span class="line">       System.out.println(<span class="string">"key= "</span> + entry.getKey() + <span class="string">" and value= "</span> + entry.getValue());</span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">      <span class="comment">//第四种</span></span><br><span class="line">      System.out.println(<span class="string">"通过Map.values()遍历所有的value，但不能遍历key"</span>);</span><br><span class="line">      <span class="keyword">for</span> (String v : map.values()) &#123;</span><br><span class="line">       System.out.println(<span class="string">"value= "</span> + v);</span><br><span class="line">      &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="题外话：-Java-数组"><a href="#题外话：-Java-数组" class="headerlink" title="题外话： Java 数组"></a>题外话： Java 数组</h1><p>Java 数组是很容易和Java动态数组(ArrayList)进行混淆的数据结构。其实Java数组本身并不具有方法，唯一的属性是length。对于数组的大小也不能改变，很多功能需要借助Utility类Arrays提供的静态方法。</p>
<p>Java中的所有数组都是通过Array类实例化。Array类没有public的构造方法，数组是通过Array的newInstance()方法进行实例化。Java数组是支持所有类型的，也就是说对于自定义引用类型，也能创建数组类型，但是与动态数组的方式不同，内存分配机制上也有所不同。</p>
<h2 id="Array类源码"><a href="#Array类源码" class="headerlink" title="Array类源码"></a>Array类源码</h2><p>数组类的实现主要基于本地方法创建，申请分配一段连续内存，每一个数组元素支持强类型检查。长度不支持扩展。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lang;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">System</span> </span>&#123;</span><br><span class="line">    <span class="comment">//System 类不能被实例化。 </span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">System</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="comment">//在 System 类提供的设施中，有标准输入、标准输出和错误输出流；对外部定义的属性</span></span><br><span class="line">    <span class="comment">//和环境变量的访问；加载文件和库的方法；还有快速复制数组的一部分的实用方法。</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * src and dest都必须是同类型或者可以进行转换类型的数组．</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>      src      the source array.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>      srcPos   starting position in the source array.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>      dest     the destination array.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>      destPos  starting position in the destination data.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>      length   the number of array elements to be copied.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">arraycopy</span><span class="params">(Object src, <span class="keyword">int</span> srcPos, Object dest,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> destPos, <span class="keyword">int</span> length)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">package</span> com.lang.reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Array</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建一个具有指定的组件类型和维度的新数组。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newInstance</span><span class="params">(Class&lt;?&gt; componentType, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> NegativeArraySizeException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> newArray(componentType, length);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> Object <span class="title">newArray</span><span class="params">(Class componentType, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> NegativeArraySizeException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数组声明与初始化"><a href="#数组声明与初始化" class="headerlink" title="数组声明与初始化"></a>数组声明与初始化</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//直接声明空数组</span></span><br><span class="line">dataType[] arrayRefVar = <span class="keyword">new</span> dataType[arraySize];</span><br><span class="line"><span class="comment">//直接引入数组元素，用花括弧创建</span></span><br><span class="line"><span class="keyword">int</span> [] arrayRefVar2 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="comment">//访问时通过下标访问</span></span><br><span class="line">System.out.println(arrayRefVar2[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure>
<h2 id="多维数组声明与初始化"><a href="#多维数组声明与初始化" class="headerlink" title="多维数组声明与初始化"></a>多维数组声明与初始化</h2><p>多维数组其实就是一维数组的嵌套扩展，维度取决于数组各个元素的类型，如果是一个数组则能增加一个维度。因此多维数组的创建与访问也是基于一维数组的方法。Array类属性只有length一个，访问是基于下标的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//直接声明矩阵二维数组</span></span><br><span class="line">dataType[][] arrayRefVar = <span class="keyword">new</span> dataType[colsize][rowsize];</span><br><span class="line"><span class="comment">//分段申明非矩阵二维数组</span></span><br><span class="line">dataType[][] arrayRefVar2 = <span class="keyword">new</span> dataType[colsize][];</span><br><span class="line">arrayRefVar2[<span class="number">0</span>] = <span class="keyword">new</span> dataType[row1size];</span><br><span class="line">arrayRefVar2[<span class="number">1</span>] = <span class="keyword">new</span> dataType[row2size];</span><br><span class="line"><span class="comment">//直接引入数组元素，用嵌套花括弧创建，按照维度分配，第一个是第一列</span></span><br><span class="line"><span class="keyword">int</span>[][] arrayint = &#123;</span><br><span class="line">  &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;,</span><br><span class="line">  &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//直接引入数组元素，用下标顺序填入</span></span><br><span class="line"><span class="keyword">int</span>[][] array2 = &#123;<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>], <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>]&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数组的访问是基于下标 array2[col][row]</span></span><br></pre></td></tr></table></figure>
<h1 id="题外话-Arrays-类"><a href="#题外话-Arrays-类" class="headerlink" title="题外话: Arrays 类"></a>题外话: <a href="https://docs.oracle.com/javase/tutorial/java/nutsandbolts/arrays.html" target="_blank" rel="noopener">Arrays 类</a></h1><p>java.util.Arrays 类能方便地操作数组，它提供的所有方法都是静态的。<br>具有以下功能：</p>
<ul>
<li>给数组赋值：通过 fill 方法。</li>
<li>对数组排序：通过 sort 方法,按升序。</li>
<li>比较数组：通过 equals 方法比较数组中元素值是否相等。</li>
<li>查找数组元素：通过 binarySearch 方法能对排序好的数组进行二分查找法操作。</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">方法名</th>
<th style="text-align:center">内容</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>public static int binarySearch(Object[] a, Object key)</code></td>
<td style="text-align:center">用二分查找算法在给定数组中搜索给定值的对象(Byte,Int,double等)。数组在调用前必须排序好的。如果查找值包含在数组中，则返回搜索键的索引；否则返回 (-(插入点) - 1)。</td>
</tr>
<tr>
<td style="text-align:left"><code>public static boolean equals(long[] a, long[] a2)</code></td>
<td style="text-align:center">如果两个指定的 long 型数组彼此相等，则返回 true。如果两个数组包含相同数量的元素，并且两个数组中的所有相应元素对都是相等的，则认为这两个数组是相等的。换句话说，如果两个数组以相同顺序包含相同的元素，则两个数组是相等的。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等）。</td>
</tr>
<tr>
<td style="text-align:left"><code>public static void fill(int[] a, int val)</code></td>
<td style="text-align:center">将指定的 int 值分配给指定 int 型数组指定范围中的每个元素。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等）。</td>
</tr>
<tr>
<td style="text-align:left"><code>public static void sort(Object[] a)</code></td>
<td style="text-align:center">对指定对象数组根据其元素的自然顺序进行升序排列。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等）。</td>
</tr>
</tbody>
</table>
<h1 id="题外话：-Collections-类"><a href="#题外话：-Collections-类" class="headerlink" title="题外话： Collections 类"></a>题外话： <a href="https://docs.oracle.com/javase/7/docs/api/java/util/Collections.html" target="_blank" rel="noopener">Collections 类</a></h1>
          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sunnyhll.github.io/2018/11/17/Phoenix-Project-Reading-Notes/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="果核&肉肉">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="微观天下">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/11/17/Phoenix-Project-Reading-Notes/" class="post-title-link" itemprop="https://sunnyhll.github.io/page/2/index.html">Phoenix Project Reading Notes</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-11-17 13:40:59" itemprop="dateCreated datePublished" datetime="2018-11-17T13:40:59+08:00">2018-11-17</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-05-06 22:15:35" itemprop="dateModified" datetime="2019-05-06T22:15:35+08:00">2019-05-06</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/读书笔记/" itemprop="url" rel="index"><span itemprop="name">读书笔记</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="读书笔记-——-《凤凰项目：一个IT运维的传奇故事》"><a href="#读书笔记-——-《凤凰项目：一个IT运维的传奇故事》" class="headerlink" title="读书笔记 —— 《凤凰项目：一个IT运维的传奇故事》"></a>读书笔记 —— 《凤凰项目：一个IT运维的传奇故事》</h1><p>本书从IT运维管理者的第一视角，讲述了IT部门每天都会发生的事情，并通过从工厂管理经验中借鉴到的方法，改善了IT部分的产能的故事。</p>
<h2 id="IT工作者的每日工作项目"><a href="#IT工作者的每日工作项目" class="headerlink" title="IT工作者的每日工作项目"></a>IT工作者的每日工作项目</h2><p>IT人员的工作往往分为如下几个项目。所以每一个程序员需要重视这四类工作。</p>
<h3 id="业务项目"><a href="#业务项目" class="headerlink" title="业务项目"></a>业务项目</h3><p>这是多数开发项目所包含的业务举措，通常隶属于项目管理办公室。虽然是IT项目，但大多数是跟业务的利润有直接相关联。</p>
<h3 id="IT内部项目"><a href="#IT内部项目" class="headerlink" title="IT内部项目"></a>IT内部项目</h3><p>IT内部项目包括可能由业务项目衍生出的基础架构或IT运维项目，亿级内部生成的改进项目（例如创建新环境和部署自动化等）。这类项目业务部门并不是直接集中跟踪管理的，而属于预算所有者（例如数据库经理、存储管理经理和分布式系统经理）。</p>
<h3 id="变更"><a href="#变更" class="headerlink" title="变更"></a>变更</h3><p>经常由前两种类型的工作引起，往往在保修系统中被跟踪（例如IT运维补救、JIRA或者用于开发的敏捷计划工具）。事实上，在价值流的两个不同部分中存在两个工作跟踪系统，这会引起问题，尤其在交接工作的时候。</p>
<p>某些情况下，在一些兼具功能开发和服务交付指责的专门团队中，所有工作都会处在同一个系统中。这样做的好处是，操作层面的故障会和功能缺陷以及新的特性功能一起，在存量工作和现行工作中显现。</p>
<p>在生产环境的变更是需要严格关注的，有的公司会专门对生产环境的变更进行记录。尤其会对变更本身的原因，步骤，以及风险评估和处理细节都进行记录。变更记录会交由管理者进行审批从而在计划时间窗口生效。</p>
<h3 id="计划外项目-救火"><a href="#计划外项目-救火" class="headerlink" title="计划外项目/救火"></a>计划外项目/救火</h3><p>包括操作事故和操作问题，通常由上述三类型的工作导致，而且往往以牺牲其他计划内工作为代价。</p>
<h2 id="布伦特——约束点问题"><a href="#布伦特——约束点问题" class="headerlink" title="布伦特——约束点问题"></a>布伦特——约束点问题</h2><p>文中的工程师布伦特是IT运维部的约束点，原因是：</p>
<ul>
<li>IT运维工作中最优秀的救火队员</li>
<li>IT运维视角唯一的项目系统架构师</li>
<li>IT变更项目中时常存在的执行者</li>
<li>项目半成品堆积：由于救火项目或者忙等待问题造成。</li>
</ul>
<p>每个工作中心中都存在他的身影，个人能力的有限决定了IT部门的产出有限。</p>
<p><strong>约束点问题解决了，工作产能问题便能解决。所有在非约束点做的改进都是假象。</strong></p>
<p>对应的改善约束点问题的方案：</p>
<ul>
<li>建立L3支持工程师代替执行并学习布伦特的救火技术，建立其他人可以借鉴的trouble shooting检查清单。</li>
<li>专一做到资深架构应该做的工作：关键项目的系统架构</li>
<li>将需要布伦特参与的项目进行工作和流程标准化管理</li>
<li>IT工作可视化并控制半成品</li>
</ul>
<blockquote>
<p>等待时间是工作中心中某个资源忙碌成都的函数。下图横轴坐标上是工作重心中给定资源的忙碌百分比，纵坐标轴上是大致的等待时间（更确切的说是队列长度）。等待时间=忙碌时间百分比/空闲时间百分比。曲线的形状表明，当资源使用率超过80%时，等待时间就会直线上升。这会对项目交付产生灾难性后果。</p>
</blockquote>
<p><img src="/2018/11/17/Phoenix-Project-Reading-Notes/WaitingTime.jpg" alt="waitingtime"></p>
<p>看板对于IT中的半成品问题是最有效、最简单的一种对策。两本书推荐阅读：</p>
<ol>
<li>《个人看板:了解工作/驾驭生活》by吉姆·本森和托尼安妮·德马里亚·巴里</li>
<li>《看板方法：科技企业渐进变革成功之道》by戴维·J·安德森</li>
</ol>
<h2 id="工作流程改进————形"><a href="#工作流程改进————形" class="headerlink" title="工作流程改进————形"></a>工作流程改进————形</h2><p>为了将IT的工作项目完善的进行预先评估和量化分析，每一项工作类型都可以进行执行周期的管理与规划，尽量减少工作半成品的积压，并且最大化工作成品的“吞吐量”。本文提出需要进行“改进形”计划：</p>
<blockquote>
<p>以两周为周期，进行两个“计划-执行-审核-落实”改进周期，确立项目需要的四大要素：机器、方法、人员与测评。每两周必须做出一些改进，无论任何形式的改进。</p>
</blockquote>
<blockquote>
<p>积压的项目分为三类：需要布伦特参与的项目，可以提高布伦特生产力的项目，其他项目。优先开展后两类项目；对于需要布伦特参与的项目遵循约束点问题解决方案进行优化。</p>
</blockquote>
<p>“改进形”带来的好处：</p>
<ul>
<li>提供一种适用于各种问题或挑战的系统化科学规程；</li>
<li>组织成员普遍养成解决问题的习惯；</li>
<li>通过让经理开展周期性指导，让其向教练和导师的角色转变；</li>
<li>通过让人们每天慢慢进步的方法，形成PDCA（Plan-Do-Check-Action）。</li>
</ul>
<blockquote>
<p>微软IT案例研究《在9个月内实现逆袭：在微软IT部门应用鼓点-缓冲-绳子解决法（译注：即限制驱导式排程法）》，作者是戴维·J．安德森和德拉戈什·杜密特里乌。</p>
<p>当时安德森和杜密特里乌两人都在微软，他们描述了以前那种糟透了的状态。大多数IT从业人员&gt;对那种状态都再熟悉不过了。</p>
<p>❑ 完成业务部门要求的工作耗时过长：平均交付周期是155天。</p>
<p>❑ 对于延误和长交付周期的不满迫使IT管理作出“更多的工作预估”，这让经理们不得不把全部时<br>间都用来做PPT，而不是干实事（因为业务部门的结论是他们没有作出正确的工作预估）。</p>
<p>❑ 不管业务部门提出什么要求，回答永远是“做这件事需要5个月”。</p>
<p>❑ 每项任务都预计在20天内完成，但是没人知道多出的那135天都去哪儿了。</p>
<p>杜密特里乌在报修系统中创建了一个名叫“等待德拉戈什”的新字段（实际上，这个报修系统是微&gt;软缺陷跟踪系统），以及时发现工作阻碍。他很快得出结论，项目团队70%的时间都卡在了别人&gt;那里——也就是说，在70%的时间里，工作都在排队。<br>杜密特里乌认为，他的团队一个月只能完成3项工作，按照这个速度，需要三年才能完成所有的&gt;工作。以下是他提出的对策及其惊人结果。</p>
<p>❑ 他们不再预估工作，而采用根据历史数据得出的实际时间——他们有80个人——报修系统里有多&gt;年的工作记录供他们使用。这样做的结果是开发和测试效率立刻提高了30%。</p>
<p>❑ 他们不再采用成本核算，而采用简单的“基于预算贡献的ROI（Return on Investment，投资&gt;回报率）”。所节省的时间让PM能力立刻提高了20%。</p>
<p>❑ 发现约束点是开发部之后，PM接管了许多开发任务，把开发能力提高了20%。这样做也让开发&gt;人员更加高兴，因为他们可以专心写代码，不用再作任务预估了。</p>
<p>❑ 他们引进了一名可用性专家来调整变更申请表。（他打趣说：“我们得填完4页表格，才能得到&gt;一杯水；我们把4页表格换成2页的，上面还有很多自由格式字段，目的是保证从事这项工作的人&gt;了解其所需的全部信息。”）</p>
<p>❑ 接着他们减少了系统中允许的半成品数量：一开始平均有40到60个未结项目，他们把未结项目&gt;数减少到了5个。</p>
<p>❑ 然后他们创建了工作缓冲区，任何遇到阻碍的开发或测试人员都能在缓冲区里做一些工作。</p>
<p>❑ 交付周期从155天下降到22天。这么短的交付周期让他们创造了一个新的SLA认证（SLA &gt;guarantee）,25天（哇哦！）。</p>
<p>❑ 他们的下一轮生产能力大幅提高来自于增加开发人员数量，因为每两天的开发工作就需要一天&gt;的测试工作。他们提拔了愿意参与开发工作的测试人员，把开发人员和测试人员的比例从1∶1提&gt;高到2∶1。</p>
<p>❑ 上述种种的结果是什么？他们在9个月里完成了整整3年积压下来的工作；对他们服务的需求量&gt;也增加了，然后他们继续在其后的每个月都顺利完成并交付了所有业务部门要求的工作；不仅没&gt;人被解雇，而且很多人还升了职。<br>杜密特里乌说：“我们始终致力于降低交付周期，而不是开发和测试自身的优化，因此我们成功&gt;了。”</p>
<p>这只是详细描述的众多惊人转变之一。难以置信的是，转变主要不是基于自动化，相反，这种不&gt;可思议的改进来自于调整关于工作系统的策略和控制半成品的策略，确保有一个高效的跨职能团&gt;队，让所有事情都为约束点服务，以及管理好工作交接。</p>
</blockquote>
<h1 id="IT工作管理核心思想"><a href="#IT工作管理核心思想" class="headerlink" title="IT工作管理核心思想"></a>IT工作管理核心思想</h1><h2 id="三步工作法"><a href="#三步工作法" class="headerlink" title="三步工作法"></a>三步工作法</h2><p><strong>第一工作法</strong>是关于从开发到IT运维再到客户的整个自左向右的工作流。为了使流量最大化，我们需要小的批量规模和工作间隔，决不让缺陷刘翔下游工作中心，并且不断为了整体目标(相对于开发功能完成率、测试发现/修复比率或运维有效性指标等局部目标）进行优化。</p>
<p>必要的做法包括持续构建、集成以及部署，按需创建环境，严控半成品，以及构建起能够顺利变更的安全系统和组织。</p>
<p><strong>第二工作法</strong>是关于价值流各阶段自右向左的快速持续反馈流，放大其效益以确保防止问题再次发生，或者更快地发现和修复问题。这样，我们就能在所需之处获取或嵌入知识，从源头上保证质量。</p>
<p>必要的做法包括：在部署管道中的构建和测试失败时“停止生产线”；日复一日地持续改进日常工作；创建快速的自动化测试套装软件，以确保代码总是处于可部署的状态；在开发和IT运维之间建立共同的目标和共同解决问题的机制；建立普遍的产品遥测技术，让每个人都能知道，代码和环境是否在按照设定的运行，以及是否达到了客户的目标。</p>
<p><strong>第三工作法</strong>是关于创造公司文化，该文化可带动两种风气的形成：不断尝试，这需要承担风险并从成功和失败中吸取经验教训；理解重复和练习是熟练掌握的前提。</p>
<p>尝试和承担风险让我们能够不懈地改进工作系统，这经常要求我们去做一些与几十年来的做法大不相同的事。一旦出了问题，不断重复的日常操练赋予我们的技能和经验，令我们可以撤回至安全区域并恢复正常运作。</p>
<p>必要的做法包括营造一种勇于创新、敢于冒险（相对于畏惧或盲目服从命令）以及高信任度（相对于低信任度和命令控制）的文化，把至少20%的开发和IT运维周期划拨给非功能性需求，并且不断鼓励进行改进。</p>
<h2 id="团队领导力的寓言"><a href="#团队领导力的寓言" class="headerlink" title="团队领导力的寓言"></a>团队领导力的寓言</h2><p>这是帕特里克·兰西奥尼在《团队领导的五大障碍：关于领导力的寓言》（The Five Dysfunctions of a Team: A Leadership Fable）一书中描述的方法。<br>他认为，团队无法达成目标的一个核心诱因是信任缺失。在他的模型中，五大障碍被描述为：</p>
<ul>
<li>信任缺失——不愿在团队中显示弱点；</li>
<li>惧怕冲突——在充满激情的建设性辩论中寻求和谐的假象；</li>
<li>缺乏诚意——假意与团队的决策达成一致，形成模棱两可的公司氛围；</li>
<li>回避问责——面对员工的失职行为，逃避追责，降低了工作标准；</li>
<li>忽视结果——对个人成就、地位和自我价值的关注超过了对团队成功的关注。</li>
</ul>
<p>考虑到开发部和IT运维部之间，以及IT和“业务部门”之间存在着长期、剧烈的部门斗争，我想我们非常需要兰西奥尼先生的教诲以实现开发运维的理想。<br>通常来说，运用兰西奥尼先生方法论的第一步，是领导人要展示自己的弱点（或者起码要从塑造示弱的行为着手）。在《凤凰计划》中，史蒂夫多年来已将这一实践内化于心，并主导了一场关于个人经历的分享活动。</p>
<h2 id="信息安全问题解决思想"><a href="#信息安全问题解决思想" class="headerlink" title="信息安全问题解决思想"></a>信息安全问题解决思想</h2><p>以不对IT系统做过多无用功就保护公司不受审计困扰，才是最终的胜利。而不是一昧的强制加入新的安全补丁，限制IT系统的功能与产出更多的维护问题。正如QA不需要测试不再需要的功能和不可能发生的性能压力，不要犯“眼界的错误”。</p>
<h2 id="优先项目永远优先"><a href="#优先项目永远优先" class="headerlink" title="优先项目永远优先"></a>优先项目永远优先</h2><p>关乎公司存亡的项目永远放在第一位。必要时可以冻结其他项目进度以提供充足的资源，人力和时间。</p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">果核&肉肉</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">31</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">8</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">15</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">果核&肉肉</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v6.5.0</div>




        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv" title="总访客量">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
    </span>
  

  
    <span class="site-pv" title="总访问量">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
    </span>
  
</div>









        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.5.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.5.0"></script>



  



  










  





  

  

  

  

  

  
  

  

  

  

  

  

  

</body>
</html>
