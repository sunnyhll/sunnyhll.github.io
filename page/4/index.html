<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"sunnyhll.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":true,"version":"8.16.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="微观天下">
<meta property="og:url" content="https://sunnyhll.github.io/page/4/index.html">
<meta property="og:site_name" content="微观天下">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="果核&amp;肉肉">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://sunnyhll.github.io/page/4/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/4/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>微观天下</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<!-- hexo injector head_end start --><link rel="manifest" href="/manifest.json" /><!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">微观天下</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">果核&肉肉</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">58</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://sunnyhll.github.io/2020/12/07/%E6%9E%B6%E6%9E%84/Web/Microservices-via-Spring-Cloud/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="果核&肉肉">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="微观天下">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 微观天下">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/07/%E6%9E%B6%E6%9E%84/Web/Microservices-via-Spring-Cloud/" class="post-title-link" itemprop="url">Microservices via Spring Cloud</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-12-07 10:53:17" itemprop="dateCreated datePublished" datetime="2020-12-07T10:53:17+08:00">2020-12-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-02-08 12:39:10" itemprop="dateModified" datetime="2024-02-08T12:39:10+08:00">2024-02-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%9E%B6%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">架构</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%9E%B6%E6%9E%84/Web/" itemprop="url" rel="index"><span itemprop="name">Web</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>目前各大科技公司都提供了各种云平台服务，对于普通地金融科技公司而言，从传统的内部维护基础架构的日子一去不复返。策略转向了开发面向多平台，多终端的服务开发，其中前端开发倾向于web，后端开发倾向于自包含而且能灵活大量部署的微服务架构。如何从传统的开发风格转变为适应云平台服务的应用开发成为了一个需要攻坚的课题。</p>
<p>采用微服务架构拥有诸多好处，在本文中将不做赘述，可参见微服务架构一文。目前，微服务架构已经从设计逐渐落地，开发者社区逐渐贡献出云生态的组件框架，能够让这一战略目标变为可执行方案。</p>
<h1 id="Spring-Cloud微服务框架"><a href="#Spring-Cloud微服务框架" class="headerlink" title="Spring Cloud微服务框架"></a>Spring Cloud微服务框架</h1><p>Spring家族拥有多个方向的项目，目前最为领先行业的就是Spring Framework, Spring Boot, Spring Cloud三大方向，分别致力于帮助开发者开发系统，简化应用初始搭建，以及实现微服务开发设计。</p>
<p>Spring Cloud提供了非常完整的一套微服务实施方案：</p>
<ul>
<li>服务发现</li>
<li>分布式配置</li>
<li>客户端负载均衡</li>
<li>服务容错保护</li>
<li>API网关</li>
<li>安全</li>
<li>事件驱动</li>
<li>分布式服务跟踪</li>
</ul>
<p>当然，代码构建微服务只是微服务落地的第一步，为了支持灵活大量部署，微服务需要借助容器技术来快速部署到各个云平台服务提供商的虚拟机上，Docker则是容器技术实现的一个典范，我将在另一篇文章中介绍容器技术。</p>
<h1 id="Spring-Cloud常用组件"><a href="#Spring-Cloud常用组件" class="headerlink" title="Spring Cloud常用组件"></a>Spring Cloud常用组件</h1><h2 id="API网关"><a href="#API网关" class="headerlink" title="API网关"></a>API网关</h2><p>Spring Cloud Gateway和Netflix Zuul为所有微服务提供了一个单一入口点。API网关是一个单独的中间件。</p>
<h2 id="Spring-Cloud-Gateway源码分析"><a href="#Spring-Cloud-Gateway源码分析" class="headerlink" title="Spring Cloud Gateway源码分析"></a>Spring Cloud Gateway源码分析</h2><p>处理流程：</p>
<ul>
<li>基于webflux容器&#x2F;Netty通信框架：NIO机制，事件循环监听端口请求</li>
<li>请求的Route Predicate函数式过滤匹配规则<ul>
<li>HTTP请求信息检查例如：Host，Query, Path, Header, Cookie</li>
</ul>
</li>
<li>请求过滤器Filter处理和转发接收<ul>
<li>Pre型在请求转发前执行，可以做鉴权，限流等操作</li>
<li>Post型过滤器可以对返回数据进行增强处理</li>
<li>下游服务可以为注册中心的地址&#x2F;预先配置好的节点IP信息</li>
</ul>
</li>
</ul>
<h3 id="安全——服务验证和授权"><a href="#安全——服务验证和授权" class="headerlink" title="安全——服务验证和授权"></a>安全——服务验证和授权</h3><p>Spring Cloud Securty为微服务提供了一种灵活的用户验证机制，和授权模型。其中验证机制可以基于OAuth2.0标准下的OpenID协议完成，而用户服务授权模型则通过OAuth 2.0的token提供。云服务中的所有服务都应该引入服务验证和授权机制来保护内容服务的安全性。</p>
<p>如果需要更多的security功能，可以考虑引入spring security中的功能。本文将着重介绍基于OAuth2.0的微服务安全架构。</p>
<p>微服务中一般在gateway进行验证授权，而在下游微服务中只需要确认请求是经过认证的即可。关于鉴权的详细文章请见<a href="/2020/11/16/Authentication/">这里</a>.</p>
<h1 id="Spring-Cloud-Netflix"><a href="#Spring-Cloud-Netflix" class="headerlink" title="Spring Cloud Netflix"></a>Spring Cloud Netflix</h1><h2 id="Netflix-Eureka服务注册"><a href="#Netflix-Eureka服务注册" class="headerlink" title="Netflix Eureka服务注册"></a>Netflix Eureka服务注册</h2><p>Eureka是单独的服务组件，保证了A高可用，和P分区容忍性的中间件，与Zookeeper保证的C一致性，P分区容忍性不同，更加适合微服务架构，通过集群保证了高可用的动态服务注册以及心跳感知。Eureka一般和Ribbon放在同一个服务器上，所以在gateway上需要指向lb:&#x2F;&#x2F;abc-service就能保证负载均衡到对应的已注册资源服务中。</p>
<h2 id="Netflix-Ribbon负载均衡"><a href="#Netflix-Ribbon负载均衡" class="headerlink" title="Netflix Ribbon负载均衡"></a>Netflix Ribbon负载均衡</h2><p>Netflix Ribbon 采用拦截器将请求的Url进行负载均衡分发，从而达到内容微服务的负载均衡效果。Ribbon框架并不是单独执行，往往在前端服务中会通过（服务注册中心获取&#x2F;API网关中写死）得到提供服务的IP地址，所以服务调用方引入Ribbon通过一定的均衡策略动态生成最终访问的IP地址。</p>
<ul>
<li><p>全局使用既定的某种负载均衡策略：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> RandomRule <span class="title function_">randomRule</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RandomRule</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过配置方式灵活配置服务提供者的负载均衡策略</p>
</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 负载均衡策略</span></span><br><span class="line"><span class="comment"># service-provider-name 为调用的服务的名称</span></span><br><span class="line"><span class="attr">service-provider-name:</span></span><br><span class="line">  <span class="attr">ribbon:</span></span><br><span class="line">    <span class="attr">NFLoadBalancerRuleClassName:</span> <span class="string">com.netflix.loadbalancer.RandomRule</span></span><br></pre></td></tr></table></figure>
<h3 id="Ribbon负载均衡策略比较"><a href="#Ribbon负载均衡策略比较" class="headerlink" title="Ribbon负载均衡策略比较"></a>Ribbon负载均衡策略比较</h3><table>
<thead>
<tr>
<th align="left">策略名</th>
<th align="left">策略声明</th>
<th align="left">策略描述</th>
<th align="left">实现说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">BestAvailableRule</td>
<td align="left">public class BestAvailableRule extends ClientConfigEnabledRoundRobinRule</td>
<td align="left">选择一个最小的并发请求的server</td>
<td align="left">逐个考察Server：</br> 如果Server被tripped了，则忽略，</br>再选择其中ActiveRequestsCount最小的server</td>
</tr>
<tr>
<td align="left">AvailabilityFilteringRule</td>
<td align="left">public class AvailabilityFilteringRule extends PredicateBasedRule</td>
<td align="left">过滤掉那些因为一直连接失败的被标记为circuit tripped的后端server，并过滤掉那些高并发的的后端server（active connections 超过配置的阈值）</td>
<td align="left">使用一个AvailabilityPredicate来包含过滤server的逻辑, 其实就就是检查status里记录的各个server的运行状态</td>
</tr>
<tr>
<td align="left">WeightedResponseTimeRule</td>
<td align="left">public class WeightedResponseTimeRule extends RoundRobinRule</td>
<td align="left">根据相应时间分配一个weight，相应时间越长，weight越小，被选中的可能性越低。</td>
<td align="left">一个后台线程定期的从status里面读取评价响应时间，为每个server计算一个weight;</br>Weight的计算也比较简单responsetime 减去每个server自己平均的responsetime是server的权重;</br>当刚开始运行，没有形成statas时，使用roudrobin策略选择server。</td>
</tr>
<tr>
<td align="left">RetryRule</td>
<td align="left">public class RetryRule extends AbstractLoadBalancerRule</td>
<td align="left">对选定的负载均衡策略机上重试机制。</td>
<td align="left">在一个配置时间段内当选择server不成功，则一直尝试使用subRule的方式选择一个可用的server</td>
</tr>
<tr>
<td align="left">RoundRobinRule</td>
<td align="left">public class RoundRobinRule extends AbstractLoadBalancerRule</td>
<td align="left">roundRobin方式轮询选择server</td>
<td align="left">轮询index，选择index对应位置的server</td>
</tr>
<tr>
<td align="left">RandomRule</td>
<td align="left">public class RandomRule extends AbstractLoadBalancerRule</td>
<td align="left">随机选择一个server</td>
<td align="left">在index上随机，选择index对应位置的server</td>
</tr>
<tr>
<td align="left">ZoneAvoidanceRule</td>
<td align="left">public class ZoneAvoidanceRule extends PredicateBasedRule</td>
<td align="left">复合判断server所在区域的性能和server的可用性选择server</td>
<td align="left">使用ZoneAvoidancePredicate和AvailabilityPredicate来判断是否选择某个server，前一个判断判定一个zone的运行性能是否可用，剔除不可用的zone（的所有server），AvailabilityPredicate用于过滤掉连接数过多的Server。</td>
</tr>
</tbody></table>
<h2 id="Netflix-Feign动态代理RPC调用"><a href="#Netflix-Feign动态代理RPC调用" class="headerlink" title="Netflix Feign动态代理RPC调用"></a>Netflix Feign动态代理RPC调用</h2><p>RPC远程调用的一种经典实现，为了让服务调用的代码跟普通方法调用一样方便，可以使用Netflix Feign动态代理被调用的服务接口，并且在底层实际使用HTTPClient进行调用。</p>
<h2 id="Netflix-Hystrix服务弹性保证"><a href="#Netflix-Hystrix服务弹性保证" class="headerlink" title="Netflix Hystrix服务弹性保证"></a>Netflix Hystrix服务弹性保证</h2><p>对于微服务的调用失败需要进行动态的感知，当大量请求失败后需要主动断路避免延迟。而且需要后备方式记录或者进行服务降级。在.NETcore 中对等的实现是steeltoe.</p>
<h3 id="Hystrix熔断机制源码分析"><a href="#Hystrix熔断机制源码分析" class="headerlink" title="Hystrix熔断机制源码分析"></a>Hystrix熔断机制源码分析</h3><p>基于注解@HystrixCommand和AOP实现，在方法执行前拦截的动态代理执行。对于有弹性机制需要的节点，需要引入Hystrix进行失败回退方法编写。</p>
<h4 id="Hystrix手写代码示例"><a href="#Hystrix手写代码示例" class="headerlink" title="Hystrix手写代码示例"></a>Hystrix手写代码示例</h4><ol>
<li>自定义注解 @WuzzHystrixCommand</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> WuzzHystrixCommand &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认超时时间</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">timeout</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 回退方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">fallback</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>编写切面类，实现简易的逻辑处理</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WuzzHystrixCommandAspect</span> &#123;</span><br><span class="line">    <span class="comment">//线程池的处理，基于这个线程池的处理统计可以达到 THREAD 资源限流</span></span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注解切点</span></span><br><span class="line">    <span class="meta">@Pointcut(value = &quot;@annotation(com.wuzz.demo.custom.hystrix.WuzzHystrixCommand)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pointCut</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//环绕通知</span></span><br><span class="line">    <span class="meta">@Around(value = &quot;pointCut()&amp;&amp;@annotation(hystrixCommand)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">doPointCut</span><span class="params">(ProceedingJoinPoint joinPoint, WuzzHystrixCommand hystrixCommand)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException, NoSuchMethodException, InvocationTargetException, IllegalAccessException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">timeout</span> <span class="operator">=</span> hystrixCommand.timeout();</span><br><span class="line">        <span class="comment">//前置的判断逻辑</span></span><br><span class="line">        <span class="type">Future</span> <span class="variable">future</span> <span class="operator">=</span> executorService.submit(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> joinPoint.proceed(); <span class="comment">//执行目标方法</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">                throwable.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        Object result;</span><br><span class="line">        <span class="keyword">try</span> &#123;<span class="comment">// 使用 future 来实现超时</span></span><br><span class="line">            result = future.get(timeout, TimeUnit.MILLISECONDS);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException | TimeoutException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            future.cancel(<span class="literal">true</span>);</span><br><span class="line">            <span class="comment">// ？</span></span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isBlank(hystrixCommand.fallback())) &#123;</span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//调用fallback</span></span><br><span class="line">            result = invokeFallback(joinPoint, hystrixCommand.fallback());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object <span class="title function_">invokeFallback</span><span class="params">(ProceedingJoinPoint joinPoint, String fallback)</span> <span class="keyword">throws</span> NoSuchMethodException, InvocationTargetException, IllegalAccessException &#123;</span><br><span class="line">        <span class="comment">//获取被代理的方法的参数和Method</span></span><br><span class="line">        <span class="type">MethodSignature</span> <span class="variable">signature</span> <span class="operator">=</span> (MethodSignature) joinPoint.getSignature();</span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> signature.getMethod();</span><br><span class="line">        Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</span><br><span class="line">        <span class="comment">//得到fallback方法</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Method</span> <span class="variable">fallbackMethod</span> <span class="operator">=</span> joinPoint.getTarget().getClass().getMethod(fallback, parameterTypes);</span><br><span class="line">            fallbackMethod.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            <span class="comment">//完成反射调用</span></span><br><span class="line">            <span class="keyword">return</span> fallbackMethod.invoke(joinPoint.getTarget(), joinPoint.getArgs());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>编写测试，调用：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WuzzHystrixCommand(fallback = &quot;customFallback&quot;, timeout = 3000)</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/custom/hystrix/test&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;id&quot;</span>, <span class="number">666</span>);</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(REST_URL_PREFIX + <span class="string">&quot;/hello?id=&#123;id&#125;&quot;</span>, String.class, map);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">customFallback</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;custom 请求被降级&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正常得调用是没有问题的，这个时候我们把服务提供方的服务接口里  sleep 3秒来模仿调用超时，在访问接口就会得到降级服务后的返回。</p>
<h1 id="Spring-Cloud-Alibaba"><a href="#Spring-Cloud-Alibaba" class="headerlink" title="Spring Cloud Alibaba"></a>Spring Cloud Alibaba</h1><h2 id="Nacos-配置中心，负载均衡，服务注册"><a href="#Nacos-配置中心，负载均衡，服务注册" class="headerlink" title="Nacos 配置中心，负载均衡，服务注册"></a>Nacos 配置中心，负载均衡，服务注册</h2><h3 id="Nacos服务注册源码分析"><a href="#Nacos服务注册源码分析" class="headerlink" title="Nacos服务注册源码分析"></a>Nacos服务注册源码分析</h3><ul>
<li>Nacos服务注册Naming Service源码分析<br>  * 接受Nacos客户端的API调用注册生成Instance实例<br>      * 将Instance放入serviceMap中ConcurrentHashMap集合中<br>      * consitencyService.listen实现数据定期检查<br>  * 通过Namespace对已注册服务的隔离<br>  * 定时检查HeartBeat对已注册Instance实例进行检查，更新实例状态<br>  * 对出现异常的服务进行基于UDP协议推送更新于PushService<ul>
<li>Nacos服务方客户端注册源码分析<ul>
<li>Spring Boot自动启动NacosAutoServiceRegistration进行注册调用</li>
<li>监听ApplicationStartedEvent事件调用NacosServiceRegistry.register方法</li>
<li>namingService.regiterInstance中创建BeanInfo，定时发送心跳包：executorService.schedule(task, period, unit)</li>
</ul>
</li>
<li>Nacos前端客户端服务消费者源码分析<ul>
<li>客户端发起订阅请求会定期发起UpdateTask来获得最新地址</li>
<li>客户端也会提供本地EventListener回调实例处理出现异常的服务</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Sentinel-弹性限流-x2F-熔断模式"><a href="#Sentinel-弹性限流-x2F-熔断模式" class="headerlink" title="Sentinel 弹性限流&#x2F;熔断模式"></a>Sentinel 弹性限流&#x2F;熔断模式</h2><h3 id="Sentinel和Hystrix对比"><a href="#Sentinel和Hystrix对比" class="headerlink" title="Sentinel和Hystrix对比"></a>Sentinel和Hystrix对比</h3><p><img src="/2020/12/07/%E6%9E%B6%E6%9E%84/Web/Microservices-via-Spring-Cloud/SentinelHystrix.png" alt="SH"></p>
<h2 id="Seata-分布式事务"><a href="#Seata-分布式事务" class="headerlink" title="Seata 分布式事务"></a>Seata 分布式事务</h2><p>分布式事务解决了分布式系统中存储数据（数据库&#x2F;缓存)一致性问题。</p>
<h3 id="分布式事务解决理论"><a href="#分布式事务解决理论" class="headerlink" title="分布式事务解决理论"></a>分布式事务解决理论</h3><h4 id="X-x2F-Open分布式事务模型"><a href="#X-x2F-Open分布式事务模型" class="headerlink" title="X&#x2F;Open分布式事务模型"></a>X&#x2F;Open分布式事务模型</h4><ul>
<li>AP: Application 应用程序</li>
<li>RM： Resource Manager 资源管理者，数据库</li>
<li>TM： Transaction Manager事务管理器&#x2F;协调者</li>
</ul>
<h4 id="两段提交协议"><a href="#两段提交协议" class="headerlink" title="两段提交协议"></a>两段提交协议</h4><ul>
<li>准备阶段： TM同之RM准备事务，并告知准备结果</li>
<li>提交&#x2F;回滚阶段：如果所有RM返回成功则执行提交完成指令，反之执行回滚指令。</li>
</ul>
<p>存在问题：</p>
<ol>
<li>同步阻塞数据库</li>
<li>容易失败，一个节点失败就回滚</li>
<li>TM单点故障问题，造成RM锁死。</li>
<li>脑裂问题，二阶段部分提交问题。</li>
</ol>
<h4 id="三段提交协议"><a href="#三段提交协议" class="headerlink" title="三段提交协议"></a>三段提交协议</h4><ul>
<li>CanCommit询问阶段: TM询问是否可以参与事务&#x2F;超时。</li>
<li>PreCommit准备阶段：如果所有RM确认可以，则发起事务，并返回结果&#x2F;超时。</li>
<li>DoCommit提交&#x2F;回滚阶段：如果均成功提交则发起提交&#x2F;回滚指令。</li>
</ul>
<p>改进部分:</p>
<ul>
<li>超时即失败机制，避免两阶段提交锁死等待问题。</li>
<li>提前确认节点状态</li>
</ul>
<h3 id="分布式事务解决方案"><a href="#分布式事务解决方案" class="headerlink" title="分布式事务解决方案"></a>分布式事务解决方案</h3><ul>
<li>基于MQ的消息中间件实现TCC (Try-Confirm-Cancel)模型补偿型方案(幂等性实现，最大努力通知机制)</li>
<li>基于Seata模式的分布式事务框架(AT, TCC, Sega 和XA事务模式)</li>
</ul>
<h3 id="Seata源码分析"><a href="#Seata源码分析" class="headerlink" title="Seata源码分析"></a>Seata源码分析</h3><h2 id="Spring-Cloud-Stream-发布-x2F-订阅流处理"><a href="#Spring-Cloud-Stream-发布-x2F-订阅流处理" class="headerlink" title="Spring Cloud Stream 发布&#x2F;订阅流处理"></a>Spring Cloud Stream 发布&#x2F;订阅流处理</h2><p>Spring Cloud Stream支持消息中间件通信，因而可以支持多种高并发消息发布&#x2F;消费场景：</p>
<p>Spring Cloud Stream包含如下四个核心部分：</p>
<ul>
<li>Spring Messaging<ul>
<li>Message, 消息对象，包含消息头和消息体</li>
<li>MessageChannel, 消息通道接口，用于接收消息，提供send方法将消息发送至消息通道</li>
<li>MessageHandler, 消息处理器接口，用于处理消息逻辑</li>
</ul>
</li>
<li>Spring Integration<ul>
<li>MessageDispatcher：消息分发接口，用于分发消息和添加删除消息处理器</li>
<li>MessageRouter: 消息路由接口，定义默认的输出消息通道</li>
<li>Filter：消息的过滤注解，用于配置消息过滤表达式</li>
<li>Aggregator: 消息的聚合注解，用于将多个消息聚合成一条</li>
<li>Splitter: 消息的分割，用于将一条消息拆分成多条</li>
</ul>
</li>
<li>Binders 目标绑定器，负责于外部消息中间件系统集成的组件<ul>
<li>doBindProducer: 为中间件绑定发送消息模块，让中间件能从MessageChannel接受到符合中间件格式的消息</li>
<li>doBindConsumer：为中间件绑定接受消息模块，让中间件能够发送符合Spring Message标准的消息到MessageChannel</li>
</ul>
</li>
<li>Bindings 绑定生成的桥梁，支持Kafka，RabbitMQ中间件</li>
</ul>
<h3 id="RocketMQ-分布式消息通信源码分析"><a href="#RocketMQ-分布式消息通信源码分析" class="headerlink" title="RocketMQ 分布式消息通信源码分析"></a>RocketMQ 分布式消息通信源码分析</h3><p>消息发送流程源码分析：</p>
<p><img src="/2020/12/07/%E6%9E%B6%E6%9E%84/Web/Microservices-via-Spring-Cloud/SpringCloudStream.jpg" alt="MQProducer"></p>
<p>除了负责和Spring Cloud服务器中的Messaging集成之外，RocketMQ Binder还负责和MQ中间件集群通信，源码分发布&#x2F;订阅两部分，分别如下:</p>
<ul>
<li>使用RocketMQTemplate真正发送MQ消息到中间件</li>
<li>同时创建ConsumerEndpoint和input MessageChannel监听MQ订阅消息，并且负责转发给下游</li>
<li>消息的消费分为顺序消费和并发消费，分别由DefaultMessageListenerOrderly,DefaultMessageListenerConcurrently实现，通过binders的配置设定。</li>
</ul>
<p>消息订阅流程源码分析：</p>
<p><img src="/2020/12/07/%E6%9E%B6%E6%9E%84/Web/Microservices-via-Spring-Cloud/SpringCloudStreamConsume.jpg" alt="MQProducer"></p>
<p>其中，服务器对消息的接收，是基于注解方式注入到响应的业务方法中的。这就是在业务代码中，不需要为接收信息创建MessageChannel，却能拿到信息体中的反序列化后信息。</p>
<h3 id="RocketMQ-消息使用场景与实现"><a href="#RocketMQ-消息使用场景与实现" class="headerlink" title="RocketMQ 消息使用场景与实现"></a>RocketMQ 消息使用场景与实现</h3><h4 id="RocketMQ-顺序消息实现"><a href="#RocketMQ-顺序消息实现" class="headerlink" title="RocketMQ 顺序消息实现"></a>RocketMQ 顺序消息实现</h4><p>顺序发送消费场景：订单创建、支付、退款流程处理，数据库BinLog信息消费等等。</p>
<ul>
<li>顺序发送需要将消息发送到同一队列即可，通过基于消息ID的哈希分队选择器即可完成。</li>
<li>顺序消费需要binders中配置好ConsumerMQ的集群消费模式，即每条消息只会被ConsumerGroup中的一个Consumer消费。通过Consumer拿Broker独占锁实现。消费成功后会提交并更新消费进程，避免重复消费。代码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.processQueue.getLockConsume().lock();</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">this</span>.processQueue.isDropped())&#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  status = messageListener.consumeMessage(Collections.unmodifieableList(msgs), context);</span><br><span class="line">&#125;<span class="keyword">catch</span>(Throwable e)&#123;</span><br><span class="line">  hasException - <span class="literal">true</span>;</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.processQueue.getLockConsume().unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="RocketMQ-普通消息发送实现"><a href="#RocketMQ-普通消息发送实现" class="headerlink" title="RocketMQ 普通消息发送实现"></a>RocketMQ 普通消息发送实现</h4><p>普通消息在队列选择可以由两种机制:</p>
<ul>
<li>轮询机制：轮流使用每个队列发送消息</li>
<li>故障规避机制：</li>
</ul>
<h4 id="RocketMQ-消息并发消费实现"><a href="#RocketMQ-消息并发消费实现" class="headerlink" title="RocketMQ 消息并发消费实现"></a>RocketMQ 消息并发消费实现</h4><p>并发消费场景下，消息队列允许Consumer的线程消费池可以向同一个队列消费信息，并且每个消费线程消费信息会有自己的进度信息。</p>
<h4 id="RocketMQ-分布式事务消息实现"><a href="#RocketMQ-分布式事务消息实现" class="headerlink" title="RocketMQ 分布式事务消息实现"></a>RocketMQ 分布式事务消息实现</h4><p>为分布式事务处理提供了通信基础。</p>
<p><img src="/2020/12/07/%E6%9E%B6%E6%9E%84/Web/Microservices-via-Spring-Cloud/RocketMQ.png" alt="RMQ"></p>
<p>Rocket发送事务消息：</p>
<p>Rocket发送事务消息是二次提交的，第一次发送prepare提交到服务器时消息主题会替换为RMQ_SYS_TRANS_HALF_TOPIC。等到本地事务执行完毕以后才进行二次提交，这时会发送给原本消息的topic。</p>
<ol>
<li><p>由producer发送prepare（半消息）给MQ的broker。MQ会把消息记录到本地，然后回复prepare消息状态给producer。</p>
</li>
<li><p>prepare消息发送以后获取发送状态，如果是成功则执行本地业务（本地事务），根据本地事务执行结果手动返回相应状态（RocketMQLocalTransactionState.COMMIT、RocketMQLocalTransactionState.ROLLBACK等）给MQ。</p>
</li>
<li><p>如果是COMMIT则说明本地事务执行成功，prepare为可提交状态，MQ收到COMMIT消息就会发送给consumer，然后consumer执行本地业务。如果是ROLLBACK则会删除prepare消息。</p>
</li>
<li><p>如果MQ一直没收到返回状态则会启动定时任务检查本地事务状态</p>
</li>
<li><p>消费者、生产者的事务各由开发者自己保证。MQ的事务是由MQ保证，这里会根据使用者配置的参数来决定如何执行。</p>
</li>
</ol>
<h4 id="RocketMQ消费模式"><a href="#RocketMQ消费模式" class="headerlink" title="RocketMQ消费模式"></a>RocketMQ消费模式</h4><ul>
<li>at-most-once最多一次</li>
<li>at-least-once最少一次，RocketMQ通过消费者ACK机制支持至少一次</li>
<li>exactly-only-once仅此一次</li>
</ul>
<h3 id="RocketMQ实现原理"><a href="#RocketMQ实现原理" class="headerlink" title="RocketMQ实现原理"></a>RocketMQ实现原理</h3><h4 id="高性能设计"><a href="#高性能设计" class="headerlink" title="高性能设计"></a>高性能设计</h4><h4 id="高可用设计"><a href="#高可用设计" class="headerlink" title="高可用设计"></a>高可用设计</h4><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://sunnyhll.github.io/2020/11/07/Runbooks/Office-365-Addin-ESC-POC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="果核&肉肉">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="微观天下">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 微观天下">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/11/07/Runbooks/Office-365-Addin-ESC-POC/" class="post-title-link" itemprop="url">Office 365 Addin ESC POC</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-11-07 09:45:41" itemprop="dateCreated datePublished" datetime="2020-11-07T09:45:41+08:00">2020-11-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-02-08 12:35:05" itemprop="dateModified" datetime="2024-02-08T12:35:05+08:00">2024-02-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Runbooks/" itemprop="url" rel="index"><span itemprop="name">Runbooks</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="project-bootstrap"><a href="#project-bootstrap" class="headerlink" title="project bootstrap"></a>project bootstrap</h1><p> Demo项目是通过VS2019自带的Addin模板生成。默认debug模式部署在一个o365 dev tenant上。目前已有Github demo项目也可以直接下载，相关<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/office/dev/add-ins/outlook/outlook-on-send-addins?tabs=windows#install-outlook-add-ins-that-use-on-send">链接</a>。</p>
<h2 id="Demo-项目原型简述"><a href="#Demo-项目原型简述" class="headerlink" title="Demo 项目原型简述"></a>Demo 项目原型简述</h2><p>引入demo项目是一个查看邮件各种属性的ESCPOC项目，在读取一封邮件时，可以点击ESCPOC按钮查看邮件的属性。在启动debug并上传manifest后，点击Ribbon上的MyAddinGroup按钮，显示如下图所示：</p>
<p> <img src="/Office-365-Addin-ESC-POC%5CESCPOC.PNG" alt="ESCPOCDemo"></p>
<p>我们的目标POC项目是一个非常简单的发送弹框程序，需要订阅每一封邮件的发送事件itemsend并且根据Web API调用结果显示一个web UI.</p>
<h3 id="ESCPOC-xml-修改剖析"><a href="#ESCPOC-xml-修改剖析" class="headerlink" title="ESCPOC.xml 修改剖析"></a>ESCPOC.xml 修改剖析</h3><p>Manifest文件是O365插件加载的关键配置，需要完全符合schema定义的规则才能正确显式UI以及相应的回调API。</p>
<ol>
<li>Validation<br>Manifest 文件具有很强的格式要求，需要运用微软提供的工具对自己的manifest文件进行语法检查。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#install latest version</span></span><br><span class="line">npm install -g office-addin-manifest</span><br><span class="line">office-addin-manifest validate PATH_MANIFEST_FILE</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>创建ItemSend相关配置<br>目前微软已经有开源的示例代码于<a target="_blank" rel="noopener" href="https://github.com/OfficeDev/outlook-add-in-command-demo%EF%BC%8C%E5%8F%AF%E4%BB%A5%E4%BD%9C%E4%B8%BA%E5%8F%82%E8%80%83%E3%80%82">https://github.com/OfficeDev/outlook-add-in-command-demo，可以作为参考。</a><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Event</span> <span class="attr">Type</span>=<span class="string">&quot;ItemSend&quot;</span> <span class="attr">FunctionExecution</span>=<span class="string">&quot;synchronous&quot;</span> <span class="attr">FunctionName</span>=<span class="string">&quot;itemSendHandler&quot;</span> /&gt;</span> </span><br></pre></td></tr></table></figure></li>
</ol>
<p>注意配置上下文需要在VersionOverrides 1.1框架下。</p>
<h2 id="O365-环境准备"><a href="#O365-环境准备" class="headerlink" title="O365 环境准备"></a>O365 环境准备</h2><p>对于跨平台的O365 Addin，一个合法的O365账号是需要的，而且需要拥有上传插件的权限。在用用MSDN订阅的情况下，可以创建合适的E3等级Office Tenant。例如本文则使用<a href="mailto:&#104;&#117;&#97;&#x6e;&#103;&#x73;&#117;&#x6e;&#x40;&#115;&#x75;&#x6e;&#110;&#121;&#104;&#108;&#108;&#x2e;&#111;&#x6e;&#x6d;&#105;&#x63;&#114;&#x6f;&#115;&#111;&#102;&#x74;&#46;&#x63;&#111;&#109;">&#104;&#117;&#97;&#x6e;&#103;&#x73;&#117;&#x6e;&#x40;&#115;&#x75;&#x6e;&#110;&#121;&#104;&#108;&#108;&#x2e;&#111;&#x6e;&#x6d;&#105;&#x63;&#114;&#x6f;&#115;&#111;&#102;&#x74;&#46;&#x63;&#111;&#109;</a>作为测试账号，密码为系统密码。</p>
<p>Web Addin查看可以点击Outlook桌面客户端的Manage Addin按钮，也可以在<a target="_blank" rel="noopener" href="https://outlook.office365.com/owa/?path=/options/manageapps">https://outlook.office365.com/owa/?path=/options/manageapps</a> 链接中看到。可以看到即使安装了很多插件，这些插件却不是实时安装在本地Outlook桌面客户端上的， 而是在需要访问的时候才进行加载执行的。</p>
<h3 id="开启ItemSend事件监听"><a href="#开启ItemSend事件监听" class="headerlink" title="开启ItemSend事件监听"></a>开启ItemSend事件监听</h3><p>相关<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/powershell/exchange/exchange-online/connect-to-exchange-online-powershell/connect-to-exchange-online-powershell?view=exchange-ps">链接</a>.</p>
<h3 id="“My-Custom-Roles”权限"><a href="#“My-Custom-Roles”权限" class="headerlink" title="“My Custom Roles”权限"></a>“My Custom Roles”权限</h3><p>对于个人O365账号，这里不需要进行权限获取，Microsoft Tenant默认每个客户的SideLoad权限开启。</p>
<h3 id="Web-Addin部署"><a href="#Web-Addin部署" class="headerlink" title="Web Addin部署"></a>Web Addin部署</h3><p>对于Outlook Web Addin, 主要分成两部分部署：</p>
<ul>
<li>Manifest配置文件部署，在Exchange Mailbox 上注册插件</li>
<li>插件服务部署，必须采用https协议，插件服务前后端本身需要在同一域名下。<br>部署完成即可进行测试。</li>
</ul>
<h2 id="Excel-Addin原型"><a href="#Excel-Addin原型" class="headerlink" title="Excel Addin原型"></a>Excel Addin原型</h2><p>Excel Addin属于Office Addin一部分，example link： <a target="_blank" rel="noopener" href="https://github.com/OfficeDev/Office-Add-in-samples/">https://github.com/OfficeDev/Office-Add-in-samples/</a></p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://sunnyhll.github.io/2020/10/30/Java/Effective-Java/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="果核&肉肉">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="微观天下">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 微观天下">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/10/30/Java/Effective-Java/" class="post-title-link" itemprop="url">Effective Java</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2020-10-30 15:11:53 / 修改时间：15:11:54" itemprop="dateCreated datePublished" datetime="2020-10-30T15:11:53+08:00">2020-10-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>本文是Effetive Java一书提出地90条Java代码规范建议，具体内容需要查看相应地书籍内容，本文仅作为索引复习回忆。</p>
<h1 id="创建与销毁对象"><a href="#创建与销毁对象" class="headerlink" title="创建与销毁对象"></a>创建与销毁对象</h1><ol>
<li><p>用静态工厂方法代替构造器</p>
</li>
<li><p>遇到多个构造器参数时要考虑使用构建器(builder)</p>
</li>
<li><p>用私有构造器或者枚举类型强化Singleton属性</p>
</li>
<li><p>通过私有构造器强化不可实例化的能力</p>
</li>
<li><p>优先考虑依赖注入来引用资源</p>
</li>
<li><p>避免创建不必要的对象</p>
</li>
<li><p>消除过期的对象引用</p>
</li>
<li><p>避免使用中介方法和清除方法</p>
</li>
<li><p>try-with-resources优先于try-finally</p>
</li>
</ol>
<h1 id="对于所有对象都通用的方法"><a href="#对于所有对象都通用的方法" class="headerlink" title="对于所有对象都通用的方法"></a>对于所有对象都通用的方法</h1><ol start="10">
<li><p>覆盖Equals时请遵守通用约定</p>
</li>
<li><p>覆盖equals时总要覆盖hashCode</p>
</li>
<li><p>始终要覆盖toString</p>
</li>
<li><p>谨慎的覆盖clone</p>
</li>
<li><p>考虑实现Comparable接口</p>
</li>
</ol>
<h1 id="类和接口"><a href="#类和接口" class="headerlink" title="类和接口"></a>类和接口</h1><ol start="15">
<li><p>使用类和成员的可访问性最小化</p>
</li>
<li><p>要在公有类而非公有域中使用访问方法</p>
</li>
<li><p>使可变性最小化</p>
</li>
<li><p>复合优先于集成</p>
</li>
<li><p>要么设计继承并提供文档说明，要么继承</p>
</li>
<li><p>接口优于抽象类</p>
</li>
<li><p>为后代设计接口</p>
</li>
<li><p>接口只用于定义类型</p>
</li>
<li><p>类层次优于标签类</p>
</li>
<li><p>静态成员类由于非静态成员类</p>
</li>
<li><p>限制源文件为单个顶级类</p>
</li>
</ol>
<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><ol start="26">
<li><p>请不要使用原生态类型</p>
</li>
<li><p>消除非受检的警告</p>
</li>
<li><p>列表由于数组</p>
</li>
<li><p>优先考虑泛型</p>
</li>
<li><p>优先考虑泛型方法</p>
</li>
<li><p>利用有限限制通配符来提升API的灵活性</p>
</li>
<li><p>谨慎并用泛型和可变参数</p>
</li>
<li><p>优先考虑类型安全的异构容器</p>
</li>
</ol>
<h1 id="枚举和注解"><a href="#枚举和注解" class="headerlink" title="枚举和注解"></a>枚举和注解</h1><ol start="34">
<li><p>用enum代替int常量</p>
</li>
<li><p>用实例域代替序数</p>
</li>
<li><p>用EnumSet代替位域</p>
</li>
<li><p>用EnumMap代替序数索引</p>
</li>
<li><p>用接口模拟可扩展的枚举</p>
</li>
<li><p>注解优先于明明模式</p>
</li>
<li><p>坚持使用Override注解</p>
</li>
<li><p>用标记接口定义类型</p>
</li>
</ol>
<h1 id="Lamda和stream"><a href="#Lamda和stream" class="headerlink" title="Lamda和stream"></a>Lamda和stream</h1><ol start="42">
<li><p>Lamda优先于匿名类</p>
</li>
<li><p>方法引用优先于Lamda</p>
</li>
<li><p>坚持使用标准的函数接口</p>
</li>
<li><p>谨慎使用Stream</p>
</li>
<li><p>优先选择Stream中无副作用的函数</p>
</li>
<li><p>Stream要优先用Collection作为返回类型</p>
</li>
<li><p>谨慎使用Stream并行</p>
</li>
</ol>
<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><ol start="49">
<li><p>检查参数的有效性</p>
</li>
<li><p>必要时进行保护性拷贝</p>
</li>
<li><p>谨慎设计方法签名</p>
</li>
<li><p>慎用重载</p>
</li>
<li><p>慎用可变参数</p>
</li>
<li><p>返回零长度的数组或者集合，而不是null</p>
</li>
<li><p>谨慎返回optional</p>
</li>
<li><p>为所有导出的API元素编写文档注释</p>
</li>
</ol>
<h1 id="通用编程"><a href="#通用编程" class="headerlink" title="通用编程"></a>通用编程</h1><ol start="57">
<li><p>将局部变量的作用域最小化</p>
</li>
<li><p>for-each循环优先传统的for循环</p>
</li>
<li><p>了解和使用类库</p>
</li>
<li><p>如果需要精确的答案，请避免使用float和double</p>
</li>
<li><p>基本类型优先于装箱基本类型</p>
</li>
<li><p>如果其他类型更适合，则尽量避免使用字符串</p>
</li>
<li><p>了解字符串连接的性能</p>
</li>
<li><p>通过接口引用对象</p>
</li>
<li><p>接口优先于反射机制</p>
</li>
<li><p>谨慎地使用本地方法</p>
</li>
<li><p>谨慎地进行优化</p>
</li>
<li><p>遵守普遍接受的命名惯例</p>
</li>
</ol>
<h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><ol start="69">
<li><p>只针对异常的情况才使用异常</p>
</li>
<li><p>对可恢复的情况使用受检异常，对编程错误使用运行时异常</p>
</li>
<li><p>避免不必要地使用受检异常</p>
</li>
<li><p>优先使用标准的异常</p>
</li>
<li><p>抛出与抽象对应的异常</p>
</li>
<li><p>每个方法抛出的所有异常都要建立文档</p>
</li>
<li><p>在细节消息中包含失败捕获信息</p>
</li>
<li><p>努力使失败保持原子性</p>
</li>
<li><p>不要忽略异常</p>
</li>
</ol>
<h1 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h1><ol start="78">
<li><p>同步访问共享的可变数据</p>
</li>
<li><p>避免过度同步</p>
</li>
<li><p>executor，task和stream优先于线程</p>
</li>
<li><p>并发工具优先于wait和notify</p>
</li>
<li><p>线程安全性的文档化</p>
</li>
<li><p>慎用延迟初始化</p>
</li>
<li><p>不要依赖于线程调度器</p>
</li>
</ol>
<h1 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h1><ol start="85">
<li><p>其他方法优先于Java序列化</p>
</li>
<li><p>谨慎地实现Serializable接口</p>
</li>
<li><p>考虑使用自定义地序列化形式</p>
</li>
<li><p>保护性地编写readOjbect方法</p>
</li>
<li><p>对于实例控制，枚举类型优先于readResolve</p>
</li>
<li><p>考虑用序列化代理代替序列化实例</p>
</li>
</ol>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://sunnyhll.github.io/2020/02/22/%E6%9E%B6%E6%9E%84/Web/Microservice-Architecture/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="果核&肉肉">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="微观天下">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 微观天下">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/02/22/%E6%9E%B6%E6%9E%84/Web/Microservice-Architecture/" class="post-title-link" itemprop="url">Microservice Architecture</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-02-22 12:16:13" itemprop="dateCreated datePublished" datetime="2020-02-22T12:16:13+08:00">2020-02-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-02-08 12:39:19" itemprop="dateModified" datetime="2024-02-08T12:39:19+08:00">2024-02-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%9E%B6%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">架构</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%9E%B6%E6%9E%84/Web/" itemprop="url" rel="index"><span itemprop="name">Web</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Why-Microservice"><a href="#Why-Microservice" class="headerlink" title="Why Microservice"></a>Why Microservice</h1><ul>
<li>Heterogenious technical stack：<br>支持多重技术栈，由于HTTP协议被多种编程语言支持，微服务可以用多种语言实现。</li>
<li>Robustness：整个App mesh网络不会因为单一的微服务的奔溃而停止工作。</li>
<li>Extensions：可以针对单一微服务进行扩展。</li>
<li>Simple deployment：微服务可以进行独立部署，不需要因为单一服务升级而多次部署。</li>
<li>Efficiency：微服务小团队开发高效敏捷。</li>
<li>More client support：多种前端客户端支持，可以重复利用同一个微服务后端网络。</li>
<li>Migration：基于单一微服务迁移的整体升级，阻碍更小。</li>
</ul>
<h1 id="What-is-Microservice"><a href="#What-is-Microservice" class="headerlink" title="What is Microservice"></a>What is Microservice</h1><p>微服务就是一些协同工作的小而自治的服务。</p>
<h1 id="How-to-architect-Microservices"><a href="#How-to-architect-Microservices" class="headerlink" title="How to architect Microservices"></a>How to architect Microservices</h1><h2 id="微服务特点"><a href="#微服务特点" class="headerlink" title="微服务特点"></a>微服务特点</h2><ul>
<li><p>Loose coupling松耦合</p>
</li>
<li><p>High Cohesion高内聚</p>
</li>
</ul>
<h2 id="上下文边界确定"><a href="#上下文边界确定" class="headerlink" title="上下文边界确定"></a>上下文边界确定</h2><p>业务或者职能的界限，往往也可以作为微服务架构中的服务边界。不同的业务只能之间的内部细节并不需要相互知晓。同一个事件，在不同的业务职能会有不同的体现，但是在内部细节上却没有相互交叉。</p>
<h2 id="共享和隐藏模型设计"><a href="#共享和隐藏模型设计" class="headerlink" title="共享和隐藏模型设计"></a>共享和隐藏模型设计</h2><p>限界上下文的确立，能够帮助确立共享模块，对于处于两个上下文边界上需要共同的消息，可以确立一个共享模块，专门进行信息共享。同时，对于上下文内部的逻辑，也能进行对应的逻辑模块设计，从而完成对于整个上下文的设计。</p>
<h2 id="切勿过早划分"><a href="#切勿过早划分" class="headerlink" title="切勿过早划分"></a>切勿过早划分</h2><p>对于一些过早划分的业务产品，警惕由于后期需求用例改变造成多个上下文之间的重叠。比较推荐的是先进行单体设计，不进行划分，在服务稳定之后再进行划分设计迁移，基于以有代码进行划分，比从头开始构建微服务简单得多。</p>
<h2 id="逐步划分上下文"><a href="#逐步划分上下文" class="headerlink" title="逐步划分上下文"></a>逐步划分上下文</h2><p>不断对上下文的界限进行迭代，从复杂的共享模型中慢慢抽出简单的共享模型，将嵌套的模块逐步上升到顶层模型，对其中某些紧密关联模型进行共享。当然，模型共享的粒度取决于代码是分开维护还是集中维护，如果是集中维护也未尝不可进行嵌套模型共享。</p>
<h1 id="微服务的集成"><a href="#微服务的集成" class="headerlink" title="微服务的集成"></a>微服务的集成</h1><p>微服务之间的通信机制，可以成为微服务的集成。微服务间的API相互调用设计需要注意一下几个方面：</p>
<ul>
<li><p>为用户创建接口</p>
<p>  用户上下文会触发一定特定的流程。</p>
</li>
<li><p>共享数据库</p>
<p>  数据库是多个微服务共享的，因为每个微服务都可能对同一个数据库进行修改。</p>
</li>
<li><p>同步与异步通信模式</p>
<p>  两种不同的通信模式中，同步模式会阻塞线程，而异步模式是基于事件响应请求的，能提降低耦合性，提高吞吐量。</p>
</li>
<li><p>编排与协同</p>
<p>  编排和协同是两种管理流程的架构风格。（同步）编排是通过一个中心执行者将每一步的步骤执行，知道获取最终的结果。（异步)协同则是以事件为机制进行执行，执行单元会订阅事件，API调用会触发一个事件，事件订阅者则会自动执行响应的流程。后者会需要监控服务，监控结果要映射到流程中，troubleshooting难度增加，这是一个难题。ATOM是一个符合REST规范的协议可以通过它提供资源feed的发布服务，客户端可以消费该信息。</p>
</li>
<li><p>RPC与REST</p>
<p>  远程调用允许进行本地调用，事实上是由某个远程服务器产生。RPC会有一定的技术耦合要求。protocol buffers, Thrift是比较推荐的RPC框架。REST则是RPC的一个替代方案。通过URI对客户端与服务器进行了松耦合。</p>
</li>
<li><p>Json与XML</p>
<p>  JSON与XML都是一种有效的数据序列化格式，前者更加流行XML对超媒体控制更加好。</p>
</li>
<li><p>API重定向</p>
<p>  API的重定向常常发生在多个API版本共存的时候，当老版本的API准备deco时，需要绞杀者模式将旧的API拦截，选择是否替换成新版本的实现。当旧版本的访问完全消失时，再删除旧的API。</p>
</li>
</ul>
<h1 id="拆分成微服务"><a href="#拆分成微服务" class="headerlink" title="拆分成微服务"></a>拆分成微服务</h1><ol>
<li>寻找独立的上下文边界——接缝</li>
<li>拆分数据库表格的混合加载功能，放弃直接利用数据库命令访问上下文边界间的外键，改为由代码（微服务服务API）</li>
<li>共享的静态数据改由配置维护关联。</li>
<li>针对共享数据，建立合适的领域进行关联，例如代码中建立客户关系，来维护财务——客户——仓库关系。</li>
<li>共享表格，对于有大量列信息的表格，可以根据上下文边界将表格拆分成两个。</li>
<li>自数据库开始进行代码重构。</li>
<li>事务的边界重构，对于多表的修改操作，需要协同处理错误，或者利用分布式事务处理工具代为管理事务。</li>
<li>拆分后的数据库在制作报表时会出现问题，因为不再能用sql语言进行表格操作。解决方法可以是主动定期导出表格合并，或者基于修改时间订阅导出行为。</li>
</ol>
<h1 id="部署微服务"><a href="#部署微服务" class="headerlink" title="部署微服务"></a>部署微服务</h1><ol>
<li>准备CI系统，流水线，自动化流程</li>
<li>Paas，Docker打包部署</li>
</ol>
<h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><ol>
<li>单元测试</li>
<li>服务测试(mock&#x2F;打桩)</li>
<li>E2E测试 —— 消费者驱动的测试</li>
<li>上线 —— 金丝雀发布法</li>
</ol>
<h1 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h1><p>微服务的监控难度高于单一服务器应用。微服务包含多个服务，而每个服务的实例个数不等。关联标识可以帮忙关联同一个事件服务调用的日志，采用统一标准化的格式能够更快的辅助错误定位。</p>
<p>监控的内容包括CPU，响应时间，以及合理的语义监控（合成事务监控）。</p>
<h1 id="微服务安全"><a href="#微服务安全" class="headerlink" title="微服务安全"></a>微服务安全</h1><ol>
<li>身份验证和授权</li>
</ol>
<p>身份雅正确认了登录者的身份。授权机制能够确定登录者可以访问和进行的操作。常见的单点登录（Single Sign-On)，企业级标准为SAML和OpenID Connect，前者基于SOAP标准，后者基于OAuth2.0. 身份提供者可以是外部系统或者内部目录服务，如LDAP&#x2F;AD等。</p>
<p>微服务的身份认证和授权部分可以依托于网关，网关可以作为认证代理，通过网管认证的所有查询和操作都可以发送到微服务集群任意一个实例中处理。微服务内部可以决定身份可以授权的操作。</p>
<ol start="2">
<li>服务间的身份验证和授权</li>
</ol>
<p>服务之间的身份验证是指微服务的各个服务之间的身份验证和授权，一般来说有如下几种方式管理:</p>
<ul>
<li>在微服务边界内允许一切</li>
<li>HTTP(S)基本身份验证（HTTP明文传输认证信息，如果基于SSL认证则需要管理多台服务器之间的自签发证书。）</li>
<li>使用SAML或OpenID Connect认证授权，可以有效的避免中间人攻击，这样每个服务也需要一个身份。</li>
<li>客户端证书（采用客户端X.509证书，通过TLS层协议对服务器验证进行保证。)</li>
<li>HMAC（Hash-based Message Authentication Code,请求主题和私有密钥一起被哈希处理后进行发送，服务器使用请求主题和自己私钥副本重建哈希值。如果匹配则接收，防止的中间人攻击。)</li>
<li>JWT(JSON Web Token,JWT的原则是在服务器身份验证之后，将生成一个JSON对象并将其发送回用户。当用户与服务器通信时，客户在请求中发回JSON对象。服务器仅依赖于这个JSON对象来标识用户。为了防止用户篡改数据，服务器将在生成对象时添加签名。)</li>
<li>API密钥(API密钥是给予某种形式的秘密令牌的名称，该秘密令牌与Web服务（或类似）请求一起提交以便识别请求的来源。密钥可以包括在请求内容的一些摘要中，以进一步验证原点并防止篡改值。)</li>
</ul>
<ol start="3">
<li>数据加密（现存多种算法进行数据加密，密钥可以通过加盐哈希保护）</li>
<li>深度防御</li>
</ol>
<ul>
<li>防火墙</li>
<li>日志</li>
<li>入侵监测</li>
<li>网络隔离</li>
<li>操作系统安全</li>
<li>OWASP标准(Open Web Application Security Project开放式Web应用程序安全项目,<a target="_blank" rel="noopener" href="https://www.owasp.org/">https://www.owasp.org</a>)</li>
</ul>
<h1 id="系统设计与组织架构"><a href="#系统设计与组织架构" class="headerlink" title="系统设计与组织架构"></a>系统设计与组织架构</h1><p>公司团队的组织架构会影响系统设计。</p>
<ul>
<li><p>单地域的团队拥有更加好的灵活性和效率，因此对于异地团队最好的办法是想办法合理拆分，让不同的团队负责不同的松耦合模块。</p>
</li>
<li><p>每个团队需要负责对服务的需求，更改，构建，部署到运维，自治的团队能够很好的激励团队的效率。</p>
</li>
<li><p>小团队规模，少于10个人的团队能够对其所负责的系统整个生命周期负责，技术选择和实现上具有灵活性。当然这个对服务的高效构建部署效率很高，比如利用云服务的Infra来轻松构建CI&#x2F;CD流程。</p>
</li>
</ul>
<h1 id="规模化微服务"><a href="#规模化微服务" class="headerlink" title="规模化微服务"></a>规模化微服务</h1><ul>
<li><p>允许故障无处不在，故障永远会在意想不到的时候发生，所以微服务本身需要能够允许故障出现，硬件上也不用为避免故障作特殊设计。</p>
</li>
<li><p>服务平行扩容阈值控制，需要参考一些系统参数，响应时间&#x2F;延迟，可用性，数据持久性（丢包率）。</p>
</li>
<li><p>当故障出现时，适当的服务功能降级，允许应用能够在其他方面能够正确运行而不是直接返回错误界面。</p>
</li>
<li><p>微服务延迟的影响控制，通常会导致worker线程池的阻塞队列超长，最终线程池没有可用的线程而宕机。合理设置线程池的舱壁bulkhead，在舱位线程用尽后断路该服务，避免因为单个服务的延迟影响导致所有的线程都阻塞于同一个服务。</p>
</li>
<li><p>数据库扩展，当数据库需要服务于高吞吐量服务时，可以通过数据库副本，RDBMS系统，扩展写操作，独立CQRS读写分离系统，等多种方式扩展。</p>
</li>
<li><p>缓存可以优化重复请求，氛围哭护短、代理和服务器端缓存。</p>
</li>
<li><p>自动伸缩，当云管理能够强大到自动调整微服务实例个数，就可以基于当前流量进行自动调整。</p>
</li>
<li><p>CAP定理(一致性consistency、可用性availability和分区容忍性partition tolerance)是分布式系统中需要控制好的三个平衡。</p>
</li>
<li><p>服务发现，可以通过DNS服务器进行关联，负载均衡服务器将查询分发到不同的IP服务器上。</p>
</li>
<li><p>动态服务注册，新加入的微服务实例的IP应用信息需要能共享给其他服务，Zookeeper，consul和Eureka等服务可以管理配置管理和服务发现。</p>
</li>
<li><p>文档服务，为API构建合适的文档，Swagger可以很好的自动生成API文档，HAL和HAL浏览器也可以客户端逐步探索API。</p>
</li>
<li><p>自描述系统（UDDI Universal Description Discovery and Integration通用描述发现与集成服务），这个标准能帮助了解哪些服务正在运行。</p>
</li>
</ul>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://sunnyhll.github.io/2019/12/24/Java/Java-Concurrency-In-Depth/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="果核&肉肉">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="微观天下">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 微观天下">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/12/24/Java/Java-Concurrency-In-Depth/" class="post-title-link" itemprop="url">Java Concurrency In Depth</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-12-24 16:29:19" itemprop="dateCreated datePublished" datetime="2019-12-24T16:29:19+08:00">2019-12-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-02-08 12:55:25" itemprop="dateModified" datetime="2024-02-08T12:55:25+08:00">2024-02-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>本文将从计算机底层实现的角度描述Java目前的并发工具的实现细节。</p>
<h1 id="Synchronized实现细节"><a href="#Synchronized实现细节" class="headerlink" title="Synchronized实现细节"></a>Synchronized实现细节</h1><p>JVM基于进入和退出Monitor对象来实现方法同步和代码块同步。即使用monitorenter和monitorexit指令实现的。</p>
<ul>
<li>monitorenter指令是在编译后插入到同步代码块的开始位置，而monitorexit是插入到方法结束处和异常处。</li>
<li>线程执行到monitorenter指令时会尝试获取对象所对应的monitor的所有权&#x2F;对象锁。</li>
</ul>
<p>Synchronized用的锁是存在与Java对象头里。Java对象头的结构于<a href="/2018/11/07/JVM-memory-management-and-GC/#%E5%AF%B9%E8%B1%A1%E5%A4%B4">这里</a>。</p>
<p>锁一共有4种状态，级别从低到高分别是：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态。</p>
<p>偏向锁：</p>
<pre><code>1. 设置:当一个线程获取锁，对象锁从无锁状态变成偏向锁，允许该线程反复拿锁。（已经有identity hashcode的对象不会使用偏向锁）

2. 撤销：当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，撤销后变成无锁状态，膨胀成轻量级锁。（偏向对象如果需要identity hashcode则会膨胀成重量级锁）
</code></pre>
<p>** identity hash code： 未被覆写的 java.lang.Object.hashCode() 或者 java.lang.System.identityHashCode(Object) 所返回的值。</p>
<p>轻量级锁：</p>
<pre><code>1. 设置：JVM在当前线程栈帧中创建用于存储锁纪录的空间，并将对象头的MarkWord复制到锁纪录中。然后尝试用CAS操作将指向锁纪录指针放入MarkWord空间。如果成功，则获得锁，如果失败，则自旋来获取锁。

2. 解锁: CAS操作将Displaced MarkWord
放回到对象头，如果成功，表示没有竞争。如果失败说明存在竞争,即两个线程中解锁线程无法将MarkWord取回，因为另一个自旋线程已经尝试将MarkWord放到自己线程的锁记录中，CAS会发现MW的owner不是自己，膨胀成重量级锁。阻塞所有没拿到锁的线程。
</code></pre>
<p>重量级锁：</p>
<pre><code>1. 设置：重量级锁会阻塞拿不到锁的所有线程，减少了自旋带来的CPU开销。一旦升级成重量级锁，将不会降级锁。
</code></pre>
<h1 id="原子操作的实现原理"><a href="#原子操作的实现原理" class="headerlink" title="原子操作的实现原理"></a>原子操作的实现原理</h1><p>原子操作主要依赖的是计算机的如下几个CPU基本操作：</p>
<p><img src="/2019/12/24/Java/Java-Concurrency-In-Depth/AtomicFundamentals.jpg" alt="AtomicFundamentals"></p>
<p>为了达到原子操作的目的，CPU会通过如下两种方式确保在某一时刻，只有一个CPU对共享内存中的数据进行写操作：</p>
<ol>
<li>通过总线锁保证原子性：CPU会提供一个LOCK #信号，将其他处理器的内存访问请求阻塞住，从而独占共享内存。</li>
<li>通过缓存所定保证原子性：需要处理器支持，开销较小，CPU修改缓存行进行缓存锁定，那么另一个CPU就不能同时缓存该内存数据，这是通过处理器的缓存以执行机制来保证的。</li>
</ol>
<p>JVM中是可以通过锁和循环CAS操作来保证该变量的赋值成功的。</p>
<p>其中循环CAS操作可能带来如下问题：</p>
<ol>
<li>ABA问题，值已经变化，但CAS的旧值比较返回true，解决方法是加入变量版本号。</li>
<li>循环时间开销大，可以通过JVM支持CPU的pause指令提升效率。</li>
<li>只能保证单一共享变量的原子性，可以通过AtomicReference方式合并变量成为一个新的对象处理。</li>
</ol>
<p>锁机制，除了偏向锁，锁本身就是通过循环CAS实现拿&#x2F;释放锁。</p>
<h1 id="Lock锁实现细节"><a href="#Lock锁实现细节" class="headerlink" title="Lock锁实现细节"></a>Lock锁实现细节</h1><p>对比与synchronized中采用的锁，  Lock有如下不同之处:</p>
<p><img src="/2019/12/24/Java/Java-Concurrency-In-Depth/LockSynchronized.png" alt="LockSynchronized"></p>
<p>以下是Lock的API介绍，本文将展示API的实现细节：<br><img src="/2019/12/24/Java/Java-Concurrency-In-Depth/LockAPI.png" alt="LockAPI"></p>
<p>ReentrantLock的实现依赖于Java同步器框架，下面将着重讲解同步器框架的实现。对于公平锁和非公平锁的实现，AQS基本实现都一样，除了在公平锁释放节点是会调用hasQueuedPredecessors()方法判定是否队列中用等待节点，从而保证不会有线程在释放阶段竞争到锁，让线程串行化拿锁。</p>
<h2 id="队列同步器AQS框架实现细节"><a href="#队列同步器AQS框架实现细节" class="headerlink" title="队列同步器AQS框架实现细节"></a>队列同步器AQS框架实现细节</h2><blockquote>
<p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/waterystone/p/4920797.html">http://www.cnblogs.com/waterystone/p/4920797.html</a></p>
</blockquote>
<p>类如其名，抽象的队列式的同步器，AQS定义了一套多线程访问共享资源的同步器框架，许多同步类实现都依赖于它，如常用的ReentrantLock&#x2F;Semaphore&#x2F;CountDownLatch。</p>
<p>实现细节在另一篇<a href="Java-Memory-Model/##%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82">文章</a>已讲述。</p>
<p>同步器本身是一个抽象类，实现了同步器的类可以完成线程同步，包括：同步队列，独占式同步状态获取与释放，共享式同步状态获取与释放及超时获取同步状态。队列同步器使用了一个int成员变量表示同步状态，通过内置的FIFO队列来完成资源获取线程的排队工作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractQueueSynchronizer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标记锁状态， 0是无锁状态，非0则是同步队列有被阻塞节点/线程。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> state;</span><br><span class="line">    <span class="comment">//同步状态相关方法</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> in <span class="title function_">getState</span><span class="params">()</span>; <span class="comment">// 获取当前的同步状态</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(<span class="type">int</span> newState)</span>; <span class="comment">//设置当前的同步状态</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSetState</span><span class="params">(<span class="type">int</span> expect, <span class="type">int</span> update)</span>; <span class="comment">//使用CAS设置当前状态，能够保证状态设置的原子性</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//支持重写的方法</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> arg)</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> arg)</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">tryAcquireShared</span><span class="params">(<span class="type">int</span> arg)</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryReleaseShared</span><span class="params">(<span class="type">int</span> arg)</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isHeldExclusive</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//模板方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">acquireInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryAcquireNanos</span><span class="params">(<span class="type">int</span> arg, <span class="type">long</span> nanos)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">acquireShared</span><span class="params">(<span class="type">int</span> arg)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">acquireSharedInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryAcquireSharedNanos</span><span class="params">(<span class="type">int</span> arg, <span class="type">long</span> nanos)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">releaseShared</span><span class="params">(<span class="type">int</span> arg)</span>;</span><br><span class="line">    <span class="keyword">public</span> Collection&lt;Thread&gt; <span class="title function_">getQueuedThreads</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>支持重写方法的不同重写可以实现不同的锁，具体如下：<br><img src="/2019/12/24/Java/Java-Concurrency-In-Depth/AQSoverride.png" alt="AQSoverride"></p>
<p>在实现重写方法可以调用模板方法，具体如下：<br><img src="/2019/12/24/Java/Java-Concurrency-In-Depth/AQStemplate.png" alt="AQStemplate"></p>
<p>下文将分类别讲述模板方法的实现:</p>
<h3 id="同步队列"><a href="#同步队列" class="headerlink" title="同步队列"></a>同步队列</h3><p>同步器内部有一个同步队列（FIFO双向队列）进行同步状态管理。当前线程获取同步状态失败时，同步器会将当前线程及等待状态等信息构造成为一个节点并将其加入同步队列，同时会阻塞当前线程，当同步状态释放时，会把节点中的线程唤醒，使其再次尝试获取同步状态。</p>
<p><img src="/2019/12/24/Java/Java-Concurrency-In-Depth/AQSQueue.png" alt="AQSQueue"></p>
<p>compareAndSetTail(…)方法基于CAS设置尾节点，保证队列更新的线程安全。<br>而头节点的更新是由获得锁的线程更新的，因此不需要作同步处理，是线程安全的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> waitStatus;</span><br><span class="line">    <span class="keyword">private</span> Node prev;</span><br><span class="line">    <span class="keyword">private</span> Node next;</span><br><span class="line">    <span class="keyword">private</span> Node nextWaiter;</span><br><span class="line">    <span class="keyword">private</span> Thread thread;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体描述如下图所示：</p>
<p><img src="/2019/12/24/Java/Java-Concurrency-In-Depth/Node.png" alt="Node"></p>
<ol>
<li>当首节点的线程成功地获取了同步状态&#x2F;锁，该线程会将首节点设置为后继节点，并且将本节点的next引用断开即可。然后线程执行任务，任务完成后唤醒后继节点。具体的节点处理实现由锁的类型(独占&#x2F;共享)的模板方法Release&#x2F;ReleaseShared实现。</li>
</ol>
<p><img src="/2019/12/24/Java/Java-Concurrency-In-Depth/Deque.jpg" alt="Dequeue"></p>
<ol start="2">
<li>当一个线程无法获取到同步状态，会被构造成节点加入到同步队列尾部，CAS设置能保证节点加入过程的线程安全。过程图如图所示。</li>
</ol>
<p><img src="/2019/12/24/Java/Java-Concurrency-In-Depth/Enque.jpg" alt="Enqueue"></p>
<p>节点操作由具体的模板方法AcquireQueued&#x2F;AcquireShared等实现，而节点封装和入队细节如下列代码所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Node head;</span><br><span class="line">    <span class="keyword">private</span> Node tail;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">addWaiter</span><span class="params">(Node mode)</span>&#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Thread.currentThread(), mode);</span><br><span class="line">        <span class="comment">//快速尝试在尾部添加</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">pred</span> <span class="operator">=</span> tail;</span><br><span class="line">        <span class="keyword">if</span>( pred != <span class="literal">null</span>) &#123;</span><br><span class="line">            node.prev = pred;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(pred, node))&#123;</span><br><span class="line">                pred.next = node;</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        enq(node);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span>&#123;</span><br><span class="line">        <span class="comment">// 死循环保证了节点的添加在有并发冲突的情况也能成功</span></span><br><span class="line">        <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail;</span><br><span class="line">            <span class="keyword">if</span>(t == <span class="literal">null</span>)&#123;<span class="comment">//Must initialize</span></span><br><span class="line">                <span class="keyword">if</span>(compareAndSetHead(<span class="keyword">new</span> <span class="title class_">Node</span>()))</span><br><span class="line">                    tail = head;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                node.prev = t;</span><br><span class="line">                <span class="keyword">if</span>(compareAndSetTail(t, node))&#123;</span><br><span class="line">                    t.next = node;</span><br><span class="line">                    <span class="keyword">return</span> t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<h3 id="独占式同步状态获取与释放"><a href="#独占式同步状态获取与释放" class="headerlink" title="独占式同步状态获取与释放"></a>独占式同步状态获取与释放</h3><p>独占式同步状态，是指在同一时刻只能有一个线程成功获取同步状态，锁的获取是排他的，不是共享的。</p>
<ol>
<li>独占式同步状态获取流程如图所示:<br><img src="/2019/12/24/Java/Java-Concurrency-In-Depth/Acquire.jpg" alt="Acquire"></li>
</ol>
<p>相关的实现代码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="type">int</span> arg)</span>&#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//在同步队列入队完成后，每个节点都在自旋等待，但是只有前驱是头节点的节点(头节点的next节点)才能有终端自旋的可能</span></span><br><span class="line">        <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">            <span class="keyword">if</span>(p == head $$ <span class="title function_">tryAcquire</span><span class="params">(arg)</span>)&#123;</span><br><span class="line">                <span class="comment">//更新头节点</span></span><br><span class="line">                setHead(node);</span><br><span class="line">                <span class="comment">//断开头节点对后续节点的引用</span></span><br><span class="line">                p.next = <span class="literal">null</span>; <span class="comment">//help GC</span></span><br><span class="line">                failed = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(shouldParkAfterFailedAcquiredAcquire(p, node) &amp;&amp; parkAndCheckInterrupe())</span><br><span class="line">                interrupted = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>独占式同步状态释放<br>在当前线程获取了同步状态并执行后，需要释放同步状态，从而使得后续的同步节点可以获取同步状态。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tryRelease(arg))&#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">if</span>(h != <span class="literal">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);<span class="comment">//使用lockSupport去唤醒等待状态的线程。</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="共享式同步状态获取与释放"><a href="#共享式同步状态获取与释放" class="headerlink" title="共享式同步状态获取与释放"></a>共享式同步状态获取与释放</h3><p>共享式获取与独占式获取最主要的区别在与同一时刻能否有多个线程同时获取到同步状态。以文件的读写为例，读操作可以是共享式访问，写操作则是独占式访问。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquireShared</span><span class="params">(<span class="type">int</span> arg)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tryAcquireShared(arg) &lt; <span class="number">0</span>&gt;)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doAcquireShared</span><span class="params">(<span class="type">int</span> arg)</span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addWaiter(Node.SHARED);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 自旋获取共享锁</span></span><br><span class="line">        <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> tryAcquireShared(arg);</span><br><span class="line">                <span class="comment">//获取到了同步状态</span></span><br><span class="line">                <span class="keyword">if</span>( r &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="literal">null</span>;</span><br><span class="line">                    <span class="keyword">if</span>(interrupted)</span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                    failed = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">releaseShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="comment">//tryReleaseShared通过自旋和CAS保证释放状态成功</span></span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        <span class="comment">//释放同步状态后，会唤醒处于等待状态的节点。</span></span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="独占式超时获取同步状态"><a href="#独占式超时获取同步状态" class="headerlink" title="独占式超时获取同步状态"></a>独占式超时获取同步状态</h3><p>超时获取同步状态，即在指定的时间段内获取同步状态，如果获取到同步状态则返回true，否则，返回false。具体流程如下: </p>
<p><img src="/2019/12/24/Java/Java-Concurrency-In-Depth/Workflow.jpg" alt="Workflow"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">doAcquireNanos</span><span class="params">(<span class="type">int</span> arg, <span class="type">long</span> nanosTimeout)</span> <span class="keyword">throws</span> InterruptedException&#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">lastTime</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addWaiter(Node,EXCLUSIVE);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">            <span class="comment">//确定时间内获取成功</span></span><br><span class="line">            <span class="keyword">if</span>(p == head &amp;&amp; tryAcquire(arg))&#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="literal">null</span>;</span><br><span class="line">                failed = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//确定时间内获取失败</span></span><br><span class="line">            <span class="keyword">if</span>(nanosTimeout &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(shouldParkAfterFailedAcquire(p, node) &amp;&amp; nanosTimeout &gt; spinForTimeoutThreshold)</span><br><span class="line">                LockSupport.parkNanos(<span class="built_in">this</span> nanosTimeout);</span><br><span class="line">            <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">            <span class="comment">// 计算lastTime到现在的睡眠时间，并且更新还应该睡眠的时间</span></span><br><span class="line">            nanosTimeout -= now - lastTime;</span><br><span class="line">            lastTime = now;</span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Condition实现细节"><a href="#Condition实现细节" class="headerlink" title="Condition实现细节"></a>Condition实现细节</h1><p>每个Condition对象都包含一个等待队列，Object包含一个AQS队列，两个队列节点是AQS中的Node，并用这个两个队列共同实现了wait&#x2F;notify功能。</p>
<h2 id="等待"><a href="#等待" class="headerlink" title="等待"></a>等待</h2><p>Condition.await()让线程释放锁，构造新节点加入等待队列进入等待状态。返回的前提是重新获取了condition相关联的锁。底层是通过LockSupport的park()方法释放。</p>
<h2 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h2><p>Condition.signal()将等待队列中等待时间最长的节点加入同步队列，并用LockSupport.unpark()唤醒该节点。加入同步队列的节点通过tryAcquire()竞争获取锁，获取锁后从await()中返回继续执行。</p>
<h1 id="并发容器实现细节"><a href="#并发容器实现细节" class="headerlink" title="并发容器实现细节"></a>并发容器实现细节</h1><h2 id="ConcurrentHashMap实现细节"><a href="#ConcurrentHashMap实现细节" class="headerlink" title="ConcurrentHashMap实现细节"></a>ConcurrentHashMap实现细节</h2><blockquote>
<p>ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成。Segment是一种可重入锁ReentrantLock，在ConcurrentHashMap里扮演锁的角色，HashEntry则用于存储键值对数据。一个ConcurrentHashMap里包含一个Segment数组，Segment的结构和HashMap类似，是一种数组和链表结构， 一个Segment里包含一个HashEntry数组，每个HashEntry是一个链表结构的元素， 每个Segment守护者一个HashEntry数组里的元素,当对HashEntry数组的数据进行修改时，必须首先获得它对应的Segment锁。</p>
</blockquote>
<p><img src="/2019/12/24/Java/Java-Concurrency-In-Depth/concurrentHashmap.png" alt="ConcurrentHashMap"></p>
<p>读取HashEntry信息是不需要拿锁，从而保证了并发读的高效性。HashMap中读取Map.Entry&lt;K,V&gt;是需要拿锁的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">HashEntry</span>&lt;K,V&gt; &#123;  </span><br><span class="line">    <span class="keyword">final</span> K key; <span class="comment">// immutable field保证链表稳定性，新节点头插入,或者替换已有的值（不能重复value）。  </span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> hash;  </span><br><span class="line">    <span class="keyword">volatile</span> V value;  <span class="comment">//volatile保证可见性，删除需要O(n)倒序复制被删节点前的list。</span></span><br><span class="line">    <span class="keyword">final</span> HashEntry&lt;K,V&gt; next;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>在Hash中，会进行分段哈希从而保证segment中数组的均匀性，会对hash值的高字段和低字段进行分段处理，前半段获取segment位置，后端确定segment中数组中未知。</p>
<ul>
<li>get()操作不需要枷锁，除非读到的值为空才会加锁重读。</li>
<li>put()操作需要对加锁操作。扩容时，只会对某segment中的数组进行扩种。</li>
<li>size()操作会两次不加锁计算，当操作数没有变化，则直接返回，如果变化则加锁获取size。</li>
</ul>
<h2 id="阻塞队列实现原理"><a href="#阻塞队列实现原理" class="headerlink" title="阻塞队列实现原理"></a>阻塞队列实现原理</h2><h1 id="线程池并行执行机制Executor"><a href="#线程池并行执行机制Executor" class="headerlink" title="线程池并行执行机制Executor"></a>线程池并行执行机制Executor</h1><p>Java线程即是工作单元，也是执行机制。工作单元包括Runnable和Callable，而执行机制由Executor框架提供。应用程序通过Executor框架控制上层的调度，下层的调度由操作系统内核控制，下层调度不受应用程序的控制。<br><img src="/2019/12/24/Java/Java-Concurrency-In-Depth/ExecutorMechanism.jpg" alt="Executor"></p>
<p>Executor接收<code>Runnable/Callable&lt;T&gt;</code>接口的实例的任务，返回<code>Future&lt;T&gt;</code>接口的<code>FutureTask&lt;T&gt;</code>实例，当任务完成时，可以获取任务执行结果。</p>
<h2 id="ThreadPoolExecutor-线程池-框架和实现原理"><a href="#ThreadPoolExecutor-线程池-框架和实现原理" class="headerlink" title="ThreadPoolExecutor (线程池)框架和实现原理"></a>ThreadPoolExecutor (线程池)框架和实现原理</h2><p>ThreadPoolExecutor可以有三种: FixedThreadPool, SingleThreadExecutor, CachedThreadPool。这三种是不同配置的ThreadPoolExecutor，并非不同子类型。</p>
<ul>
<li><p>FixedThreadPool:<br>FixedThreadPool是使用固定线程数的线程池，适用于为了满足资源管理的需求，而需要限制当前线程数量的应用场景，适用于负载较重的服务器。<br><img src="/2019/12/24/Java/Java-Concurrency-In-Depth/FixedThreadPool.jpg" alt="FixedThreadPool"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads, <span class="number">0L</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());<span class="comment">//无界队列</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads, ThreadFactory threadFactory)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>SingleThreadExecutor:<br>SingleThreadExecutor是单个线程的线程“池”，适用于需要保证顺序执行的各个任务，并且保证没有多个线程活动的应用场景。<br><img src="/2019/12/24/Java/Java-Concurrency-In-Depth/SingleThreadExecutor.jpg" alt="SingleThreadExecutor"></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">SingleThreadExecutor</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// FinalizableDelegatedExecutorService 增加对gc时停掉线程池的功能</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FinalizableDelegatedExecutorService</span>(<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0L</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()));</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">SingleThreadExecutor</span><span class="params">(ThreadFactory threadFactory)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>CachedThreadPool:<br>CachedThreadPool是大小无界的线程池，适用于执行多的短期异步任务的小程序，适合负载较轻的服务器。<br><img src="/2019/12/24/Java/Java-Concurrency-In-Depth/CachedThreadPool.jpg" alt="CachedThreadPool"></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">CachedThreadPool</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE, <span class="number">60L</span>, TimeUnit.SECONDS,<span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;());<span class="comment">//使用没有容量的工作队列，因为线程数没有限制。</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">CachedThreadPool</span><span class="params">(ThreadFactory threadFactory)</span>;</span><br></pre></td></tr></table></figure>
<h3 id="ThreadPoolExecutor实现原理"><a href="#ThreadPoolExecutor实现原理" class="headerlink" title="ThreadPoolExecutor实现原理"></a>ThreadPoolExecutor实现原理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class ThreadPoolExecutor&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> corePool; <span class="comment">// 核心线程池大小，当前运行线程数少于此则创建新线程至预热完成。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> maximumPool; <span class="comment">//最大线程池的大小，当前线程数不会超过此，多的任务会挂起在工作阻塞队列中。</span></span><br><span class="line">    <span class="keyword">private</span> BlockingQueue&lt;Runnable&gt; workQueue; <span class="comment">//保存任务的工作队列，只要队列不为空，空闲的线程会获取任务并执行，直到任务队列为空。</span></span><br><span class="line">    <span class="keyword">private</span> RejectedExecutionHandler handler; <span class="comment">// 工作队列饱和时调用的handler</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> keepAliveTime; <span class="comment">//空闲线程存活时间</span></span><br><span class="line">    <span class="keyword">private</span> TimeUnit unit; <span class="comment">//空闲时间单位</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ScheduledThreadPoolExecutor-调度线程池）框架实现原理"><a href="#ScheduledThreadPoolExecutor-调度线程池）框架实现原理" class="headerlink" title="ScheduledThreadPoolExecutor (调度线程池）框架实现原理"></a>ScheduledThreadPoolExecutor (调度线程池）框架实现原理</h2><p>调度线程池是线程池实现的扩展，主要在给定的延迟后运行任务，或者定期执行任务。<br>ScheduledThreadPoolExecutor有两种: ScheduledThreadPoolExecutor和SingleThreadScheduledExecutor。</p>
<ul>
<li><p>ScheduledThreadPoolExecutor:<br>ScheduledThreadPoolExecutor是固定个数线程的调度线程池，适用于需要多个后台线程执行周期任务，同时为了满足资源管理的需求而需要限制后台线程的数量的应用场景。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title function_">newScheduledThreadPool</span><span class="params">(<span class="type">int</span> corePoolSize)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title function_">newScheduledThreadPool</span><span class="params">(<span class="type">int</span> corePoolSize, ThreadFactory threadFactory)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>SingleThreadScheduledExecutor:<br>SingleThreadScheduledExecutor是单个后台线程执行周期任务，同事需要保证顺序地执行各个任务的应用场景。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title function_">SingleThreadScheduledExecutor</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title function_">SingleThreadScheduledExecutor</span><span class="params">(ThreadFactory threadFactory)</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="ScheduledThreadPoolExecutor实现原理"><a href="#ScheduledThreadPoolExecutor实现原理" class="headerlink" title="ScheduledThreadPoolExecutor实现原理"></a>ScheduledThreadPoolExecutor实现原理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScheduledThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title class_">ThreadPoolExecutor</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> time; <span class="comment">// 任务要被执行的具体时间，当前时间大于等于time值时被执行</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> sequenceNumber; <span class="comment">// 任务被添加到Executor时的序号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> period; <span class="comment">// 任务执行的间隔周期</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>提交任务<br>ScheduledThreadPoolExecutor接受实现了RunnableScheduledFuture接口的ScheduledFutureTask实例。通过scheduleAtFixedRate()方法或者scheduleWithFixedDelay()方法提交，放在<code>DelayQueue&lt;RunnableScheduledFuture&gt;</code>中。<br><img src="/2019/12/24/Java/Java-Concurrency-In-Depth/ScheduledTaskSubmission.jpg" alt="ScheduledTask"></p>
</li>
<li><p>执行任务<br>DelayQueue封装了一个PriorityQueue, 对队列中的ScheduledFutureTask进行排序，time小的排在前面。如果time值相同，则sequenceNumber小的在前面。</p>
</li>
<li><p>放回任务<br>对于执行过的周期任务，time值被重置为下一次的执行时间，并且将task放回DelayQueue中。</p>
</li>
</ol>
<h3 id="DelayQueue部分实现原理"><a href="#DelayQueue部分实现原理" class="headerlink" title="DelayQueue部分实现原理"></a>DelayQueue部分实现原理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DelayQueue</span>&lt;E <span class="keyword">extends</span> <span class="title class_">Delayed</span>&gt;&#123;</span><br><span class="line">    <span class="keyword">private</span> ReentrantLoc lock;</span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;E&gt; q;</span><br><span class="line">    <span class="keyword">private</span> Thread leader;</span><br><span class="line">    <span class="keyword">private</span> Condition available;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">take</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">        lock.lockInterruptibly(); <span class="comment">// 处理队列需要获得锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">                <span class="type">E</span> <span class="variable">first</span> <span class="operator">=</span> q.peek();<span class="comment">// 线程锁住等待直到有task出现</span></span><br><span class="line">                <span class="keyword">if</span>( first == <span class="literal">null</span>) &#123;</span><br><span class="line">                    available.await();</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="type">long</span> <span class="variable">deplay</span> <span class="operator">=</span> first.getDelay(TimeUnit.NANOSECONDS);</span><br><span class="line">                    <span class="keyword">if</span>(delay &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="type">long</span> <span class="variable">tl</span> <span class="operator">=</span> available.awaitNanos(delay); <span class="comment">// wait nanoseonds for task to be ready to execute.</span></span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="type">E</span> <span class="variable">x</span> <span class="operator">=</span> q.poll(); <span class="comment">// when task is ready, take the task and do</span></span><br><span class="line">                        <span class="keyword">assert</span> x != <span class="literal">null</span>;</span><br><span class="line">                        <span class="keyword">if</span>( q.size() != <span class="number">0</span>)</span><br><span class="line">                            available.signalAll(); <span class="comment">//release condition</span></span><br><span class="line">                        <span class="keyword">return</span> x;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">offer</span><span class="params">(E e)</span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">E</span> <span class="variable">first</span> <span class="operator">=</span> q.peek(); </span><br><span class="line">            q.offer(e); <span class="comment">// 拿到锁后放入这个queue</span></span><br><span class="line">            <span class="keyword">if</span>(first == <span class="literal">null</span>) || e.compareTo(first) &lt; <span class="number">0</span>)</span><br><span class="line">                available.singalAll(); <span class="comment">// 检查task是否到期可以执行，如果ready触发take的线程。</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ForkJoinPool-框架实现原理"><a href="#ForkJoinPool-框架实现原理" class="headerlink" title="ForkJoinPool 框架实现原理"></a>ForkJoinPool 框架实现原理</h2><p>ForkJoinPool由ForkJoinTask数组和ForkJoinWorkerThread数组组成，前者用于存放程序提交的任务，ForkJoinWorkerThread数组负责执行任务。</p>
<p>算法执行分两段，fork阶段将任务分割到足够小，创建&#x2F;唤醒一个工作线程执行；join阶段将任务的结果收集合并结果得到最后的结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForkJoinTask</span>&lt;V&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> ForkJoinTask&lt;V&gt; <span class="title function_">fork</span><span class="params">()</span> &#123;</span><br><span class="line">        ((ForkJoinWorkerThread) Thread.currentThread()).pushTask(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> V <span class="title function_">join</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(doJoin() != NORMAL)</span><br><span class="line">            <span class="keyword">return</span> reportResult();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> getRawResult();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> V <span class="title function_">reportResult</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> s; Throwable ex;</span><br><span class="line">        <span class="keyword">if</span>((s = status) == CANCELLED)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">CancellationException</span>();</span><br><span class="line">        <span class="keyword">if</span>(s == EXCEPTIONAL &amp;&amp; (ex = getThrowableException()) != <span class="literal">null</span>)</span><br><span class="line">            UNSAFE.throwException(ex);</span><br><span class="line">        <span class="keyword">return</span> getRawResult();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">doJoin</span><span class="params">()</span>&#123;</span><br><span class="line">        Thread t; ForkJoinWorkerTHread w; <span class="type">int</span> s; <span class="type">boolean</span> completed;</span><br><span class="line">        <span class="keyword">if</span>((t = Thread.currentThread()) <span class="keyword">instanceof</span> ForkJoinWorkThread) &#123;</span><br><span class="line">            <span class="keyword">if</span> (( s = STATUS)  &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> s;</span><br><span class="line">            <span class="keyword">if</span>( ((w = (ForkJoineWorkerThread)t).unpushTask(<span class="built_in">this</span>))) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    completed = exec();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable rex) &#123;</span><br><span class="line">                    <span class="keyword">return</span>  setExceptionalCompletion( rex);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(completed)</span><br><span class="line">                    <span class="keyword">return</span> setCompletion(NORMAL);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> w.joinTask(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> exeternalAwaitDone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForkJoinWorkerThread</span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">pushTask</span><span class="params">(ForkJoinTask&lt;?&gt; t)</span> &#123;</span><br><span class="line">        ForkJoinTask&lt;?&gt;[] q; <span class="type">int</span> s, m;</span><br><span class="line">        <span class="keyword">if</span>((q = quque) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">u</span> <span class="operator">=</span> (((s = queueTop) &amp; (m = q.length - <span class="number">1</span>)) &lt;&lt; ASHIFT) + ABASE;</span><br><span class="line">            UNSAFE.putOrderObject(q, u, t);</span><br><span class="line">            queueTop = s + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> ((s -= queueBase) &lt;= <span class="number">2</span>)</span><br><span class="line">                pool.singalWork();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s == m)</span><br><span class="line">                growQuque();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="异步执行机制"><a href="#异步执行机制" class="headerlink" title="异步执行机制"></a>异步执行机制</h1><h2 id="FutureTask实现原理"><a href="#FutureTask实现原理" class="headerlink" title="FutureTask实现原理"></a>FutureTask实现原理</h2><p>FutureTask实现了Future, Runnable接口。是Executor的执行任务单元，也可以由调用线程直接执行FutureTask.run()。FutureTask的get方法能阻塞当前线程，等待任务执行结果再执行下文。</p>
<p>FutureTask通过内部聚合的AQS的子类实现完成FUtureTask的获取和释放操作。队列中的每个FutureTask实例的get方法并不以一定需要在run方法之前执行，get方法会阻塞调用线程直到run方法被执行完成。每个任务只会执行一次，并且会有定义好的执行顺序，从get方法调用线程恢复执行上下文，从而达到异步调用的效果。类似.NET中的beginInvoke和endInvoke方法。<br><img src="/2019/12/24/Java/Java-Concurrency-In-Depth/FutureTask.jpg" alt="Future"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FutureTask</span>&lt;V&gt; <span class="keyword">implements</span> <span class="title class_">Future</span>&lt;V&gt;, Runnable&#123;</span><br><span class="line">    <span class="keyword">private</span> Sync sync;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        Callable.call();</span><br><span class="line">        ...</span><br><span class="line">        AQS.compareAndSetState(<span class="type">int</span> expect, <span class="type">int</span> update);</span><br><span class="line">        ...</span><br><span class="line">        AQS.releaseShared(<span class="type">int</span> arg);</span><br><span class="line">        ...</span><br><span class="line">        FutureTask.done();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">cancel</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        AQS.acquireSharedInterruptily(<span class="type">int</span> arg);</span><br><span class="line">        ...</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> V <span class="title function_">innerGet</span><span class="params">()</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">innerRun</span><span class="params">()</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">innerCancel</span><span class="params">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="CompletableFuture实现原理"><a href="#CompletableFuture实现原理" class="headerlink" title="CompletableFuture实现原理"></a>CompletableFuture实现原理</h2><p>CompletableFuture实现了Future，CompletionStage接口，后者接口增加了更多对任务流程的控制接口，可以直接通过接口实现回调函数的定义。</p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://sunnyhll.github.io/2019/10/19/JS/Angular-Observables/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="果核&肉肉">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="微观天下">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 微观天下">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/10/19/JS/Angular-Observables/" class="post-title-link" itemprop="url">RxJs Observables</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-10-19 20:16:06" itemprop="dateCreated datePublished" datetime="2019-10-19T20:16:06+08:00">2019-10-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-06-22 10:51:41" itemprop="dateModified" datetime="2021-06-22T10:51:41+08:00">2021-06-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JS/" itemprop="url" rel="index"><span itemprop="name">JS</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="What-is-Observable"><a href="#What-is-Observable" class="headerlink" title="What is Observable"></a>What is Observable</h1><p>Observable利用观察者模式，建立了发布者publisher和订阅者subscriber之间的联系。联系本身不会修改发布的信息，只是定义声明了订阅者对发布信息的处理方式。</p>
<p>使用目的：</p>
<ol>
<li><p>流式处理本身是延迟执行的，即在需要数据的一刻进行处理，并且不改变数据本身而是生成一个新的流。多流处理的支持。</p>
</li>
<li><p>异步回调保证了流式处理结果的实时渲染，因此Observable是高性能前端的重要概念。可以将同步方法转换成异步方法。</p>
</li>
<li><p>支持事件处理，动态注册事件及句柄。</p>
</li>
</ol>
<h2 id="创建Observable"><a href="#创建Observable" class="headerlink" title="创建Observable"></a>创建Observable</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Observable</span>&#125; <span class="keyword">from</span> <span class="string">&#x27;rxjs&#x27;</span>;</span><br><span class="line"><span class="comment">// subscriber/observer is callback functions for this observable.</span></span><br><span class="line"><span class="comment">// &#123;next, error, complete&#125;</span></span><br><span class="line"><span class="keyword">const</span> observable = <span class="keyword">new</span> <span class="title class_">Observable</span>(<span class="function"><span class="params">subscriber</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// observable can decide how frequency next/error/complete callback is called.</span></span><br><span class="line">    subscriber.<span class="title function_">next</span>(<span class="number">1</span>);</span><br><span class="line">    subscriber.<span class="title function_">next</span>(<span class="number">2</span>);</span><br><span class="line">    subscriber.<span class="title function_">next</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        subscriber.<span class="title function_">next</span>(<span class="number">4</span>);</span><br><span class="line">        subscriber.<span class="title function_">complete</span>();</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="title function_">unsubscribe</span>(<span class="params"></span>) &#123;&#125;&#125;;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="传入Observable回调函数-x2F-创建一个subscriber"><a href="#传入Observable回调函数-x2F-创建一个subscriber" class="headerlink" title="传入Observable回调函数&#x2F;创建一个subscriber"></a>传入Observable回调函数&#x2F;创建一个subscriber</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">observable.<span class="title function_">subscribe</span>(&#123;</span><br><span class="line">    <span class="function"><span class="params">x</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;got value &#x27;</span> + x),</span><br><span class="line">    <span class="function"><span class="params">err</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;got error &#x27;</span> + err),</span><br><span class="line">    <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;done&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="创建multicast-Observable"><a href="#创建multicast-Observable" class="headerlink" title="创建multicast Observable"></a>创建multicast Observable</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">multicastSequenceSubscriber</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> observers = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> timeoutId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">observer</span>) =&gt;</span> &#123;</span><br><span class="line">        observers.<span class="title function_">push</span>(observer);</span><br><span class="line">        <span class="comment">// start the sequence when firstly subscribed.</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( observers.<span class="property">length</span> === <span class="number">1</span>) &#123;</span><br><span class="line">            timeoutId = <span class="title function_">doSequence</span>(&#123;</span><br><span class="line">                <span class="title function_">next</span>(<span class="params">val</span>) &#123;</span><br><span class="line">                    <span class="comment">// 将所有observer封装成一个observer</span></span><br><span class="line">                    observers.<span class="title function_">forEach</span>(<span class="function"><span class="params">obs</span> =&gt;</span> obs.<span class="title function_">next</span>(val));</span><br><span class="line">                &#125;,</span><br><span class="line"></span><br><span class="line">                <span class="title function_">complete</span>(<span class="params"></span>) &#123;</span><br><span class="line">                    observers.<span class="title function_">slice</span>(<span class="number">0</span>).<span class="title function_">forEach</span>( <span class="function"><span class="params">obs</span> =&gt;</span> obs.<span class="title function_">complete</span>());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, seq, <span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="title function_">unsubscribe</span>(<span class="params"></span>) &#123;</span><br><span class="line">                <span class="comment">//remove observer</span></span><br><span class="line">                observers.<span class="title function_">splice</span>(observers.<span class="title function_">indexOf</span>(observer), <span class="number">1</span>);</span><br><span class="line">                <span class="comment">// cancel subscription if no observers.</span></span><br><span class="line">                <span class="keyword">if</span>(observers.<span class="property">length</span> === <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="built_in">clearTimeout</span>(timeoutId);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> multicastObservable = <span class="keyword">new</span> <span class="title class_">Observerble</span>(<span class="title function_">multicastSequenceSubscriber</span>())</span><br><span class="line"></span><br><span class="line"><span class="comment">// subscribe to this observable</span></span><br><span class="line">multicastObservable.<span class="title function_">subscribe</span>(&#123;</span><br><span class="line">    <span class="title function_">next</span>(<span class="params">num</span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(num)&#125;</span><br><span class="line">    <span class="title function_">complete</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">multicastObservable.<span class="title function_">subscribe</span>(&#123;</span><br><span class="line">    <span class="title function_">next</span>(<span class="params">num</span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;second: &#x27;</span> + num)&#125;</span><br><span class="line">    <span class="title function_">complete</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="Observable关系操作符"><a href="#Observable关系操作符" class="headerlink" title="Observable关系操作符"></a>Observable关系操作符</h2><table>
<thead>
<tr>
<th align="left">Area</th>
<th align="center">Operator</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Creation</td>
<td align="center">from, fromEvent, of</td>
</tr>
<tr>
<td align="left">Comibination</td>
<td align="center">combineLatest,concat, merge, startWith, withLatestFrom, zip</td>
</tr>
<tr>
<td align="left">Filtering</td>
<td align="center">debounceTime, distinctUtilChanged, filter, take, takeUtil</td>
</tr>
<tr>
<td align="left">Transformation</td>
<td align="center">bufferTime, concatMap, map, mergeMap, scan, switchMap</td>
</tr>
<tr>
<td align="left">Utility</td>
<td align="center">tap</td>
</tr>
<tr>
<td align="left">Multicasting</td>
<td align="center">share</td>
</tr>
</tbody></table>
<p>Observable的关系操作符，是通过.pipe()引入的，更多的操作符，可以参考rxjs官方API文档<a target="_blank" rel="noopener" href="https://www.learnrxjs.io/operators/">here</a>。</p>
<h1 id="Using-observables-in-Angular"><a href="#Using-observables-in-Angular" class="headerlink" title="Using observables in Angular"></a>Using observables in Angular</h1><ul>
<li>EventEmitter</li>
<li>HTTP模块处理AJAX requests</li>
<li>Router, Forms 模块监听&#x2F;响应用户输入</li>
</ul>
<h1 id="Observable-v-s-Promise"><a href="#Observable-v-s-Promise" class="headerlink" title="Observable v.s. Promise"></a>Observable v.s. Promise</h1><ul>
<li>共同点</li>
</ul>
<table>
<thead>
<tr>
<th align="left">方面</th>
<th align="center">细节</th>
</tr>
</thead>
<tbody><tr>
<td align="left">异步处理</td>
<td align="center">subscribe&#x2F;then callback</td>
</tr>
<tr>
<td align="left">使用语言</td>
<td align="center">支持typescript, javascript</td>
</tr>
<tr>
<td align="left">支持HTTP</td>
<td align="center">通过Angular httpClient支持, observable.toPromise()</td>
</tr>
</tbody></table>
<ul>
<li>不同点</li>
</ul>
<table>
<thead>
<tr>
<th align="left">方面</th>
<th align="center">细节</th>
</tr>
</thead>
<tbody><tr>
<td align="left">使用场景</td>
<td align="center">O: 事件处理句柄, 流式处理； P: 链式处理</td>
</tr>
<tr>
<td align="left">操作符复杂度</td>
<td align="center">O:多样化； P:单一</td>
</tr>
</tbody></table>
<h1 id="Reactive-Programming"><a href="#Reactive-Programming" class="headerlink" title="Reactive Programming"></a>Reactive Programming</h1><p>使用异步数据流进行编程，通过代码来忠实反映业务之间的关系。</p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://sunnyhll.github.io/2019/08/11/%E6%9E%B6%E6%9E%84/Web/HTTP-protocol-introduction/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="果核&肉肉">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="微观天下">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 微观天下">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/08/11/%E6%9E%B6%E6%9E%84/Web/HTTP-protocol-introduction/" class="post-title-link" itemprop="url">HTTP protocol introduction</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-08-11 21:57:54" itemprop="dateCreated datePublished" datetime="2019-08-11T21:57:54+08:00">2019-08-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-02-08 12:39:24" itemprop="dateModified" datetime="2024-02-08T12:39:24+08:00">2024-02-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%9E%B6%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">架构</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%9E%B6%E6%9E%84/Web/" itemprop="url" rel="index"><span itemprop="name">Web</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="HTTP-协议"><a href="#HTTP-协议" class="headerlink" title="HTTP 协议"></a>HTTP 协议</h1><p>HTTP协议属于应用层协议，其设计目的是为了方便文本内容的分享与发布。HTTP协议是Web资源共享的基础，与URL(文档地址定位符)，HTML共同构建了Web世界。</p>
<p>HTTP协议属于点到点通信协议，请求访问资源的一端称为客户端，提供资源相应的一端称为服务器。</p>
<h2 id="HTTP协议方法"><a href="#HTTP协议方法" class="headerlink" title="HTTP协议方法"></a>HTTP协议方法</h2><ul>
<li>GET：请求访问资源。</li>
<li>POST：传输主体内容。</li>
<li>PUT：传输内容，幂等传输。</li>
<li>HEAD: 获得报文首部，用于确认资源有效性和更新日期。</li>
<li>DELETE: 删除内容。</li>
<li>OPTIONS: 询问资源支持方法。</li>
<li>TRACE：追踪路径，用于计算客户端到服务器端的跳数。</li>
<li>CONNECT: 要求用socket协议连接代理。</li>
</ul>
<p>HTTP方法本身是无状态协议，为了支持复杂有状态场景，引入了Cookie技术，确保认证客户端通信的上下文是连续的。</p>
<h2 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h2><table>
<thead>
<tr>
<th align="left"></th>
<th align="left">类别</th>
<th align="left">原因短语</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1XX</td>
<td align="left">Informational(信息性状态码)</td>
<td align="left">接收的请求正在处理</td>
</tr>
<tr>
<td align="left">2XX</td>
<td align="left">Success（成功状态码）</td>
<td align="left">请求正常处理完毕</td>
</tr>
<tr>
<td align="left">3XX</td>
<td align="left">Redirection（重定向状态码）</td>
<td align="left">需要进行附加操作以完成请求</td>
</tr>
<tr>
<td align="left">4XX</td>
<td align="left">Client Error（客户端错误状态码）</td>
<td align="left">服务器无法处理请求</td>
</tr>
<tr>
<td align="left">5XX</td>
<td align="left">Server Error(服务器错误状态码)</td>
<td align="left">服务器处理请求出错</td>
</tr>
</tbody></table>
<h2 id="HTTP协议架构中的转发功能节点"><a href="#HTTP协议架构中的转发功能节点" class="headerlink" title="HTTP协议架构中的转发功能节点"></a>HTTP协议架构中的转发功能节点</h2><ul>
<li>代理：代理服务器的基本行为是接收客户端发送的请求转发给其他服务器，不改变请求URI。分为两类：<ol>
<li>缓存代理：缓存内容。</li>
<li>透明代理：纯粹内容转发，不做缓存。</li>
</ol>
</li>
<li>网关：网关为通信链路上的服务器提供非HTTP协议连接，例如与信用卡结算系统联动，数据库联动等。</li>
<li>隧道：隧道的建立能够确保客户端与服务器之间安全的通信。也能扩展HTTP通信协议，例如支持推送功能等等。</li>
</ul>
<h1 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h1><h2 id="HTTP协议的缺点："><a href="#HTTP协议的缺点：" class="headerlink" title="HTTP协议的缺点："></a>HTTP协议的缺点：</h2><ol>
<li>明文信息会被窃听；</li>
<li>无法验证通信方身份，会被伪装；</li>
<li>无法验证报文的完整性，会被篡改。</li>
</ol>
<h2 id="HTTP-over-SSL-x2F-TSL"><a href="#HTTP-over-SSL-x2F-TSL" class="headerlink" title="HTTP over SSL&#x2F;TSL"></a>HTTP over SSL&#x2F;TSL</h2><p>SSL&#x2F;TSL协议独立与HTTP协议，存在于HTTP和TCP协议之间，在建立HTTP连接之前，先建立SSL通信机制，交换加密密钥，从而在HTTP通信报文可以进行加密传输。</p>
<p>HTTPS 协议通信握手&#x2F;分手协议步骤：</p>
<p><img src="/HTTP-protocol-introduction%5CHTTPS.jpg" alt="HTTPS"></p>
<p>握手主要分为4个阶段:</p>
<ol>
<li>SSL证书请求，及公钥获取。&lt;&#x3D; 由于非对称加密机制的效率较低，安全性高，只用作密钥交互。</li>
<li>客户端密钥加密发送。</li>
<li>服务器端密钥确认。</li>
<li>数据传输… &lt;&#x3D; 数据传输阶段的加密是基于协商确定的对称密钥发送，效率较高。</li>
</ol>
<h1 id="WebSocket协议"><a href="#WebSocket协议" class="headerlink" title="WebSocket协议"></a>WebSocket协议</h1><p>Web浏览器支持的全双工通信协议，在HTTP部首加入upgrade：websocket字段，服务器通过返回状态码101 swtiching protocols响应连接，一旦服务器与客户端建立WebSocket协议的通信连接，之后所有的通信都用这个专用协议进行。</p>
<ul>
<li>推送功能： 服务器可以直接发送数据到客户端。</li>
<li>减少通信量：保持连接的状态减少HTTP协议的连接开销。</li>
</ul>
<h1 id="用户认证问题"><a href="#用户认证问题" class="headerlink" title="用户认证问题"></a>用户认证问题</h1><p>HTTP&#x2F;1.1常见的认证方式如下：</p>
<ul>
<li>BASIC认证：直接提交用户名密码完成认证。<br><img src="/HTTP-protocol-introduction%5CBASIC.jpg" alt="BASIC"></li>
<li>DIGEST认证：客户端根据服务器端的质询码生成响应码完成认证。<br><img src="/HTTP-protocol-introduction%5CDIGEST.jpg" alt="DIGEST"></li>
<li>SSL客户端认证：凭借HTTPS的客户端认证证书完成认证。</li>
<li>FormBase认证：在用户登录信息以表单形式提交后，服务器端发放Session ID用于用户认证状态的绑定和保持。<br><img src="/HTTP-protocol-introduction%5CFORMBASED.jpg" alt="FORM"></li>
<li>Kerberos认证：</li>
<li>NTLM认证：</li>
<li>SSO认证：</li>
</ul>
<h1 id="Web安全问题"><a href="#Web安全问题" class="headerlink" title="Web安全问题"></a>Web安全问题</h1><ul>
<li>跨站脚本工具XSS：通过执行非法HTML标签&#x2F;JS脚本进行攻击。<ol>
<li>表单中插入非法标签执行JS脚本。</li>
<li>基于用户Cookie的窃取攻击</li>
</ol>
</li>
<li>SQL注入攻击：通过加入SQL结束符，强制加入SQL语句执行。</li>
<li>OS命令攻击:通过Shell脚本注入执行系统命令。</li>
<li>HTTP部首注入攻击：通过访问URL加入换行符，注入HTTP首部字段进行攻击。<ol>
<li>Cookie设置字段生效。</li>
<li>HTTP响应截断攻击，强制显示伪造内容。</li>
</ol>
</li>
<li>邮件首部注入攻击: <ol>
<li>BCC邮件泄露。</li>
</ol>
</li>
<li>目录遍历攻击: 访问无疑公开的文件目录。</li>
<li>远程文件包含漏洞：引入其他包，例如System包进行代码污染。</li>
</ul>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://sunnyhll.github.io/2019/04/24/Java/Java-Xml-Libraries/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="果核&肉肉">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="微观天下">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 微观天下">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/04/24/Java/Java-Xml-Libraries/" class="post-title-link" itemprop="url">Java Xml Libraries</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-04-24 22:14:19" itemprop="dateCreated datePublished" datetime="2019-04-24T22:14:19+08:00">2019-04-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2019-05-06 22:15:35" itemprop="dateModified" datetime="2019-05-06T22:15:35+08:00">2019-05-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>本文描述了当前主流的Java Xml libraries，以及对比区别。</p>
<blockquote>
<p>下文摘取自<a target="_blank" rel="noopener" href="https://www.baeldung.com/java-xml-libraries">https://www.baeldung.com/java-xml-libraries</a></p>
</blockquote>
<ul>
<li><p>SAX: It is an event based parsing API, it provides a low level access, is memory efficient and faster than DOM since it doesn’t load the whole document tree in memory but it doesn’t provide support for navigation like the one provided by XPath, although it is more efficient it is harder to use too.</p>
</li>
<li><p>DOM(DOM4J and JDOM): It as model based parser that loads a tree structure document in memory, so we have the original elements order, we can navigate our document both directions, it provides an API for reading and writing, it offers XML manipulation and it is very easy to use although the price is high strain on memory resources.</p>
</li>
<li><p>StAX: It offers the ease of DOM and the efficiency of SAX but it lacks of some functionality provided by DOM like XML manipulation and it only allows us to navigate the document forward.</p>
</li>
<li><p>JAXB: It allows us to navigate the document in both directions, it is more efficient than DOM, it allows conversion from XML to java types and it supports XML manipulation but it can only parse a valid XML document.</p>
</li>
</ul>
<p><img src="/2019/04/24/Java/Java-Xml-Libraries/JavaXmlLibs.png" alt="JavaXmlLibs"></p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://sunnyhll.github.io/2019/04/12/Runbooks/Office-365-Addin-development-guide/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="果核&肉肉">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="微观天下">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 微观天下">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/04/12/Runbooks/Office-365-Addin-development-guide/" class="post-title-link" itemprop="url">Office 365 Addin development guide</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-04-12 22:16:53" itemprop="dateCreated datePublished" datetime="2019-04-12T22:16:53+08:00">2019-04-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-02-08 12:35:10" itemprop="dateModified" datetime="2024-02-08T12:35:10+08:00">2024-02-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Runbooks/" itemprop="url" rel="index"><span itemprop="name">Runbooks</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>This is a guide for how to develop Office 365 cross platform addin.</p>
<h1 id="Front-end-UI-framework"><a href="#Front-end-UI-framework" class="headerlink" title="Front end UI framework"></a>Front end UI framework</h1><p>Microsoft has provided offical Office UI framework: Office Fabric UI. The office site is at <a target="_blank" rel="noopener" href="https://developer.microsoft.com/en-us/fabric">https://developer.microsoft.com/en-us/fabric</a>. The are three directions of the UI project future roadmap. All the three projects are implementation of UI components, demos are available at <a target="_blank" rel="noopener" href="https://developer.microsoft.com/en-us/fabric#/components">https://developer.microsoft.com/en-us/fabric#/components</a>.</p>
<ol>
<li>Fabric React (Official support)</li>
<li>AngularJS (Community version, no updates)</li>
<li>Fabric iOS</li>
<li>Fabric JS (Stop support from MSFT)</li>
</ol>
<p>New UI design sytem is called fluent, the website is at <a target="_blank" rel="noopener" href="https://www.microsoft.com/design/fluent/">https://www.microsoft.com/design/fluent/</a>. It can help let developer know how to design an Windows style application UI and the guide of UWP web app design. </p>
<p>Fabric.js is an open source js framework using canvas as the basic style of UI components, the official site is at <a target="_blank" rel="noopener" href="http://fabricjs.com/">http://fabricjs.com/</a>.</p>
<h2 id="Useful-links"><a href="#Useful-links" class="headerlink" title="Useful links:"></a>Useful links:</h2><p>Directly reuse existing Microsoft designed and implemented components is very convinient as long as your application can work well with these codes.</p>
<ul>
<li>Office UI Fabric Core (Style and fonts): <a target="_blank" rel="noopener" href="https://github.com/OfficeDev/office-ui-fabric-core">https://github.com/OfficeDev/office-ui-fabric-core</a></li>
<li>Office UI Fabric React (Full components): <a target="_blank" rel="noopener" href="https://github.com/OfficeDev/office-ui-fabric-react">https://github.com/OfficeDev/office-ui-fabric-react</a></li>
<li>Office UI Fabric JS (Full components in JS): <a target="_blank" rel="noopener" href="https://github.com/OfficeDev/office-ui-fabric-js/">https://github.com/OfficeDev/office-ui-fabric-js/</a></li>
</ul>
<p>Except Windows style UI frameworks, there are other frameworks using morden components:</p>
<ul>
<li>Material-UI: <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/b3cfaca94596">https://www.jianshu.com/p/b3cfaca94596</a> , <a target="_blank" rel="noopener" href="https://material-ui.com/getting-started/example-projects/">https://material-ui.com/getting-started/example-projects/</a></li>
<li>PrimeNG: <a target="_blank" rel="noopener" href="https://www.primefaces.org/primeng">https://www.primefaces.org/primeng</a></li>
</ul>
<h1 id="Front-end-Office-js-framework"><a href="#Front-end-Office-js-framework" class="headerlink" title="Front end Office.js framework"></a>Front end Office.js framework</h1><p>Office.js is the JavaScript based Office model provided by Microsoft, there are also Excel-15.js or Outlook-15.js for application respectively.</p>
<h2 id="Office-JavaScript-API-object-model"><a href="#Office-JavaScript-API-object-model" class="headerlink" title="Office JavaScript API object model"></a>Office JavaScript API object model</h2><p>This doc <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/office/dev/add-ins/develop/office-javascript-api-object-model">https://docs.microsoft.com/en-us/office/dev/add-ins/develop/office-javascript-api-object-model</a> explains the API model for new O365 addin JS model.</p>
<p>The object is still under active development, there are more and more new features added, reading the documents can get the updated information. As for now, there are below bullet points:</p>
<p><img src="/2019/04/12/Runbooks/Office-365-Addin-development-guide/AddinJSModel.PNG" alt="JSAddinFeatures"></p>
<p>This is also guide for how to develop Addin with Angular front end. <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/office/dev/add-ins/develop/add-ins-with-angular2">https://docs.microsoft.com/en-us/office/dev/add-ins/develop/add-ins-with-angular2</a></p>
<p>Office appication has its own object model, so developers can read the related documents for detailed guide.</p>
<h2 id="Outlook-Backend-service"><a href="#Outlook-Backend-service" class="headerlink" title="Outlook Backend service"></a>Outlook Backend service</h2><p>Except the general Office JS API model, Outlook has its own API. The development guide is at <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/outlook/add-ins/">https://docs.microsoft.com/en-us/outlook/add-ins/</a>. </p>
<h3 id="Manifest-version-and-corresponding-clients-support"><a href="#Manifest-version-and-corresponding-clients-support" class="headerlink" title="Manifest version and corresponding clients support"></a>Manifest version and corresponding clients support</h3><p><img src="/2019/04/12/Runbooks/Office-365-Addin-development-guide/ClientSupport.PNG" alt="ClientSupport"></p>
<p>Troubleshooting manifest file <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/office/dev/add-ins/testing/troubleshoot-manifest#to-use-the-office-add-in-validator-to-validate-your-manifest">here</a></p>
<h3 id="Outlook-Web-Addin-Catalogs"><a href="#Outlook-Web-Addin-Catalogs" class="headerlink" title="Outlook Web Addin Catalogs"></a>Outlook Web Addin Catalogs</h3><p>Outlook Addin has its own concepts and there are many aspects:</p>
<p><img src="/2019/04/12/Runbooks/Office-365-Addin-development-guide/OutlookConcepts.PNG" alt="OutlookCatalog"></p>
<h3 id="Sample-Addins-for-Outlook"><a href="#Sample-Addins-for-Outlook" class="headerlink" title="Sample Addins for Outlook"></a>Sample Addins for Outlook</h3><p><a target="_blank" rel="noopener" href="https://developer.microsoft.com/zh-cn/outlook/gallery/?filterBy=Outlook,Samples,Add-ins">https://developer.microsoft.com/zh-cn/outlook/gallery/?filterBy=Outlook,Samples,Add-ins</a> </p>
<h1 id="Other-Office-Web-Addin-Demos"><a href="#Other-Office-Web-Addin-Demos" class="headerlink" title="Other Office Web Addin Demos"></a>Other Office Web Addin Demos</h1><ul>
<li>Word Style Checker: <a target="_blank" rel="noopener" href="https://github.com/OfficeDev/Word-Add-in-Angular2-StyleChecker">https://github.com/OfficeDev/Word-Add-in-Angular2-StyleChecker</a></li>
<li>Word task pane add-in: <a target="_blank" rel="noopener" href="https://github.com/OfficeDev/Office-Add-in-Fabric-UI-Sample">https://github.com/OfficeDev/Office-Add-in-Fabric-UI-Sample</a></li>
<li>Outlook Addin: <a target="_blank" rel="noopener" href="https://github.com/OfficeDev/outlook-add-in-attachments-demo">https://github.com/OfficeDev/outlook-add-in-attachments-demo</a></li>
<li>Word dialog Addin: <a target="_blank" rel="noopener" href="https://github.com/OfficeDev/Office-Add-in-Dialog-API-Simple-Example">https://github.com/OfficeDev/Office-Add-in-Dialog-API-Simple-Example</a></li>
</ul>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://sunnyhll.github.io/2019/03/29/Runbooks/Git-best-practices/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="果核&肉肉">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="微观天下">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 微观天下">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/03/29/Runbooks/Git-best-practices/" class="post-title-link" itemprop="url">Git best practices</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-03-29 22:37:46" itemprop="dateCreated datePublished" datetime="2019-03-29T22:37:46+08:00">2019-03-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-10 21:14:25" itemprop="dateModified" datetime="2025-02-10T21:14:25+08:00">2025-02-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Runbooks/" itemprop="url" rel="index"><span itemprop="name">Runbooks</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Git-基本操作"><a href="#Git-基本操作" class="headerlink" title="Git 基本操作"></a>Git 基本操作</h1><h2 id="创建Git仓库"><a href="#创建Git仓库" class="headerlink" title="创建Git仓库"></a>创建Git仓库</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>

<h2 id="查看代码情况"><a href="#查看代码情况" class="headerlink" title="查看代码情况"></a>查看代码情况</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br><span class="line">git diff &#123;filepath&#125;</span><br></pre></td></tr></table></figure>

<h2 id="提交代码"><a href="#提交代码" class="headerlink" title="提交代码"></a>提交代码</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> &#123;clone.git&#125;</span><br><span class="line">git add -A</span><br><span class="line">git commit -m <span class="string">&quot;message&quot;</span></span><br><span class="line">git push orgin master</span><br></pre></td></tr></table></figure>

<h2 id="保存-x2F-恢复临时修改文件"><a href="#保存-x2F-恢复临时修改文件" class="headerlink" title="保存&#x2F;恢复临时修改文件"></a>保存&#x2F;恢复临时修改文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git stash</span><br><span class="line">git checkout stash@&#123;0&#125; -- &#123;filepath&#125;</span><br></pre></td></tr></table></figure>

<h2 id="读取文件历史版本"><a href="#读取文件历史版本" class="headerlink" title="读取文件历史版本"></a>读取文件历史版本</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout &#123;commithash&#125; -- &#123;filepath&#125;</span><br></pre></td></tr></table></figure>

<h2 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git tag -a v1.0  <span class="comment"># tag most recent commit</span></span><br><span class="line">git tag -a v0.9 85fc7e7 <span class="comment"># tag on a specific commit</span></span><br><span class="line">git tag <span class="comment"># view tags</span></span><br></pre></td></tr></table></figure>

<h1 id="Pull-x2F-Fork工作流"><a href="#Pull-x2F-Fork工作流" class="headerlink" title="Pull&#x2F;Fork工作流"></a>Pull&#x2F;Fork工作流</h1><ol>
<li>fork from the github</li>
<li>clone to local and commit changes<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> &#123;clone.git&#125;</span><br><span class="line">git checkout -b feature</span><br><span class="line"><span class="comment"># make changes to this branch</span></span><br><span class="line">git add -p</span><br><span class="line">git commit -m <span class="string">&quot;feature message&quot;</span></span><br><span class="line">git push origin feature</span><br></pre></td></tr></table></figure></li>
<li>rebase commits after remote master<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git remote add upstream &#123;remote.git&#125;</span><br><span class="line">git pull upstream master</span><br><span class="line"><span class="comment"># no changes on master, then automatically git history is updated</span></span><br><span class="line">git checkout feature</span><br><span class="line">git pull --rebase origin master</span><br><span class="line"><span class="comment"># apply changes from origin master to feature newly commits</span></span><br><span class="line">git push origin feature --force</span><br></pre></td></tr></table></figure></li>
<li>raise pull request for code review</li>
</ol>
<h1 id="提交历史管理"><a href="#提交历史管理" class="headerlink" title="提交历史管理"></a>提交历史管理</h1><h2 id="缩减冗余commit-log"><a href="#缩减冗余commit-log" class="headerlink" title="缩减冗余commit log"></a>缩减冗余commit log</h2><ul>
<li>通过rebase修改commit history</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># rewrite last 10 commit logs</span></span><br><span class="line">git rebase -i HEAD~10 feature</span><br><span class="line">git push orign feature --force</span><br></pre></td></tr></table></figure>

<ul>
<li>通过squash命令压缩commit history</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD~12 <span class="comment"># 将git指针定位到历史版本</span></span><br><span class="line"></span><br><span class="line">git merge --squash HEAD@&#123;1&#125; <span class="comment"># 从该点开始merge到最新的版本</span></span><br><span class="line"></span><br><span class="line">git commmit -m <span class="string">&quot;xxx&quot;</span> <span class="comment"># 提交commit重写</span></span><br><span class="line"></span><br><span class="line">git push origin master --force <span class="comment"># 强制改写历史</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h1><h2 id="创建新分支"><a href="#创建新分支" class="headerlink" title="创建新分支"></a>创建新分支</h2><p>在创建新的local分支时，也可以添加commit hash告诉git分支最新的HEAD指向</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b feature</span><br><span class="line"><span class="comment"># create a branch based on current branch</span></span><br></pre></td></tr></table></figure>

<h2 id="切换分支-x2F-从Detached-HEAD切换"><a href="#切换分支-x2F-从Detached-HEAD切换" class="headerlink" title="切换分支&#x2F;从Detached HEAD切换"></a>切换分支&#x2F;从Detached HEAD切换</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout feature</span><br></pre></td></tr></table></figure>

<h2 id="删除本地分支"><a href="#删除本地分支" class="headerlink" title="删除本地分支"></a>删除本地分支</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch -d feature</span><br><span class="line">git branch -D feature <span class="comment"># force delete</span></span><br></pre></td></tr></table></figure>

<h2 id="删除远程分支"><a href="#删除远程分支" class="headerlink" title="删除远程分支"></a>删除远程分支</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push orgin --delete feature</span><br></pre></td></tr></table></figure>

<h2 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git merge feature</span><br><span class="line"><span class="comment"># merge changes from feature branch to current master branch</span></span><br></pre></td></tr></table></figure>

<h2 id="CherryPick别的分支commit-x2F-branch"><a href="#CherryPick别的分支commit-x2F-branch" class="headerlink" title="CherryPick别的分支commit&#x2F;branch"></a>CherryPick别的分支commit&#x2F;branch</h2><p>在需要apply的分支上保证没有unstaged change，运行如下命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git cherry-pick &lt;commitHash&gt;/&lt;feature branch name&gt;</span><br></pre></td></tr></table></figure>
<h2 id="github-migration-from-port-22-to-443"><a href="#github-migration-from-port-22-to-443" class="headerlink" title="github migration from port 22 to 443"></a>github migration from port 22 to 443</h2><p>github服务器已经将22端口关闭，git工具需要访问ssh.github.com:443而不是默认的github.com:22 SSH端口。</p>
<p>需要更新~&#x2F;.ssh&#x2F;config文件如下：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Host github.com</span><br><span class="line">HostName ssh.github.com</span><br><span class="line">User git</span><br><span class="line">Port 443</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure>

<p>测试方法</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/3/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/5/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">果核&肉肉</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>


  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":"forest","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/9.4.3/mermaid.min.js","integrity":"sha256-e0o3JYsdjqKajf9eOe22FhioYSz9WofRY4dLKo3F6do="}}</script>
  <script src="/js/third-party/tags/mermaid.js"></script>




  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





<!-- hexo injector body_end start --><script>
// Check that service workers are supported
if ('serviceWorker' in navigator) {
  // Use the window load event to keep the page load performant
  window.addEventListener('load', () => {
    navigator.serviceWorker.register('/sw.js');
  });
}
</script>
<!-- hexo injector body_end end --></body>
</html>
