<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2021年度个人规划</title>
    <url>/2021/04/12/2021%E5%B9%B4%E5%BA%A6%E4%B8%AA%E4%BA%BA%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<h1 id="2021-个人小目标"><a href="#2021-个人小目标" class="headerlink" title="2021 个人小目标"></a>2021 个人小目标</h1><ul>
<li style="list-style: none"><input type="checkbox"> 体重管理，达成55kg<ul>
<li style="list-style: none"><input type="checkbox" checked> Q2完成每周跑步回家两次</li>
</ul>
</li>
<li style="list-style: none"><input type="checkbox"> 睡眠管理，生活习惯调整为10点睡觉，6点起床<ul>
<li style="list-style: none"><input type="checkbox" checked> Q1睡眠管理完成良好</li>
<li style="list-style: none"><input type="checkbox"> Q2睡眠管理完成良好</li>
</ul>
</li>
<li style="list-style: none"><input type="checkbox"> 饮食管理,减少吃垃圾食品次数,减少鼻炎复发<ul>
<li style="list-style: none"><input type="checkbox" checked> Q2吃炸鸡、辣椒较频繁，导致上火严重鼻炎一次</li>
<li style="list-style: none"><input type="checkbox"> Q3每个月炸鸡次数不超过一次，避免鼻炎复发</li>
</ul>
</li>
<li style="list-style: none"><input type="checkbox"> 时间管理，提高每日效率，平衡工作，家庭，和个人的需求<ul>
<li style="list-style: none"><input type="checkbox" checked> 减少平均每天新浪微博时间至30分钟</li>
<li style="list-style: none"><input type="checkbox"> 减少平均每天Youtube时间至30分钟</li>
<li style="list-style: none"><input type="checkbox"> 保持平均每天看书时间至30分钟</li>
<li style="list-style: none"><input type="checkbox"> 阅读《哈佛时间管理课》</li>
<li style="list-style: none"><input type="checkbox" checked> 工作效率提升<ul>
<li style="list-style: none"><input type="checkbox" checked> 阅读《番茄工作法》</li>
<li style="list-style: none"><input type="checkbox" checked> 实践执行番茄钟时间管理</li>
</ul>
</li>
</ul>
</li>
<li style="list-style: none"><input type="checkbox"> 个人充电：阅读书籍10本<ul>
<li>技术相关书籍：<ul>
<li style="list-style: none"><input type="checkbox" checked> 阅读《Electron实战》</li>
<li style="list-style: none"><input type="checkbox"> 阅读《快学Scala》</li>
<li style="list-style: none"><input type="checkbox"> 阅读《Python量化交易》</li>
<li style="list-style: none"><input type="checkbox"> 大型网站架构演进</li>
</ul>
</li>
<li>其他书籍：<ul>
<li style="list-style: none"><input type="checkbox"> 阅读《金字塔法则》</li>
<li style="list-style: none"><input type="checkbox" checked> 阅读《高敏感天赋》系列，深入了解自己</li>
<li style="list-style: none"><input type="checkbox"> 阅读《高敏感天赋》系列二，明确具体实践</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="个人感悟"><a href="#个人感悟" class="headerlink" title="个人感悟"></a>个人感悟</h1><ol>
<li><p>这是人的社会<br>与过去工作的五年相比，今年除了工作量上的增加也有了更多超出技术本身的感悟。主要源于过去六个月在和市场打交道的过程中，我更加意识到人力资源本身也是有供求属性的。发展本身一但被赋与市场化属性但会发生性质上的变化。</p>
</li>
<li><p>《高敏感是种天赋》读后感</p>
</li>
</ol>
<p>这是一本讲述细腻情感的书籍，首先从一个高敏感人的视角描述了内心世界，然后着重讲述了内心平静的技巧：</p>
<ul>
<li><p>减少内耗：</p>
<ul>
<li>避免低自尊陷阱，可以尝试客观评估自己能力回归情绪</li>
<li>避免过度內疚，可以合理分析对方情绪影响因子</li>
<li>避免羞耻感，这只是过去创伤遗留下的焦虑，需要新的体验刷新记忆</li>
</ul>
</li>
<li><p>疏理自己的生活，愉悅自己，与自己和解</p>
<ul>
<li>认可自己的思维方式，喜欢在事情发生前做好最坏打算，并且明白别人一般不会这么做</li>
<li>不喜欢过度纷扰环境，喜欢专心干好一件事，可以避免来获得内心平静</li>
<li>满足自己，关爱自己<ul>
<li>了解发现自己的需求，满足自己</li>
<li>给自己独处机会</li>
<li>转移注意力，放空</li>
<li>倾诉，释放压力</li>
<li>承认自己的缺陷，关注优势发展</li>
</ul>
</li>
</ul>
</li>
<li>沟通技巧：善于利用共情能力</li>
<li>处理冲突：明确表达观点</li>
</ul>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>肉肉</tag>
      </tags>
  </entry>
  <entry>
    <title>Angular 5 Components &amp; Templates</title>
    <url>/2018/10/02/Angular-5-template-syntax/</url>
    <content><![CDATA[<h1 id="Angular-binding-brief-introduction"><a href="#Angular-binding-brief-introduction" class="headerlink" title="Angular binding brief introduction"></a>Angular binding brief introduction</h1><p>This blog is talking about the template syntax of Angular 5. The reference topic is at <a href="https://angular.io/guide/template-syntax" target="_blank" rel="noopener">https://angular.io/guide/template-syntax</a>.</p>
<h2 id="Angular-one-way-binding-with-DOM-elements"><a href="#Angular-one-way-binding-with-DOM-elements" class="headerlink" title="Angular one-way binding with DOM elements"></a>Angular one-way binding with DOM elements</h2><p>For DOM elmenets that does simple display, Angular one-way binding is very useful. For example, pure text, or un-editable tables, one-way binding can quick get rendered by directly binding the Angular variable or using *ngFor iteration. There are three examples of one-way binding in the html template. THe binding objective can be expression, which does not change variables.</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello &#123;&#123;username&#125;&#125;.<span class="tag">&lt;/<span class="name">p</span>&gt;</span> <span class="comment">&lt;!-- pure one-way interpolation with &#123;&#123;&#125;&#125; syntax--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> [<span class="attr">value</span>]=<span class="string">"username"</span>&gt;</span> <span class="comment">&lt;!-- DOM property with [] binding --&gt;</span></span><br><span class="line">bind-target="expression" <span class="comment">&lt;!-- bind- prefix target binding--&gt;</span></span><br></pre></td></tr></table></figure>
<p>** Remember to user [] brackets to make the DOM property actively linked with Angular variables, otherwise the binding is worked as string type initialization only.</p>
<h2 id="Angular-two-way-binding-with-DOM-elements"><a href="#Angular-two-way-binding-with-DOM-elements" class="headerlink" title="Angular two-way binding with DOM elements"></a>Angular two-way binding with DOM elements</h2><p>For DOM elements that also can have user interactions like input elements, select elments, two-way binding or event binding is required to allow Angular know about the user action. The grammar to bind a two-way variable is to use [(target)].</p>
<p>There are some examples of Angular two-way binding:<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> [(<span class="attr">ngModel</span>)]=<span class="string">"username"</span>&gt;</span> <span class="comment">&lt;!-- property, like ngModel for form elements, with [()] syntax--&gt;</span></span><br><span class="line">bindon-target="expression" <span class="comment">&lt;!-- bindon- prefix target two-way binding--&gt;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="Angular-event-binding-with-DOM-elements"><a href="#Angular-event-binding-with-DOM-elements" class="headerlink" title="Angular event binding with DOM elements"></a>Angular event binding with DOM elements</h2><p>Some DOM elements are not interact with text but events link click or text change, Angular also provides sytax for event binding so it can track user’s behavior based on DOM events. Vairables, like #event template input variable (let here), and template reference variable (#heroForm), which can be passed to the event handlers. The grammar to bind a event of a DOM is to use parenthesis with Angular event like (click). Event handlers can only be statements like methods of the component instance.</p>
<p>There are some examples of Angular event bindings:<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">(click)="click($event)" <span class="comment">&lt;!-- use DOM property binding with () syntax--&gt;</span></span><br><span class="line">on-target="statement"  <span class="comment">&lt;!-- use on- prefix target binding --&gt;</span></span><br></pre></td></tr></table></figure></p>
<h1 id="Angular-template-binding-targets"><a href="#Angular-template-binding-targets" class="headerlink" title="Angular template binding targets"></a>Angular template binding targets</h1><p>It’s not hard to see, binding targets in Angular includes HTML properties and events as below table.</p>
<table>
<thead>
<tr>
<th style="text-align:left">Type</th>
<th style="text-align:left">Target</th>
<th style="text-align:left">Examples</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Property</td>
<td style="text-align:left">Element property,<br>Component property,<br>Directive property</td>
<td style="text-align:left"><code>&lt;img [src]=&quot;heroImageUrl&quot;&gt;</code><br><code>&lt;app-hero-detail [hero]=&quot;currentHero&quot;&gt;&lt;/app-hero-detail&gt;</code><br><code>&lt;div [ngClass]=&quot;{&#39;special&#39;: isSpecial}&quot;&gt;&lt;/div&gt;</code></td>
</tr>
<tr>
<td style="text-align:left">Event</td>
<td style="text-align:left">Element event,<br>Component event,<br>Directive event</td>
<td style="text-align:left"><code>&lt;button (click)=&quot;onSave()&quot;&gt;Save&lt;/button&gt;</code><br><code>&lt;app-hero-detail (deleteRequest)=&quot;deleteHero()&quot;&gt;&lt;/app-hero-detail&gt;</code><br><code>&lt;div (myClick)=&quot;clicked=$event&quot; clickable&gt;click me&lt;/div&gt;</code></td>
</tr>
<tr>
<td style="text-align:left">Two-way</td>
<td style="text-align:left">Event and property</td>
<td style="text-align:left"><code>&lt;input [(ngModel)]=&quot;name&quot;&gt;</code></td>
</tr>
<tr>
<td style="text-align:left">Attributes</td>
<td style="text-align:left">Attribute (the exception)</td>
<td style="text-align:left"><code>&lt;button [attr.aria-label]=&quot;help&quot;&gt;help&lt;/button&gt;</code></td>
</tr>
<tr>
<td style="text-align:left">Class</td>
<td style="text-align:left">class property</td>
<td style="text-align:left"><code>&lt;div [class.special]=&quot;isSpecial&quot;&gt;Special&lt;/div&gt;</code></td>
</tr>
<tr>
<td style="text-align:left">Style</td>
<td style="text-align:left">style property</td>
<td style="text-align:left"><code>&lt;button [style.color]=&quot;isSpecial ? &#39;red&#39; : &#39;green&#39;&quot;&gt;</code></td>
</tr>
</tbody>
</table>
<p>Besides, Angular also supports built-in directives as below table.</p>
<table>
<thead>
<tr>
<th style="text-align:left">Directive Type</th>
<th style="text-align:left">Target</th>
<th style="text-align:left">Use Case</th>
<th style="text-align:left">Examples</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Attribute</td>
<td style="text-align:left">NgClass</td>
<td style="text-align:left">add and remove a set of CSS classes</td>
<td style="text-align:left"><code>&lt;!-- toggle the &quot;special&quot; class on/off with a property --&gt;</code><br><code>&lt;div [class.special]=&quot;isSpecial&quot;&gt;The class binding is special&lt;/div&gt;</code></td>
</tr>
<tr>
<td style="text-align:left">Attribute</td>
<td style="text-align:left">NgStyle</td>
<td style="text-align:left">add and remove a set of HTML styles</td>
<td style="text-align:left"><code>&lt;button [style.color]=&quot;isSpecial ? &#39;red&#39; : &#39;green&#39;&quot;&gt;</code></td>
</tr>
<tr>
<td style="text-align:left">Attribute</td>
<td style="text-align:left">NgModel</td>
<td style="text-align:left">two-way data binding to an HTML form element</td>
<td style="text-align:left"><code>&lt;input [(ngModel)]=&quot;name&quot;&gt;</code></td>
</tr>
<tr>
<td style="text-align:left">Structural</td>
<td style="text-align:left">NgIf</td>
<td style="text-align:left">conditionally add or remove an element from the DOM</td>
<td style="text-align:left"><code>&lt;app-hero-detail *ngIf=&quot;isActive&quot;&gt;&lt;/app-hero-detail&gt;</code></td>
</tr>
<tr>
<td style="text-align:left">Structural</td>
<td style="text-align:left">NgSwitch</td>
<td style="text-align:left">a set of directives that switch among alternative views</td>
<td style="text-align:left"><code>&lt;div *ngFor=&quot;let hero of heroes&quot;&gt;&lt;/div&gt;</code></td>
</tr>
<tr>
<td style="text-align:left">Structural</td>
<td style="text-align:left">NgForOf</td>
<td style="text-align:left">repeat a template for each item in a list</td>
<td style="text-align:left"><code>&lt;div [ngSwitch]=&quot;currentHero.emotion&quot;&gt;</code><br><code>&lt;app-happy-hero    *ngSwitchCase=&quot;&#39;happy&#39;&quot;    [hero]=&quot;currentHero&quot;&gt;&lt;/app-happy-hero&gt;</code><br><code>&lt;app-sad-hero      *ngSwitchCase=&quot;&#39;sad&#39;&quot;      [hero]=&quot;currentHero&quot;&gt;&lt;/app-sad-hero&gt;</code><br><code>&lt;/div&gt;</code></td>
</tr>
</tbody>
</table>
<h2 id="Template-reference-variables"><a href="#Template-reference-variables" class="headerlink" title="Template reference variables"></a>Template reference variables</h2><p>A template reference variable is often a reference to a DOM element within a template. It can also be a reference to an Angular component or directive or a web component.<br>Use the hash symbol (#) to declare a reference variable. The #phone declares a phone variable on an <code>&lt;input&gt;</code> element.</p>
<p>Example:<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> #<span class="attr">phone</span> <span class="attr">placeholder</span>=<span class="string">"phone number"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- lots of other elements --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- phone refers to the input element; pass its `value` to an event handler --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> (<span class="attr">click</span>)=<span class="string">"callPhone(phone.value)"</span>&gt;</span>Call<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="Template-expression-operators"><a href="#Template-expression-operators" class="headerlink" title="Template expression operators"></a>Template expression operators</h2><p>The template expression language employs a subset of JavaScript syntax supplemented with a few special operators for specific scenarios. The next sections cover two of these operators: pipe and safe navigation operator.</p>
<h3 id="The-pipe-operator"><a href="#The-pipe-operator" class="headerlink" title="The pipe operator ( | )"></a>The pipe operator ( | )</h3><p>Angular pipes are a good choice for small transformations such as these. Pipes are simple functions that accept an input value and return a transformed value. They’re easy to apply within template expressions, using the pipe operator (|):</p>
<p>Example:<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Title through uppercase pipe: &#123;&#123;title | uppercase&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="The-safe-navigation-operator-and-null-property-paths"><a href="#The-safe-navigation-operator-and-null-property-paths" class="headerlink" title="The safe navigation operator ( ?. ) and null property paths"></a>The safe navigation operator ( ?. ) and null property paths</h3><p>The Angular safe navigation operator (?.) is a fluent and convenient way to guard against null and undefined values in property paths. Here it is, protecting against a view render failure if the currentHero is null.</p>
<p>Example:<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">The current hero's name is &#123;&#123;currentHero?.name&#125;&#125;</span><br></pre></td></tr></table></figure></p>
<p>The Angular non-null assertion operator (!) serves the same purpose in an Angular template.</p>
<p>Example:<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--No hero, no text --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> *<span class="attr">ngIf</span>=<span class="string">"hero"</span>&gt;</span></span><br><span class="line">  The hero's name is &#123;&#123;hero!.name&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="The-any-type-cast-function-any"><a href="#The-any-type-cast-function-any" class="headerlink" title="The $any type cast function ($any(  ))"></a>The $any type cast function ($any( <expression> ))</expression></h3><p>Sometimes a binding expression will be reported as a type error and it is not possible or difficult to fully specify the type. To silence the error, you can use the $any cast function to cast the expression to the any type.</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Accessing an undeclared member --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  The hero's marker is &#123;&#123;$any(hero).marker&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="Angular-binding-different-component-properties"><a href="#Angular-binding-different-component-properties" class="headerlink" title="Angular binding different component properties"></a>Angular binding different component properties</h1><p>We usually binding a template to its own component class. In such binding expressions, the component’s property or method is to the right of the (=).</p>
<p>The Angular compiler won’t bind to properties of a different component unless they are Input or Output properties. You can’t use the TypeScript public and private access modifiers to shape the component’s public binding API.</p>
<h2 id="Declaring-Input-and-Output-properties"><a href="#Declaring-Input-and-Output-properties" class="headerlink" title="Declaring Input and Output properties"></a>Declaring Input and Output properties</h2><p>An Input property is a settable property annotated with an @Input decorator. Values flow into the property when it is data bound with a property binding<br>An Output property is an observable property annotated with an @Output decorator. The property almost always returns an Angular EventEmitter. Values flow out of the component as events bound with an event binding.</p>
<p>Example:</p>
<p>In the sample for this guide, the bindings to HeroDetailComponent do not fail because the data bound properties are annotated with @Input() and @Output() decorators.</p>
<p>In src/app/app.component.html file, below code will through compile error as template of app component does not recognize the property of hero-detail component:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">app-hero-detail</span> [<span class="attr">hero</span>]=<span class="string">"currentHero"</span> (<span class="attr">deleteRequest</span>)=<span class="string">"deleteHero($event)"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">app-hero-detail</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>In src/app/hero-detail.component.ts file, set @Input and @Output decorator with corresponding properties. Then the error is resolved.</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  inputs: [<span class="string">'hero'</span>],</span><br><span class="line">  outputs: [<span class="string">'deleteRequest'</span>],</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">@Input</span>()  hero: Hero;</span><br><span class="line"><span class="meta">@Output</span>() deleteRequest = <span class="keyword">new</span> EventEmitter&lt;Hero&gt;();</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title>RxJs Observables</title>
    <url>/2019/10/19/Angular-Observables/</url>
    <content><![CDATA[<h1 id="What-is-Observable"><a href="#What-is-Observable" class="headerlink" title="What is Observable"></a>What is Observable</h1><p>Observable利用观察者模式，建立了发布者publisher和订阅者subscriber之间的联系。联系本身不会修改发布的信息，只是定义声明了订阅者对发布信息的处理方式。</p>
<p>使用目的：</p>
<ol>
<li><p>流式处理本身是延迟执行的，即在需要数据的一刻进行处理，并且不改变数据本身而是生成一个新的流。多流处理的支持。</p>
</li>
<li><p>异步回调保证了流式处理结果的实时渲染，因此Observable是高性能前端的重要概念。可以将同步方法转换成异步方法。</p>
</li>
<li><p>支持事件处理，动态注册事件及句柄。</p>
</li>
</ol>
<h2 id="创建Observable"><a href="#创建Observable" class="headerlink" title="创建Observable"></a>创建Observable</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Observable&#125; <span class="keyword">from</span> <span class="string">'rxjs'</span>;</span><br><span class="line"><span class="comment">// subscriber/observer is callback functions for this observable.</span></span><br><span class="line"><span class="comment">// &#123;next, error, complete&#125;</span></span><br><span class="line"><span class="keyword">const</span> observable = <span class="keyword">new</span> Observable(<span class="function"><span class="params">subscriber</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// observable can decide how frequency next/error/complete callback is called.</span></span><br><span class="line">    subscriber.next(<span class="number">1</span>);</span><br><span class="line">    subscriber.next(<span class="number">2</span>);</span><br><span class="line">    subscriber.next(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        subscriber.next(<span class="number">4</span>);</span><br><span class="line">        subscriber.complete();</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;unsubscribe() &#123;&#125;&#125;;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="传入Observable回调函数-创建一个subscriber"><a href="#传入Observable回调函数-创建一个subscriber" class="headerlink" title="传入Observable回调函数/创建一个subscriber"></a>传入Observable回调函数/创建一个subscriber</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">observable.subscribe(&#123;</span><br><span class="line">    x =&gt; <span class="built_in">console</span>.log(<span class="string">'got value '</span> + x),</span><br><span class="line">    err =&gt; <span class="built_in">console</span>.error(<span class="string">'got error '</span> + err),</span><br><span class="line">    () =&gt; <span class="built_in">console</span>.log(<span class="string">'done'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="创建multicast-Observable"><a href="#创建multicast-Observable" class="headerlink" title="创建multicast Observable"></a>创建multicast Observable</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multicastSequenceSubscriber</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> observers = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> timeoutId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">observer</span>) =&gt;</span> &#123;</span><br><span class="line">        observers.push(observer);</span><br><span class="line">        <span class="comment">// start the sequence when firstly subscribed.</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( observers.length === <span class="number">1</span>) &#123;</span><br><span class="line">            timeoutId = doSequence(&#123;</span><br><span class="line">                next(val) &#123;</span><br><span class="line">                    <span class="comment">// 将所有observer封装成一个observer</span></span><br><span class="line">                    observers.forEach(<span class="function"><span class="params">obs</span> =&gt;</span> obs.next(val));</span><br><span class="line">                &#125;,</span><br><span class="line"></span><br><span class="line">                complete() &#123;</span><br><span class="line">                    observers.slice(<span class="number">0</span>).forEach( <span class="function"><span class="params">obs</span> =&gt;</span> obs.complete());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, seq, <span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            unsubscribe() &#123;</span><br><span class="line">                <span class="comment">//remove observer</span></span><br><span class="line">                observers.splice(observers.indexOf(observer), <span class="number">1</span>);</span><br><span class="line">                <span class="comment">// cancel subscription if no observers.</span></span><br><span class="line">                <span class="keyword">if</span>(observers.length === <span class="number">0</span>)&#123;</span><br><span class="line">                    clearTimeout(timeoutId);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> multicastObservable = <span class="keyword">new</span> Observerble(multicastSequenceSubscriber())</span><br><span class="line"></span><br><span class="line"><span class="comment">// subscribe to this observable</span></span><br><span class="line">multicastObservable.subscribe(&#123;</span><br><span class="line">    next(num) &#123; <span class="built_in">console</span>.log(num)&#125;</span><br><span class="line">    complete()&#123;&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">multicastObservable.subscribe(&#123;</span><br><span class="line">    next(num) &#123; <span class="built_in">console</span>.log(<span class="string">'second: '</span> + num)&#125;</span><br><span class="line">    complete()&#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="Observable关系操作符"><a href="#Observable关系操作符" class="headerlink" title="Observable关系操作符"></a>Observable关系操作符</h2><table>
<thead>
<tr>
<th style="text-align:left">Area</th>
<th style="text-align:center">Operator</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Creation</td>
<td style="text-align:center">from, fromEvent, of</td>
</tr>
<tr>
<td style="text-align:left">Comibination</td>
<td style="text-align:center">combineLatest,concat, merge, startWith, withLatestFrom, zip</td>
</tr>
<tr>
<td style="text-align:left">Filtering</td>
<td style="text-align:center">debounceTime, distinctUtilChanged, filter, take, takeUtil</td>
</tr>
<tr>
<td style="text-align:left">Transformation</td>
<td style="text-align:center">bufferTime, concatMap, map, mergeMap, scan, switchMap</td>
</tr>
<tr>
<td style="text-align:left">Utility</td>
<td style="text-align:center">tap</td>
</tr>
<tr>
<td style="text-align:left">Multicasting</td>
<td style="text-align:center">share</td>
</tr>
</tbody>
</table>
<p>Observable的关系操作符，是通过.pipe()引入的，更多的操作符，可以参考rxjs官方API文档<a href="https://www.learnrxjs.io/operators/" target="_blank" rel="noopener">here</a>。</p>
<h1 id="Using-observables-in-Angular"><a href="#Using-observables-in-Angular" class="headerlink" title="Using observables in Angular"></a>Using observables in Angular</h1><ul>
<li>EventEmitter</li>
<li>HTTP模块处理AJAX requests</li>
<li>Router, Forms 模块监听/响应用户输入</li>
</ul>
<h1 id="Observable-v-s-Promise"><a href="#Observable-v-s-Promise" class="headerlink" title="Observable v.s. Promise"></a>Observable v.s. Promise</h1><ul>
<li>共同点</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">方面</th>
<th style="text-align:center">细节</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">异步处理</td>
<td style="text-align:center">subscribe/then callback</td>
</tr>
<tr>
<td style="text-align:left">使用语言</td>
<td style="text-align:center">支持typescript, javascript</td>
</tr>
<tr>
<td style="text-align:left">支持HTTP</td>
<td style="text-align:center">通过Angular httpClient支持, observable.toPromise()</td>
</tr>
</tbody>
</table>
<ul>
<li>不同点</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">方面</th>
<th style="text-align:center">细节</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">使用场景</td>
<td style="text-align:center">O: 事件处理句柄, 流式处理； P: 链式处理</td>
</tr>
<tr>
<td style="text-align:left">操作符复杂度</td>
<td style="text-align:center">O:多样化； P:单一</td>
</tr>
</tbody>
</table>
<h1 id="Reactive-Programming"><a href="#Reactive-Programming" class="headerlink" title="Reactive Programming"></a>Reactive Programming</h1><p>使用异步数据流进行编程，通过代码来忠实反映业务之间的关系。</p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>Typescript</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective Java</title>
    <url>/2020/10/30/Effective-Java/</url>
    <content><![CDATA[<p>本文是Effetive Java一书提出地90条Java代码规范建议，具体内容需要查看相应地书籍内容，本文仅作为索引复习回忆。</p>
<h1 id="创建与销毁对象"><a href="#创建与销毁对象" class="headerlink" title="创建与销毁对象"></a>创建与销毁对象</h1><ol>
<li><p>用静态工厂方法代替构造器</p>
</li>
<li><p>遇到多个构造器参数时要考虑使用构建器(builder)</p>
</li>
<li><p>用私有构造器或者枚举类型强化Singleton属性</p>
</li>
<li><p>通过私有构造器强化不可实例化的能力</p>
</li>
<li><p>优先考虑依赖注入来引用资源</p>
</li>
<li><p>避免创建不必要的对象</p>
</li>
<li><p>消除过期的对象引用</p>
</li>
<li><p>避免使用中介方法和清除方法</p>
</li>
<li><p>try-with-resources优先于try-finally</p>
</li>
</ol>
<h1 id="对于所有对象都通用的方法"><a href="#对于所有对象都通用的方法" class="headerlink" title="对于所有对象都通用的方法"></a>对于所有对象都通用的方法</h1><ol start="10">
<li><p>覆盖Equals时请遵守通用约定</p>
</li>
<li><p>覆盖equals时总要覆盖hashCode</p>
</li>
<li><p>始终要覆盖toString</p>
</li>
<li><p>谨慎的覆盖clone</p>
</li>
<li><p>考虑实现Comparable接口</p>
</li>
</ol>
<h1 id="类和接口"><a href="#类和接口" class="headerlink" title="类和接口"></a>类和接口</h1><ol start="15">
<li><p>使用类和成员的可访问性最小化</p>
</li>
<li><p>要在公有类而非公有域中使用访问方法</p>
</li>
<li><p>使可变性最小化</p>
</li>
<li><p>复合优先于集成</p>
</li>
<li><p>要么设计继承并提供文档说明，要么继承</p>
</li>
<li><p>接口优于抽象类</p>
</li>
<li><p>为后代设计接口</p>
</li>
<li><p>接口只用于定义类型</p>
</li>
<li><p>类层次优于标签类</p>
</li>
<li><p>静态成员类由于非静态成员类</p>
</li>
<li><p>限制源文件为单个顶级类</p>
</li>
</ol>
<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><ol start="26">
<li><p>请不要使用原生态类型</p>
</li>
<li><p>消除非受检的警告</p>
</li>
<li><p>列表由于数组</p>
</li>
<li><p>优先考虑泛型</p>
</li>
<li><p>优先考虑泛型方法</p>
</li>
<li><p>利用有限限制通配符来提升API的灵活性</p>
</li>
<li><p>谨慎并用泛型和可变参数</p>
</li>
<li><p>优先考虑类型安全的异构容器</p>
</li>
</ol>
<h1 id="枚举和注解"><a href="#枚举和注解" class="headerlink" title="枚举和注解"></a>枚举和注解</h1><ol start="34">
<li><p>用enum代替int常量</p>
</li>
<li><p>用实例域代替序数</p>
</li>
<li><p>用EnumSet代替位域</p>
</li>
<li><p>用EnumMap代替序数索引</p>
</li>
<li><p>用接口模拟可扩展的枚举</p>
</li>
<li><p>注解优先于明明模式</p>
</li>
<li><p>坚持使用Override注解</p>
</li>
<li><p>用标记接口定义类型</p>
</li>
</ol>
<h1 id="Lamda和stream"><a href="#Lamda和stream" class="headerlink" title="Lamda和stream"></a>Lamda和stream</h1><ol start="42">
<li><p>Lamda优先于匿名类</p>
</li>
<li><p>方法引用优先于Lamda</p>
</li>
<li><p>坚持使用标准的函数接口</p>
</li>
<li><p>谨慎使用Stream</p>
</li>
<li><p>优先选择Stream中无副作用的函数</p>
</li>
<li><p>Stream要优先用Collection作为返回类型</p>
</li>
<li><p>谨慎使用Stream并行</p>
</li>
</ol>
<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><ol start="49">
<li><p>检查参数的有效性</p>
</li>
<li><p>必要时进行保护性拷贝</p>
</li>
<li><p>谨慎设计方法签名</p>
</li>
<li><p>慎用重载</p>
</li>
<li><p>慎用可变参数</p>
</li>
<li><p>返回零长度的数组或者集合，而不是null</p>
</li>
<li><p>谨慎返回optional</p>
</li>
<li><p>为所有导出的API元素编写文档注释</p>
</li>
</ol>
<h1 id="通用编程"><a href="#通用编程" class="headerlink" title="通用编程"></a>通用编程</h1><ol start="57">
<li><p>将局部变量的作用域最小化</p>
</li>
<li><p>for-each循环优先传统的for循环</p>
</li>
<li><p>了解和使用类库</p>
</li>
<li><p>如果需要精确的答案，请避免使用float和double</p>
</li>
<li><p>基本类型优先于装箱基本类型</p>
</li>
<li><p>如果其他类型更适合，则尽量避免使用字符串</p>
</li>
<li><p>了解字符串连接的性能</p>
</li>
<li><p>通过接口引用对象</p>
</li>
<li><p>接口优先于反射机制</p>
</li>
<li><p>谨慎地使用本地方法</p>
</li>
<li><p>谨慎地进行优化</p>
</li>
<li><p>遵守普遍接受的命名惯例</p>
</li>
</ol>
<h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><ol start="69">
<li><p>只针对异常的情况才使用异常</p>
</li>
<li><p>对可恢复的情况使用受检异常，对编程错误使用运行时异常</p>
</li>
<li><p>避免不必要地使用受检异常</p>
</li>
<li><p>优先使用标准的异常</p>
</li>
<li><p>抛出与抽象对应的异常</p>
</li>
<li><p>每个方法抛出的所有异常都要建立文档</p>
</li>
<li><p>在细节消息中包含失败捕获信息</p>
</li>
<li><p>努力使失败保持原子性</p>
</li>
<li><p>不要忽略异常</p>
</li>
</ol>
<h1 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h1><ol start="78">
<li><p>同步访问共享的可变数据</p>
</li>
<li><p>避免过度同步</p>
</li>
<li><p>executor，task和stream优先于线程</p>
</li>
<li><p>并发工具优先于wait和notify</p>
</li>
<li><p>线程安全性的文档化</p>
</li>
<li><p>慎用延迟初始化</p>
</li>
<li><p>不要依赖于线程调度器</p>
</li>
</ol>
<h1 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h1><ol start="85">
<li><p>其他方法优先于Java序列化</p>
</li>
<li><p>谨慎地实现Serializable接口</p>
</li>
<li><p>考虑使用自定义地序列化形式</p>
</li>
<li><p>保护性地编写readOjbect方法</p>
</li>
<li><p>对于实例控制，枚举类型优先于readResolve</p>
</li>
<li><p>考虑用序列化代理代替序列化实例</p>
</li>
</ol>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>肉肉</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Git best practices</title>
    <url>/2019/03/29/Git-best-practices/</url>
    <content><![CDATA[<h1 id="Git-基本操作"><a href="#Git-基本操作" class="headerlink" title="Git 基本操作"></a>Git 基本操作</h1><h2 id="创建Git仓库"><a href="#创建Git仓库" class="headerlink" title="创建Git仓库"></a>创建Git仓库</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>
<h2 id="查看代码情况"><a href="#查看代码情况" class="headerlink" title="查看代码情况"></a>查看代码情况</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git status</span><br><span class="line">git diff &#123;filepath&#125;</span><br></pre></td></tr></table></figure>
<h2 id="提交代码"><a href="#提交代码" class="headerlink" title="提交代码"></a>提交代码</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> &#123;clone.git&#125;</span><br><span class="line">git add -A</span><br><span class="line">git commit -m <span class="string">"message"</span></span><br><span class="line">git push orgin master</span><br></pre></td></tr></table></figure>
<h2 id="保存-恢复临时修改文件"><a href="#保存-恢复临时修改文件" class="headerlink" title="保存/恢复临时修改文件"></a>保存/恢复临时修改文件</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git stash</span><br><span class="line">git checkout stash@&#123;0&#125; -- &#123;filepath&#125;</span><br></pre></td></tr></table></figure>
<h2 id="读取文件历史版本"><a href="#读取文件历史版本" class="headerlink" title="读取文件历史版本"></a>读取文件历史版本</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout &#123;commithash&#125; -- &#123;filepath&#125;</span><br></pre></td></tr></table></figure>
<h2 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git tag -a v1.0  <span class="comment"># tag most recent commit</span></span><br><span class="line">git tag -a v0.9 85fc7e7 <span class="comment"># tag on a specific commit</span></span><br><span class="line">git tag <span class="comment"># view tags</span></span><br></pre></td></tr></table></figure>
<h1 id="Pull-Fork工作流"><a href="#Pull-Fork工作流" class="headerlink" title="Pull/Fork工作流"></a>Pull/Fork工作流</h1><ol>
<li>fork from the github</li>
<li><p>clone to local and commit changes</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> &#123;clone.git&#125;</span><br><span class="line">git checkout -b feature</span><br><span class="line"><span class="comment"># make changes to this branch</span></span><br><span class="line">git add -p</span><br><span class="line">git commit -m <span class="string">"feature message"</span></span><br><span class="line">git push origin feature</span><br></pre></td></tr></table></figure>
</li>
<li><p>rebase commits after remote master</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote add upstream &#123;remote.git&#125;</span><br><span class="line">git pull upstream master</span><br><span class="line"><span class="comment"># no changes on master, then automatically git history is updated</span></span><br><span class="line">git checkout feature</span><br><span class="line">git pull --rebase origin master</span><br><span class="line"><span class="comment"># apply changes from origin master to feature newly commits</span></span><br><span class="line">git push origin feature --force</span><br></pre></td></tr></table></figure>
</li>
<li><p>raise pull request for code review</p>
</li>
</ol>
<h1 id="提交历史管理"><a href="#提交历史管理" class="headerlink" title="提交历史管理"></a>提交历史管理</h1><h2 id="缩减冗余commit-log"><a href="#缩减冗余commit-log" class="headerlink" title="缩减冗余commit log"></a>缩减冗余commit log</h2><ul>
<li>通过rebase修改commit history</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># rewrite last 10 commit logs</span></span><br><span class="line">git rebase -i HEAD~10 feature</span><br><span class="line">git push orign feature --force</span><br></pre></td></tr></table></figure>
<ul>
<li>通过squash命令压缩commit history</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git reset --hard HEAD~12 <span class="comment"># 将git指针定位到历史版本</span></span><br><span class="line"></span><br><span class="line">git merge --squash HEAD@&#123;1&#125; <span class="comment"># 从该点开始merge到最新的版本</span></span><br><span class="line"></span><br><span class="line">git commmit -m <span class="string">"xxx"</span> <span class="comment"># 提交commit重写</span></span><br><span class="line"></span><br><span class="line">git push origin master --force <span class="comment"># 强制改写历史</span></span><br></pre></td></tr></table></figure>
<h1 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h1><h2 id="创建新分支"><a href="#创建新分支" class="headerlink" title="创建新分支"></a>创建新分支</h2><p>在创建新的local分支时，也可以添加commit hash告诉git分支最新的HEAD指向</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout -b feature</span><br><span class="line"><span class="comment"># create a branch based on current branch</span></span><br></pre></td></tr></table></figure>
<h2 id="切换分支-从Detached-HEAD切换"><a href="#切换分支-从Detached-HEAD切换" class="headerlink" title="切换分支/从Detached HEAD切换"></a>切换分支/从Detached HEAD切换</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout feature</span><br></pre></td></tr></table></figure>
<h2 id="删除本地分支"><a href="#删除本地分支" class="headerlink" title="删除本地分支"></a>删除本地分支</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch -d feature</span><br><span class="line">git branch -D feature <span class="comment"># force delete</span></span><br></pre></td></tr></table></figure>
<h2 id="删除远程分支"><a href="#删除远程分支" class="headerlink" title="删除远程分支"></a>删除远程分支</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push orgin --delete feature</span><br></pre></td></tr></table></figure>
<h2 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git merge feature</span><br><span class="line"><span class="comment"># merge changes from feature branch to current master branch</span></span><br></pre></td></tr></table></figure>
<h2 id="CherryPick别的分支commit-branch"><a href="#CherryPick别的分支commit-branch" class="headerlink" title="CherryPick别的分支commit/branch"></a>CherryPick别的分支commit/branch</h2><p>在需要apply的分支上保证没有unstaged change，运行如下命令<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git cherry-pick &lt;commitHash&gt;/&lt;feature branch name&gt;</span><br></pre></td></tr></table></figure></p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>肉肉</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP protocol introduction</title>
    <url>/2019/08/11/HTTP-protocol-introduction/</url>
    <content><![CDATA[<h1 id="HTTP-协议"><a href="#HTTP-协议" class="headerlink" title="HTTP 协议"></a>HTTP 协议</h1><p>HTTP协议属于应用层协议，其设计目的是为了方便文本内容的分享与发布。HTTP协议是Web资源共享的基础，与URL(文档地址定位符)，HTML共同构建了Web世界。</p>
<p>HTTP协议属于点到点通信协议，请求访问资源的一端称为客户端，提供资源相应的一端称为服务器。</p>
<h2 id="HTTP协议方法"><a href="#HTTP协议方法" class="headerlink" title="HTTP协议方法"></a>HTTP协议方法</h2><ul>
<li>GET：请求访问资源。</li>
<li>POST：传输主体内容。</li>
<li>PUT：传输内容，幂等传输。</li>
<li>HEAD: 获得报文首部，用于确认资源有效性和更新日期。</li>
<li>DELETE: 删除内容。</li>
<li>OPTIONS: 询问资源支持方法。</li>
<li>TRACE：追踪路径，用于计算客户端到服务器端的跳数。</li>
<li>CONNECT: 要求用socket协议连接代理。</li>
</ul>
<p>HTTP方法本身是无状态协议，为了支持复杂有状态场景，引入了Cookie技术，确保认证客户端通信的上下文是连续的。</p>
<h2 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h2><table>
<thead>
<tr>
<th style="text-align:left"></th>
<th style="text-align:left">类别</th>
<th style="text-align:left">原因短语</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1XX</td>
<td style="text-align:left">Informational(信息性状态码)</td>
<td style="text-align:left">接收的请求正在处理</td>
</tr>
<tr>
<td style="text-align:left">2XX</td>
<td style="text-align:left">Success（成功状态码）</td>
<td style="text-align:left">请求正常处理完毕</td>
</tr>
<tr>
<td style="text-align:left">3XX</td>
<td style="text-align:left">Redirection（重定向状态码）</td>
<td style="text-align:left">需要进行附加操作以完成请求</td>
</tr>
<tr>
<td style="text-align:left">4XX</td>
<td style="text-align:left">Client Error（客户端错误状态码）</td>
<td style="text-align:left">服务器无法处理请求</td>
</tr>
<tr>
<td style="text-align:left">5XX</td>
<td style="text-align:left">Server Error(服务器错误状态码)</td>
<td style="text-align:left">服务器处理请求出错</td>
</tr>
</tbody>
</table>
<h2 id="HTTP协议架构中的转发功能节点"><a href="#HTTP协议架构中的转发功能节点" class="headerlink" title="HTTP协议架构中的转发功能节点"></a>HTTP协议架构中的转发功能节点</h2><ul>
<li>代理：代理服务器的基本行为是接收客户端发送的请求转发给其他服务器，不改变请求URI。分为两类：<ol>
<li>缓存代理：缓存内容。</li>
<li>透明代理：纯粹内容转发，不做缓存。</li>
</ol>
</li>
<li>网关：网关为通信链路上的服务器提供非HTTP协议连接，例如与信用卡结算系统联动，数据库联动等。</li>
<li>隧道：隧道的建立能够确保客户端与服务器之间安全的通信。也能扩展HTTP通信协议，例如支持推送功能等等。</li>
</ul>
<h1 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h1><h2 id="HTTP协议的缺点："><a href="#HTTP协议的缺点：" class="headerlink" title="HTTP协议的缺点："></a>HTTP协议的缺点：</h2><ol>
<li>明文信息会被窃听；</li>
<li>无法验证通信方身份，会被伪装；</li>
<li>无法验证报文的完整性，会被篡改。</li>
</ol>
<h2 id="HTTP-over-SSL-TSL"><a href="#HTTP-over-SSL-TSL" class="headerlink" title="HTTP over SSL/TSL"></a>HTTP over SSL/TSL</h2><p>SSL/TSL协议独立与HTTP协议，存在于HTTP和TCP协议之间，在建立HTTP连接之前，先建立SSL通信机制，交换加密密钥，从而在HTTP通信报文可以进行加密传输。</p>
<p>HTTPS 协议通信握手/分手协议步骤：</p>
<p><img src="/2019/08/11/HTTP-protocol-introduction/HTTPS.jpg" alt="HTTPS"></p>
<p>握手主要分为4个阶段:</p>
<ol>
<li>SSL证书请求，及公钥获取。&lt;= 由于非对称加密机制的效率较低，安全性高，只用作密钥交互。</li>
<li>客户端密钥加密发送。</li>
<li>服务器端密钥确认。</li>
<li>数据传输… &lt;= 数据传输阶段的加密是基于协商确定的对称密钥发送，效率较高。</li>
</ol>
<h1 id="WebSocket协议"><a href="#WebSocket协议" class="headerlink" title="WebSocket协议"></a>WebSocket协议</h1><p>Web浏览器支持的全双工通信协议，在HTTP部首加入upgrade：websocket字段，服务器通过返回状态码101 swtiching protocols响应连接，一旦服务器与客户端建立WebSocket协议的通信连接，之后所有的通信都用这个专用协议进行。</p>
<ul>
<li>推送功能： 服务器可以直接发送数据到客户端。</li>
<li>减少通信量：保持连接的状态减少HTTP协议的连接开销。</li>
</ul>
<h1 id="用户认证问题"><a href="#用户认证问题" class="headerlink" title="用户认证问题"></a>用户认证问题</h1><p>HTTP/1.1常见的认证方式如下：</p>
<ul>
<li>BASIC认证：直接提交用户名密码完成认证。<br><img src="/2019/08/11/HTTP-protocol-introduction/BASIC.jpg" alt="BASIC"></li>
<li>DIGEST认证：客户端根据服务器端的质询码生成响应码完成认证。<br><img src="/2019/08/11/HTTP-protocol-introduction/DIGEST.jpg" alt="DIGEST"></li>
<li>SSL客户端认证：凭借HTTPS的客户端认证证书完成认证。</li>
<li>FormBase认证：在用户登录信息以表单形式提交后，服务器端发放Session ID用于用户认证状态的绑定和保持。<br><img src="/2019/08/11/HTTP-protocol-introduction/FORMBASED.jpg" alt="FORM"></li>
<li>Kerberos认证：</li>
<li>NTLM认证：</li>
<li>SSO认证：</li>
</ul>
<h1 id="Web安全问题"><a href="#Web安全问题" class="headerlink" title="Web安全问题"></a>Web安全问题</h1><ul>
<li>跨站脚本工具XSS：通过执行非法HTML标签/JS脚本进行攻击。<ol>
<li>表单中插入非法标签执行JS脚本。</li>
<li>基于用户Cookie的窃取攻击</li>
</ol>
</li>
<li>SQL注入攻击：通过加入SQL结束符，强制加入SQL语句执行。</li>
<li>OS命令攻击:通过Shell脚本注入执行系统命令。</li>
<li>HTTP部首注入攻击：通过访问URL加入换行符，注入HTTP首部字段进行攻击。<ol>
<li>Cookie设置字段生效。</li>
<li>HTTP响应截断攻击，强制显示伪造内容。</li>
</ol>
</li>
<li>邮件首部注入攻击: <ol>
<li>BCC邮件泄露。</li>
</ol>
</li>
<li>目录遍历攻击: 访问无疑公开的文件目录。</li>
<li>远程文件包含漏洞：引入其他包，例如System包进行代码污染。</li>
</ul>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>肉肉</tag>
      </tags>
  </entry>
  <entry>
    <title>Java Xml Libraries</title>
    <url>/2019/04/24/Java-Xml-Libraries/</url>
    <content><![CDATA[<p>本文描述了当前主流的Java Xml libraries，以及对比区别。</p>
<blockquote>
<p>下文摘取自<a href="https://www.baeldung.com/java-xml-libraries" target="_blank" rel="noopener">https://www.baeldung.com/java-xml-libraries</a></p>
</blockquote>
<ul>
<li><p>SAX: It is an event based parsing API, it provides a low level access, is memory efficient and faster than DOM since it doesn’t load the whole document tree in memory but it doesn’t provide support for navigation like the one provided by XPath, although it is more efficient it is harder to use too.</p>
</li>
<li><p>DOM(DOM4J and JDOM): It as model based parser that loads a tree structure document in memory, so we have the original elements order, we can navigate our document both directions, it provides an API for reading and writing, it offers XML manipulation and it is very easy to use although the price is high strain on memory resources.</p>
</li>
<li><p>StAX: It offers the ease of DOM and the efficiency of SAX but it lacks of some functionality provided by DOM like XML manipulation and it only allows us to navigate the document forward.</p>
</li>
<li><p>JAXB: It allows us to navigate the document in both directions, it is more efficient than DOM, it allows conversion from XML to java types and it supports XML manipulation but it can only parse a valid XML document.</p>
</li>
</ul>
<p><img src="/2019/04/24/Java-Xml-Libraries/JavaXmlLibs.png" alt="JavaXmlLibs"></p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>肉肉</tag>
      </tags>
  </entry>
  <entry>
    <title>Java Stream API</title>
    <url>/2018/12/11/Java-Streams/</url>
    <content><![CDATA[<h1 id="Java-Streams"><a href="#Java-Streams" class="headerlink" title="Java Streams"></a>Java Streams</h1><p>Java在JDK1.8中引入了Stream API,支持对流的处理。流处理类似于对于数据库数据流进行只读操作后求得某种结果，有如下特点:</p>
<p><img src="/2018/12/11/Java-Streams/JavaStream.png" alt="Java-Streams"></p>
<ol>
<li>stream不存储数据</li>
<li>stream不改变源数据</li>
<li>stream的延迟执行特性</li>
</ol>
<h2 id="Stream-API-简述"><a href="#Stream-API-简述" class="headerlink" title="Stream API 简述"></a>Stream API 简述</h2><h3 id="创建Stream"><a href="#创建Stream" class="headerlink" title="创建Stream"></a>创建Stream</h3><p>Stream.of(Collection<t> collections)时Stream类的静态方法，可以将集合数据转化为Stream。</t></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Stream.of()</span></span><br><span class="line">Stream&lt;Student&gt; stream = Stream.of(stuArr);</span><br><span class="line"><span class="comment">//Arrays.stream</span></span><br><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">34</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    IntStream intStream = Arrays.stream(arr);</span><br></pre></td></tr></table></figure>
<h3 id="Stream操作"><a href="#Stream操作" class="headerlink" title="Stream操作"></a>Stream操作</h3><blockquote>
<p>Reference Link: <a href="https://www.cnblogs.com/CarpenterLee/p/6545321.html" target="_blank" rel="noopener">https://www.cnblogs.com/CarpenterLee/p/6545321.html</a></p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:left">操作类型</th>
<th style="text-align:center">接口方法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">中间操作</td>
<td style="text-align:center">concat() distinct() filter() flatMap() limit() map() peek() skip() sorted() parallel() sequential() unordered()</td>
</tr>
<tr>
<td style="text-align:left">结束操作</td>
<td style="text-align:center">allMatch() anyMatch() collect() count() findAny() findFirst() forEach() forEachOrdered() max() min() noneMatch() reduce() toArray()</td>
</tr>
</tbody>
</table>
<p>对于接口方法的传入参数，是各种函数接口，可以用lamda表达式方便的书写。下面介绍几个经典的API使用：</p>
<ol>
<li>forEach()</li>
</ol>
<p>forEach(Consumer&lt;? super E&gt; action)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用Stream.forEach()迭代</span></span><br><span class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">"I"</span>, <span class="string">"love"</span>, <span class="string">"you"</span>, <span class="string">"too"</span>);</span><br><span class="line">stream.forEach(str -&gt; System.out.println(str));</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>filter()</li>
</ol>
<p>filter(Predicate&lt;? super E&gt; predicate)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 保留长度等于3的字符串</span></span><br><span class="line">Stream&lt;String&gt; stream= Stream.of(<span class="string">"I"</span>, <span class="string">"love"</span>, <span class="string">"you"</span>, <span class="string">"too"</span>);</span><br><span class="line">stream.filter(str -&gt; str.length()==<span class="number">3</span>)</span><br><span class="line">    .forEach(str -&gt; System.out.println(str));</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>map()</li>
</ol>
<p><r> Stream<r> map(Function&lt;? super T,? extends R&gt; mapper)</r></r></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;String&gt; stream　= Stream.of(<span class="string">"I"</span>, <span class="string">"love"</span>, <span class="string">"you"</span>, <span class="string">"too"</span>);</span><br><span class="line">stream.map(str -&gt; str.toUpperCase())</span><br><span class="line">    .forEach(str -&gt; System.out.println(str));</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>reduce()</li>
</ol>
<blockquote>
<p>reference Link: <a href="http://www.cnblogs.com/CarpenterLee/p/6550212.html" target="_blank" rel="noopener">http://www.cnblogs.com/CarpenterLee/p/6550212.html</a></p>
</blockquote>
<ul>
<li>Optional<t> reduce(BinaryOperator<t> accumulator)</t></t></li>
<li>T reduce(T identity, BinaryOperator<t> accumulator)</t></li>
<li>\<u> U reduce(U identity, BiFunction&lt;U,? super T,U&gt; accumulator, BinaryOperator\<u> combiner)</u></u></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 找出最长的单词</span></span><br><span class="line"></span><br><span class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">"I"</span>, <span class="string">"love"</span>, <span class="string">"you"</span>, <span class="string">"too"</span>);</span><br><span class="line">Optional&lt;String&gt; longest = stream.reduce((s1, s2) -&gt; s1.length()&gt;=s2.length() ? s1 : s2);</span><br><span class="line"><span class="comment">//Optional&lt;String&gt; longest = stream.max((s1, s2) -&gt; s1.length()-s2.length());</span></span><br><span class="line">System.out.println(longest.get());</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>collect()</li>
</ol>
<ul>
<li><r> R collect(Supplier<r> supplier, BiConsumer&lt;R,? super T&gt; accumulator, BiConsumer&lt;R,R&gt; combiner)</r></r></li>
<li>&lt;R,A&gt; R collect(Collector&lt;? super T,A,R&gt; collector)</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//　将Stream规约成List</span></span><br><span class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">"I"</span>, <span class="string">"love"</span>, <span class="string">"you"</span>, <span class="string">"too"</span>);</span><br><span class="line">List&lt;String&gt; list = stream.collect(ArrayList::<span class="keyword">new</span>, ArrayList::add, ArrayList::addAll);<span class="comment">// 方式１</span></span><br><span class="line"><span class="comment">//List&lt;String&gt; list = stream.collect(Collectors.toList());// 方式2</span></span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure>
<h2 id="LINQ-in-C"><a href="#LINQ-in-C" class="headerlink" title="LINQ in C#"></a>LINQ in C#</h2><p>与Java语言相比，C#引入了LINQ，lamda表达式和扩展方法来更好的支持chaining operation。LinQ支持所有实现了Enumberable接口的类型。</p>
<ol>
<li><p>ForEach()</p>
<p> .ForEach(Action<t> action)</t></p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List&lt;string&gt; stringList = new List&lt;string&gt;（）;</span><br><span class="line">   stringList.Add(&quot;I&quot;);</span><br><span class="line">   stringList.Add(&quot;love&quot;);</span><br><span class="line">   stringList.Add(&quot;you&quot;);</span><br><span class="line">   stringList.Add(&quot;too&quot;);</span><br><span class="line">   stringList.ForEach(a =&gt; Console.WriteLine(a));</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><p>Where()</p>
<p> .Where(Func&lt;T, bool&gt; function)</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">stringList.Where( x=&gt; x.Length == 3)</span><br><span class="line">            .ForEach( x=&gt; Console.WriteLine(x));</span><br></pre></td></tr></table></figure>
<ol start="3">
<li><p>Select()</p>
<p> .Select(Func&lt;T, int, R&gt; function)</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">stringList.Selct((x, i) =&gt; x.ToUpper())</span><br><span class="line">            .ForEach( x=&gt; Console.WriteLine(x));</span><br></pre></td></tr></table></figure>
<ol start="4">
<li><p>Aggregate()</p>
<p> .Aggregate(A, Func&lt;A, T, A&gt; function, Func&lt;A, R&gt; function2)</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">stringList.Aggregate(&quot;&quot;, (cur, next) =&gt; cur.Length &gt; next.Length ? cur : next, x =&gt; Console.WriteLine(x));</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>扩展方法，Java collect()方法是.NET扩展方法功能的一种实现，C#通过定义扩展方法更好的支持LINQ的Chaining功能，使得Java Collectors的接口都可以直接通过相似的方法实现。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">stringList.Select(x=&gt;x).toList();</span><br></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>肉肉</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 523 Continuous Subarray Sum</title>
    <url>/2018/05/13/Leetcode-523-Continuous-Subarray-Sum/</url>
    <content><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>Given a list of non-negative numbers and a target integer k, write a function to check if the array has a continuous subarray of size at least 2 that sums up to the multiple of k, that is, sums up to n*k where n is also an integer.</p>
<p>Example 1:</p>
<p>Input: [23, 2, 4, 6, 7],  k=6</p>
<p>Output: True</p>
<p>Explanation: Because [2, 4] is a continuous subarray of size 2 and sums up to 6.</p>
<p>Example 2:</p>
<p>Input: [23, 2, 6, 4, 7],  k=6</p>
<p>Output: True</p>
<p>Explanation: Because [23, 2, 6, 4, 7] is an continuous subarray of size 5 and sums up to 42. 42 is a mutiple of 6 and 7 and n=7.</p>
<p>Note:</p>
<ol>
<li>The length of the array won’t exceed 10,000.</li>
<li>You may assume the sum of all the numbers is in the range of a signed 32-bit integer.</li>
</ol>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><p>本题是一个经典的动态规划问题，此类问题的特征是，需要在穷举的可能性中找到一个最优化的解，从而求出所需问题的答案。本题的目标是找到所有和为K的连续子数组的个数。虽然本题没有直接提问一个最优解的概念，但是其实和为K的连续子数组的个数就是在穷举所有可能性后得出的并且是唯一的结果。</p>
<p>本题的解题思路是采用是动态规划思想，一般来讲，动态规划题目的解题思路如下：</p>
<ol>
<li>找出最优解性质，并刻画其结构特征;</li>
<li>递归的定义最优值;</li>
<li>自底向上的方式算出最优值；</li>
<li>根据计算最优值时得到的信息构造最优解。</li>
</ol>
<blockquote>
<p>动态规划解题的前提假设是：问题的最优解包含着其自问题的最优解。此种性质称为最优子结构性质。最优子结构性质不难通过反证法证明。</p>
</blockquote>
<blockquote>
<p>递归关系的建立，是基于已有的前提最优解，所以不难在此基础上推导出递增关系。</p>
</blockquote>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>本题中，连续子数组的和是可以通过数组前缀和算出来的。两个长度不同的数组S[i], S[j]的前缀和相减就能计算出子数组S[(i+1)~j]的和。</p>
<blockquote>
<p>数组前缀和定义：一个数组从0号元素相加到k号元素则是该数组的第k个前缀和。下文用Sum(k)表示。</p>
</blockquote>
<p>假设已知长度为k的所有长度大于2的子数组后缀和中，是K的整数倍的有a(k)个，则当在k+1的情况下，a(k+1)则是a(k)+所有k的子数组后缀和中值为K的整数倍-a[k+1]的个数。</p>
<blockquote>
<p>数组后缀和定义：一个数组从最后一个元素加到倒数第k的元素，是该数组的第k个后缀和。</p>
</blockquote>
<p>长度为k的数组的所有子数组的后缀和计算，可以利用数组的前缀和计算出。a(k)情况下，其后缀和的集合为第k个前缀和减去第i个前缀和(0&lt;=i&lt;k)的数集。</p>
<p>为求得所有k的子数组后缀和中值为K的整数倍-a[k+1]的个数，需要求出所有k的整倍数-a[k+1]的个数。循环终止于当k的倍数大于整个序列和。</p>
<h3 id="程序设计"><a href="#程序设计" class="headerlink" title="程序设计"></a>程序设计</h3><p>本程序需要维护一个HashMap，每个key都是一个前缀和，value则是前缀和的子数组个数。从而在每步的计算中能够利用这个数据结构最优查找速度。</p>
<p>每步的运算设计思想是找到重复的子问题，从而能在一步一步地推中找到第n步的答案。每步的计算中需要找到第k后缀和中符合条件的解，也就是HashMap中key值为sum-K_multiple的value。计算公式推导如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第k后缀和中符合条件的解</span><br><span class="line">    =[所有K的整倍数a[k+1]-为a[k]后缀和的]value</span><br><span class="line">    =[所有K的整倍数-a[k+1]为(Sum(k)-Sum(i))]的value, i=0,1,...,k-2中某值</span><br><span class="line">    =[所有K的整倍数为(Sum(k+1)-Sum(i))]的value</span><br><span class="line">    =[Sum(i)中值为(Sum(k+1)-所有K的整数倍)]的value</span><br></pre></td></tr></table></figure>
<p>本算法需要计算从0到n的所有子数组前缀和并进行O(1)的HashMap查找，所以最终的复杂度为O(n)。</p>
<h3 id="实现技巧"><a href="#实现技巧" class="headerlink" title="实现技巧"></a>实现技巧</h3><p>边界条件考虑：</p>
<ol>
<li><p>长度至少为2的子数组；</p>
<p> 对于存在单个数为K的整数倍的数组，单数的情况是不能统计进最终结果的，所以需要在查找匹配的情况下去检查Sum(i)是否为previous_sum。如果是且value=1就需要剔除该种情况。</p>
</li>
<li><p>非负序列</p>
<p> 注意，value是可以不为1的，因为非负序列是可以存在连续的0元素。</p>
</li>
<li><p>K的整数倍</p>
<p> K的整数倍包括负数倍，也包括0倍，所以需要考虑K&lt;0是将K转化为正数，因为同解。</p>
</li>
<li><p>K为零的情况</p>
<p> K为零的情况需要特殊考虑，主要是因为算法可以大大简化为查找连续两个0的算法。也因为K为零会使求余数运算符无法使用。</p>
</li>
<li><p>循环次数过多超时问题</p>
<p> 此属于算法优化问题，当Sum(k+1)本身就是K的整数倍的时候，可以直接跳过K的整数倍递增的查找运算，从而避免K过小，序列元素值过大而造成的超时问题。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkSubarraySum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//special consideration for k=0 case</span></span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; nums.length; ++i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i&gt; <span class="number">0</span> &amp;&amp; nums[i] == <span class="number">0</span> &amp;&amp; nums[i-<span class="number">1</span>]==<span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// revert to positive value to get same solution</span></span><br><span class="line">        <span class="keyword">if</span>(k &lt; <span class="number">0</span>)</span><br><span class="line">            k = -k;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> previous_sum = <span class="number">0</span>;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt; ();</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; nums.length; ++i)&#123;</span><br><span class="line">            sum += nums[i];            </span><br><span class="line">            <span class="comment">//check sum(k+1) first</span></span><br><span class="line">            <span class="keyword">if</span>(sum%k == <span class="number">0</span> &amp;&amp; i &gt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">//iterate to search</span></span><br><span class="line">            <span class="keyword">int</span> k_multiple = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(k_multiple&lt;sum )&#123;</span><br><span class="line">                <span class="keyword">if</span>(map.containsKey(sum-k_multiple))&#123;</span><br><span class="line">                    <span class="keyword">if</span>(sum-k_multiple == previous_sum &amp;&amp; map.get(previous_sum) == <span class="number">1</span>)&#123;</span><br><span class="line">                        k_multiple += k;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;                        </span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;                    </span><br><span class="line">                k_multiple += k;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">            <span class="comment">//memroize sum(k)</span></span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(sum))</span><br><span class="line">                map.put(sum, map.get(sum)+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                map.put(sum, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// store previoius sum(k) to avoid length=1 subarraies</span></span><br><span class="line">            previous_sum = sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>肉肉</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 60: Permutation Sequence</title>
    <url>/2018/04/12/Leetcode-60-Permutation-Sequence/</url>
    <content><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>The set [1,2,3,…,n] contains a total of n! unique permutations.</p>
<p>By listing and labeling all of the permutations in order,<br>We get the following sequence (ie, for n = 3):</p>
<p>“123”</p>
<p>“132”</p>
<p>“213”</p>
<p>“231”</p>
<p>“312”</p>
<p>“321”</p>
<p>Given n and k, return the kth permutation sequence.</p>
<p>Note: Given n will be between 1 and 9 inclusive.</p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>寻找排列顺序规律，可以得出如下排序规律：</p>
<ol>
<li><p>整个排序可以划分成n个小排序。以1为首，[2, 3]的子序列排序。以2为首，[1, 3]的子序列排序， 以3为首，[1, 2]的子序列排序。</p>
</li>
<li><p>再次划分，则可以将以1为首的排序中，分成以2为第二位， [3]的全排列，和以3为第二位，[2]的全排列。</p>
</li>
<li><p>逐次划分，分别能将长度为n的序列分解成n个(n-1)全排列，n*(n-1)个(n-2)的全排列，…n!个(1)的全排列。</p>
</li>
</ol>
<h3 id="程序设计"><a href="#程序设计" class="headerlink" title="程序设计"></a>程序设计</h3><p>在知晓序列排序规律后，可以着手考虑将第k个元素找到。搜索定位的思想类似于一棵树的节点查找，这棵树的结构已经找到：第一层儿子有n个，第二层的孙子节点共有n*(n-1)个，且每个儿子拥有(n-1)个儿子，以此类推。</p>
<p>而第k个元素对应的元素如何计算出呢？根据这棵树的特点，我们可以做出如下设计，使得从树根到第k个节点的路径就是我们所需要的元素。</p>
<ol>
<li><p>假设树根节点是个空节点，其的n个儿子分别为1, 2, 3, 4, 5,…, n。</p>
</li>
<li><p>第一层的节点1拥有(n-1)个儿子，分别为2, 3, 4, 5,…n。</p>
</li>
<li><p>第二层节点2拥有(n-2)个儿子，分别为3, 4, 5,…n。 而第二层节点3拥有N(n-2)个儿子，分别为2, 4, 5,…n。尤其需要注意，儿子的顺序是除开父亲节点后的顺序结构。</p>
</li>
</ol>
<p>时间复杂度树的高度，为O(n)。</p>
<h3 id="实现技巧"><a href="#实现技巧" class="headerlink" title="实现技巧"></a>实现技巧</h3><blockquote>
<p>从1到n的全排列值计算具有较高的代码重复性， 可以用如下算法进行缓存，从而减少反复计算产生的时间消耗。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// dynamic length int array declaration!!!</span></span><br><span class="line"><span class="keyword">int</span>[] factorial = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line"><span class="comment">// create an array of factorial lookup</span></span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">1</span>;</span><br><span class="line">    factorial[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">        sum *= i;</span><br><span class="line">        factorial[i] = sum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>对于元素生成，可以运用List<integer>类型的灵活性而避免在元素中挪动数字造成的时间开销。即使int array也可以作为一种高效的数据结构。</integer></p>
</blockquote>
<blockquote>
<p>在程序实现中，递归算法会产生较高的空间开销，在for循环可以完成计算的情况下，优先采用后者。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line"><span class="comment">// create a list of numbers to get indices</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">    numbers.add(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// numbers = &#123;1, 2, 3, 4&#125;</span></span><br><span class="line"></span><br><span class="line">k--;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> index = k/factorial[n-i];</span><br><span class="line">        sb.append(String.valueOf(numbers.get(index)));</span><br><span class="line">        numbers.remove(index);</span><br><span class="line">        k-=index*factorial[n-i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> String.valueOf(sb);</span><br></pre></td></tr></table></figure>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>肉肉</tag>
        <tag>Permutation</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 560: Subarray Sum Equals K</title>
    <url>/2018/04/14/Leetcode-560-Subarray-Sum-Equals-K/</url>
    <content><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>Given an array of integers and an integer k, you need to find the total number of continuous subarrays whose sum equals to k.</p>
<p>Example 1:</p>
<p>Input:nums = [1,1,1], k = 2</p>
<p>Output: 2</p>
<p>Note:<br>The length of the array is in range [1, 20,000].<br>The range of numbers in the array is [-1000, 1000] and the range of the integer k is [-1e7, 1e7].</p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>本题不属于某类经典类型的算法题。本题的解题关键在于深刻理解子数组和的计算方法，以及和为K的子数组和个数的求解技巧。</p>
<p>首先，需要求得长度为n的数组的和为K的连续子数组的个数，设为A(n)。统计连续子数组的和，以及和的分布则成为解题的前提条件。在统计连续子数组的和的过程中，我们可以采用穷举法，将所有子数组的和都进行一次统计，也能运用一些巧妙的方法，只统计部分子数组的和的个数，计算出和为K的子数组和的个数。</p>
<p>为了达到优化子数组和统计的方法，可以仔细思考子数组和的计算方法。不难得出，子数组和的计算方法其实源于两个从零开始的数组和之差。也就是说，假设从A[m]到A[n]之间的子数组和S[m~n] = S[0~n] - S[0-m]。如果在已知S[0~i] (i=0,…,n-1)的值，就能轻松求解出所有子数组的和。</p>
<p>然而，这样的方法用于求所有的子数组的和，并不能简化计算复杂度。要找到和为K的子数组的个数，就等于需要便利S[0~i] (i=0,…,n)，并且找出末尾为第i个元素的子数组序列和为K的个数。由此不难推出，末尾为第i个元素的子数组序列和为K的个数，等价于S[m~i] (m=1,…,i-1)中和为K的个数，也等价于S[0~m] (m=1,…,i-1)中和为S[0~i]-K的子数组个数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Number(末尾为第i个元素的子数组序列和为K的个数)=Number(S[0~m] (m=1,...,i-1)中和为S[0~i]-K的子数组个数);</span><br><span class="line"></span><br><span class="line">Number(n长数组子数组序列和为K的个数)=sigma(Number(末尾为第i个元素的子数组序列和为K的个数)) (i=0,...n-1)</span><br></pre></td></tr></table></figure>
<h3 id="程序设计"><a href="#程序设计" class="headerlink" title="程序设计"></a>程序设计</h3><p>本题解的优劣则取决于统计子数组和的计算量。</p>
<ol>
<li>运用hashmap数据结构存取所有的子数组和，经过两次for循环遍历得出所有子数组可能性下的和的值，并统计入hashmap中。本解法的时间复杂度是O(n^2)。</li>
<li>优化后的算法采用hashmap数据结构存取S[0~i] (i=0,…n-1)，并且在每次计算后计算以i结尾的连续子数组和为K的个数。将所有数字相加则为综合。本解法的时间复杂度是O(n)。</li>
</ol>
<h3 id="实现技巧"><a href="#实现技巧" class="headerlink" title="实现技巧"></a>实现技巧</h3><blockquote>
<p>边界条件考虑：</p>
<ul>
<li>K=0的情况。</li>
<li>K=S[0~i] (i=0,…,n-1)中的任意一个情况</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt; ();</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> total =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; nums.length; ++i)&#123;</span><br><span class="line">            sum += nums[i];  </span><br><span class="line">            <span class="comment">// don't forget margin k = 0, check previous count before adding this count to avoid confustion.</span></span><br><span class="line">            <span class="keyword">if</span>( map.containsKey(sum-k))</span><br><span class="line">                total += map.get(sum-k);</span><br><span class="line">            <span class="keyword">if</span>(k == sum)</span><br><span class="line">                total += <span class="number">1</span>;</span><br><span class="line">               </span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(sum))</span><br><span class="line">                map.put(sum, map.get(sum)+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                map.put(sum, <span class="number">1</span>);                </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>肉肉</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 901 Online Stock Span</title>
    <url>/2018/10/11/Leetcode-901-Online-Stock-Span/</url>
    <content><![CDATA[<h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p>Write a class StockSpanner which collects daily price quotes for some stock, and returns the span of that stock’s price for the current day.</p>
<p>The span of the stock’s price today is defined as the maximum number of consecutive days (starting from today and going backwards) for which the price of the stock was less than or equal to today’s price.</p>
<p>For example, if the price of a stock over the next 7 days were [100, 80, 60, 70, 60, 75, 85], then the stock spans would be [1, 1, 1, 2, 1, 4, 6].</p>
<p>Example 1:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Input: [<span class="string">"StockSpanner"</span>,<span class="string">"next"</span>,<span class="string">"next"</span>,<span class="string">"next"</span>,<span class="string">"next"</span>,<span class="string">"next"</span>,<span class="string">"next"</span>,<span class="string">"next"</span>], [[],[100],[80],[60],[70],[60],[75],[85]]</span><br><span class="line">Output: [null,1,1,1,2,1,4,6]</span><br><span class="line">Explanation: </span><br><span class="line">First, S = StockSpanner() is initialized.  Then:</span><br><span class="line">S.next(100) is called and returns 1,</span><br><span class="line">S.next(80) is called and returns 1,</span><br><span class="line">S.next(60) is called and returns 1,</span><br><span class="line">S.next(70) is called and returns 2,</span><br><span class="line">S.next(60) is called and returns 1,</span><br><span class="line">S.next(75) is called and returns 4,</span><br><span class="line">S.next(85) is called and returns 6.</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Note that (for example) S.next(75) returned 4, because the last 4 prices<br>(including today’s price of 75) were less than or equal to today’s price.</p>
</blockquote>
<p>Note:</p>
<ol>
<li>Calls to StockSpanner.next(int price) will have 1 &lt;= price &lt;= 10^5.</li>
<li>There will be at most 10000 calls to StockSpanner.next per test case.</li>
<li>There will be at most 150000 calls to StockSpanner.next across all test cases.</li>
<li>The total time limit for this problem has been reduced by 75% for C++, and 50% for all other languages.</li>
</ol>
<h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>本题考验的是对Java Stack类的熟练使用。</p>
<h2 id="O-n-复杂度思路"><a href="#O-n-复杂度思路" class="headerlink" title="O(n)复杂度思路"></a>O(n)复杂度思路</h2><p>不难发现，运用两个Stack可以灵活的将数组中的数字进行遍历比较，从而得出结果。但是由于Leetcode对于时间复杂度要求较高，因此同为O(n)算法，需要最大化的优化其系数，从而通过时间限制测试。</p>
<p><strong>Leetcode solution中提出的一种简化计算的方法</strong></p>
<p>在仔细分析对比数组的计算结果后，不难得出以下几个结论：</p>
<ul>
<li>当数组元素值减少时,权重结果为1；</li>
<li>当数组元素值增加时，倒推前面小于该值的连续区间可以替换成局部最大值和其局部权重weight。局部最大值即当前元素值；而最末元素的权重，正好是其前面小于该值的连续区间的权重和+1。权重值则为我们需要的返回值。</li>
</ul>
<p>以Example中的数组为例，用Stack&lt;int[]&gt;表示分步计算结果为：</p>
<ol>
<li>[100, 1]</li>
<li>[100, 1], [80, 1]</li>
<li>[100, 1], [80, 1], [60, 1]</li>
<li>[100, 1], [80, 1], <strong>[70, 2]</strong></li>
<li>[100, 1], [80, 1], [70, 2], [60, 1]</li>
<li>[100, 1], [80, 1], <strong>[75, 4]</strong></li>
<li>[100, 1], <strong>[85, 6]</strong><br>…</li>
</ol>
<h2 id="实现技巧"><a href="#实现技巧" class="headerlink" title="实现技巧"></a>实现技巧</h2><p>需要注意的本解法并没有简化时间复杂度，因为在最差情况下（数列递减），计算的复杂度为O(n)。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StockSpanner</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; prices, weights;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StockSpanner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        prices = <span class="keyword">new</span> Stack();</span><br><span class="line">        weights = <span class="keyword">new</span> Stack();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">(<span class="keyword">int</span> price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> w = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!prices.isEmpty() &amp;&amp; prices.peek() &lt;= price) &#123;</span><br><span class="line">            prices.pop();</span><br><span class="line">            w += weights.pop();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        prices.push(price);</span><br><span class="line">        weights.push(w);</span><br><span class="line">        <span class="keyword">return</span> w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>肉肉</tag>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title>My Book List</title>
    <url>/2018/04/30/My-Book-List/</url>
    <content><![CDATA[<h1 id="读书是一个很好的习惯"><a href="#读书是一个很好的习惯" class="headerlink" title="读书是一个很好的习惯"></a>读书是一个很好的习惯</h1><h2 id="Books-that-I-have-read"><a href="#Books-that-I-have-read" class="headerlink" title="Books that I have read"></a>Books that I have read</h2><table>
<thead>
<tr>
<th style="text-align:left">书名</th>
<th style="text-align:left">完成时间</th>
<th style="text-align:center">评分/10</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">&lt;&lt;明朝那些事儿&gt;&gt;</td>
<td style="text-align:left">2013</td>
<td style="text-align:center">8</td>
</tr>
<tr>
<td style="text-align:left">&lt;&lt;卑鄙的圣人:曹操 1-6&gt;&gt;</td>
<td style="text-align:left">2018-Jun</td>
<td style="text-align:center">7</td>
</tr>
<tr>
<td style="text-align:left">&lt;&lt;力哥说理财：小白理财入门必修课&gt;&gt;</td>
<td style="text-align:left">2018-Aug</td>
<td style="text-align:center">6</td>
</tr>
<tr>
<td style="text-align:left">&lt;&lt;卑鄙的圣人:曹操 7&gt;&gt;</td>
<td style="text-align:left">2018-Oct</td>
<td style="text-align:center">7</td>
</tr>
<tr>
<td style="text-align:left">&lt;&lt;凤凰项目：一个IT运维的传奇故事&gt;&gt;</td>
<td style="text-align:left">2018-Nov</td>
<td style="text-align:center">9</td>
</tr>
<tr>
<td style="text-align:left">&lt;&lt;深入理解Java虚拟机JVM高级特性与最佳实践&gt;&gt;</td>
<td style="text-align:left">2019-Mar</td>
<td style="text-align:center">10</td>
</tr>
<tr>
<td style="text-align:left">&lt;&lt; Java并发编程的艺术&gt;&gt;</td>
<td style="text-align:left">2019-Dec</td>
<td style="text-align:center">10</td>
</tr>
<tr>
<td style="text-align:left">&lt;&lt;微服务设计&gt;&gt;</td>
<td style="text-align:left">2020-Feb</td>
<td style="text-align:center">8</td>
</tr>
<tr>
<td style="text-align:left">&lt;&lt;番茄工作法&gt;&gt;</td>
<td style="text-align:left">2021-May</td>
<td style="text-align:center">10</td>
</tr>
<tr>
<td style="text-align:left">&lt;&lt;高敏感是种天赋&gt;&gt;</td>
<td style="text-align:left">2021-Jun</td>
<td style="text-align:center">9</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="Books-that-I-am-reading"><a href="#Books-that-I-am-reading" class="headerlink" title="Books that I am reading"></a>Books that I am reading</h2><table>
<thead>
<tr>
<th style="text-align:left">书名</th>
<th style="text-align:center">进度</th>
<th style="text-align:right">上次阅读时间</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">&lt;&lt;快学scala&gt;&gt;</td>
<td style="text-align:center">50%</td>
<td style="text-align:right">2021-May</td>
</tr>
<tr>
<td style="text-align:left">&lt;&lt;价值投资——原理与实战&gt;&gt;</td>
<td style="text-align:center">22/151</td>
<td style="text-align:right">2021-Jun</td>
</tr>
<tr>
<td style="text-align:left">&lt;&lt;大型网站——技术架构演进与性能优化&gt;&gt;</td>
<td style="text-align:center">5%</td>
<td style="text-align:right">2021-Jun</td>
</tr>
<tr>
<td style="text-align:left">面向模式的软件架构——模式系统</td>
<td style="text-align:center">5%</td>
<td style="text-align:right">2021-Feb</td>
</tr>
<tr>
<td style="text-align:left">&lt;&lt;深入理解Java Web技术内幕&gt;&gt;</td>
<td style="text-align:center">280/491</td>
<td style="text-align:right">2019-Dec</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="Books-that-I-want-to-read"><a href="#Books-that-I-want-to-read" class="headerlink" title="Books that I want to read"></a>Books that I want to read</h2><table>
<thead>
<tr>
<th style="text-align:left">书名</th>
<th style="text-align:center">原因</th>
<th style="text-align:right">优先级</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">&lt;&lt; Spring技术内幕&gt;&gt;</td>
<td style="text-align:center">Spring原理讲解</td>
<td style="text-align:right">I</td>
</tr>
<tr>
<td style="text-align:left">&lt;&lt;巴菲特之道&gt;&gt;</td>
<td style="text-align:center">理财启蒙</td>
<td style="text-align:right">II</td>
</tr>
<tr>
<td style="text-align:left">&lt;&lt;大数据技术体系详解:原理、架构与实践&gt;&gt;</td>
<td style="text-align:center">大数据概述</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td style="text-align:left">&lt;&lt;企业级大数据平台构建:架构与实现&gt;&gt;</td>
<td style="text-align:center">大数据概述</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td style="text-align:left">&lt;&lt; Spark Streaming实时流式大数据处理实战&gt;&gt;</td>
<td style="text-align:center">大数据实战</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td style="text-align:left">&lt;&lt;亿级流量网站架构核心技术&gt;&gt;</td>
<td style="text-align:center">高并发项目实践</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td style="text-align:left">&lt;&lt; Web性能权威指南&gt;&gt;</td>
<td style="text-align:center">网络项目编程优化</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="Books-of-reference"><a href="#Books-of-reference" class="headerlink" title="Books of reference"></a>Books of reference</h2><table>
<thead>
<tr>
<th style="text-align:left">书名</th>
<th style="text-align:center">进度</th>
<th style="text-align:right">上次阅读时间</th>
<th style="text-align:left">参考原因</th>
<th style="text-align:left">类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">&lt;&lt; Spring实战&gt;&gt;</td>
<td style="text-align:center">10%</td>
<td style="text-align:right">后端主流框架</td>
<td style="text-align:left">2019-Oct</td>
<td style="text-align:left">工具书</td>
</tr>
<tr>
<td style="text-align:left">&lt;&lt; Spring boot实战&gt;&gt;</td>
<td style="text-align:center">5%</td>
<td style="text-align:right">后端小白主流框架</td>
<td style="text-align:left">2019-Oct</td>
<td style="text-align:left">工具书</td>
</tr>
<tr>
<td style="text-align:left">&lt;&lt; Spring Cloud 实战&gt;&gt;</td>
<td style="text-align:center">5%</td>
<td style="text-align:right">DevOps主流框架</td>
<td style="text-align:left">2020-Dec</td>
<td style="text-align:left">工具书</td>
</tr>
<tr>
<td style="text-align:left">&lt;&lt; React实战&gt;&gt;</td>
<td style="text-align:center">20%</td>
<td style="text-align:right">前端主流框架</td>
<td style="text-align:left">2021-Apr</td>
<td style="text-align:left">工具书</td>
</tr>
<tr>
<td style="text-align:left">&lt;&lt; Electron实战&gt;&gt;</td>
<td style="text-align:center">50%</td>
<td style="text-align:right">跨平台客户端框架</td>
<td style="text-align:left">2021-Apr</td>
<td style="text-align:left">工具书</td>
</tr>
<tr>
<td style="text-align:left">&lt;&lt; PWA实战&gt;&gt;</td>
<td style="text-align:center">30%</td>
<td style="text-align:right">前端演进框架</td>
<td style="text-align:left">2021-Apr</td>
<td style="text-align:left">工具书</td>
</tr>
</tbody>
</table>
<h2 id="Books-that-I-am-not-reading-for-months"><a href="#Books-that-I-am-not-reading-for-months" class="headerlink" title="Books that I am not reading for months"></a>Books that I am not reading for months</h2><table>
<thead>
<tr>
<th style="text-align:left">书名</th>
<th style="text-align:center">进度</th>
<th style="text-align:right">上次阅读时间</th>
<th style="text-align:left">原因</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">&lt;&lt;张爱玲全集01：倾城之恋&gt;&gt;</td>
<td style="text-align:center">529/1025</td>
<td style="text-align:right">2018-Aug</td>
<td style="text-align:left">闲书</td>
</tr>
<tr>
<td style="text-align:left">&lt;&lt;深入理解C#&gt;&gt;</td>
<td style="text-align:center">30%</td>
<td style="text-align:right">2017-Nov</td>
<td style="text-align:left">目前专注Java</td>
</tr>
<tr>
<td style="text-align:left">&lt;&lt;卑鄙的圣人:曹操 8&gt;&gt;</td>
<td style="text-align:center">716/1187</td>
<td style="text-align:right">2018-Oct</td>
<td style="text-align:left">闲书</td>
</tr>
<tr>
<td style="text-align:left">&lt;&lt;知乎：金钱有术&gt;&gt;</td>
<td style="text-align:center">283/788</td>
<td style="text-align:right">2018-Sep</td>
<td style="text-align:left">闲书</td>
</tr>
<tr>
<td style="text-align:left">&lt;&lt;算法设计与分析基础 by Anany Levitin&gt;&gt;</td>
<td style="text-align:center"></td>
<td style="text-align:right">2018-Sep</td>
<td style="text-align:left">没有时间</td>
</tr>
<tr>
<td style="text-align:left">&lt;&lt;算法设计与分析（王晓东）&gt;&gt;</td>
<td style="text-align:center"></td>
<td style="text-align:right">2018-May</td>
<td style="text-align:left">没有时间</td>
</tr>
<tr>
<td style="text-align:left">&lt;&lt; CLR via C#&gt;&gt;</td>
<td style="text-align:center">693/798</td>
<td style="text-align:right">2019-Feb</td>
<td style="text-align:left">没有时间</td>
</tr>
<tr>
<td style="text-align:left">&lt;&lt; Office 365 开发入门指南&gt;&gt;</td>
<td style="text-align:center">15%</td>
<td style="text-align:right">2019-Sept</td>
<td style="text-align:left">领域不再关注</td>
</tr>
</tbody>
</table>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>肉肉</tag>
      </tags>
  </entry>
  <entry>
    <title>How to use Hexo on github pages.</title>
    <url>/2018/04/08/My-first-post/</url>
    <content><![CDATA[<h2 id="Welcome-to-Sunny’s-hexo-post"><a href="#Welcome-to-Sunny’s-hexo-post" class="headerlink" title="Welcome to Sunny’s hexo post"></a>Welcome to Sunny’s hexo post</h2><p>本文主要介绍一种常见的个人博客管理方式，利用现有的Hexo静态博客模板管理和生成静态博客文档，和github pages对git repo页面的原生发布功能进行博客展示。同时，博客文档也能在本地生成，部署，存档，较于现有的博客工具具有更好的功能扩展。</p>
<h3 id="Prepare-Node-js"><a href="#Prepare-Node-js" class="headerlink" title="Prepare Node.js"></a>Prepare Node.js</h3><p>Hexo is Node.js based npm plugin, which provides many extensions and powerful blog management functionality.</p>
<h3 id="Use-Hexo-to-manage-blogs"><a href="#Use-Hexo-to-manage-blogs" class="headerlink" title="Use Hexo to manage blogs"></a>Use Hexo to manage blogs</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install hexo --save</span><br><span class="line">$ hexo init</span><br><span class="line">$ hexo new <span class="string">"My New Post"</span> <span class="comment"># hexo new draft "My New Draft"</span></span><br><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<h3 id="Use-SSH-git-management"><a href="#Use-SSH-git-management" class="headerlink" title="Use SSH git management"></a>Use SSH git management</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C <span class="string">"&#123;yourgithubaddress&#125;"</span></span><br><span class="line">$ ssh -T git@github.com</span><br></pre></td></tr></table></figure>
<h3 id="Create-username-github-io-repo-for-statics-hexo-pages"><a href="#Create-username-github-io-repo-for-statics-hexo-pages" class="headerlink" title="Create {username}.github.io repo for statics hexo pages"></a>Create {username}.github.io repo for statics hexo pages</h3><h3 id="Configure-config-yml-file-for-hexo-blogs-and-deployments"><a href="#Configure-config-yml-file-for-hexo-blogs-and-deployments" class="headerlink" title="Configure _config.yml file for hexo blogs and deployments"></a>Configure _config.yml file for hexo blogs and deployments</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"># URL</span><br><span class="line">## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'</span><br><span class="line">url: https://&#123;username&#125;.github.io/</span><br><span class="line"></span><br><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/deployment.html</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:&#123;username&#125;/&#123;username&#125;.githubm.io.git</span><br><span class="line">  branch: master</span><br><span class="line">  message: "Site updated: &#123;&#123; now('YYYY-MM-DD HH:mm:ss') &#125;&#125;"</span><br></pre></td></tr></table></figure>
<h3 id="Deploy-hexo-static-files-to-target-repo"><a href="#Deploy-hexo-static-files-to-target-repo" class="headerlink" title="Deploy hexo static files to target repo"></a>Deploy hexo static files to target repo</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo clean</span><br><span class="line">$ hexo generate</span><br><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>Useful links:<br><a href="https://blog.csdn.net/android_msk/article/details/75040841" target="_blank" rel="noopener">Hexo with pictures</a>,<br><a href="https://bingyue.github.io/2017/03/08/%E4%BD%BF%E7%94%A8Github-Pages%E5%92%8CHexo%E6%9E%84%E5%BB%BA%E5%8D%9A%E5%AE%A2/" target="_blank" rel="noopener">Hexo Deployment</a>,<br><a href="https://yq.aliyun.com/articles/72002" target="_blank" rel="noopener">Jekyll vs Hexo</a>,<br><a href="https://coding.net/help/doc/project/markdown.html" target="_blank" rel="noopener">Markdown</a>,<br><a href="https://www.jianshu.com/p/1e402922ee32/" target="_blank" rel="noopener">Markdown brief</a>,<br><a href="https://blog.csdn.net/u013553529/article/details/50629055" target="_blank" rel="noopener">Markdown highlights</a></p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>Runbooks</category>
      </categories>
      <tags>
        <tag>肉肉</tag>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>Microsoft Graph API</title>
    <url>/2021/04/16/Microsoft-Graph-API/</url>
    <content><![CDATA[<h1 id="What-is-Graph-API"><a href="#What-is-Graph-API" class="headerlink" title="What is Graph API"></a>What is Graph API</h1><p><a href="https://docs.microsoft.com/en-us/graph/use-the-api" target="_blank" rel="noopener">Graph API documents</a></p>
<h1 id="Graph-API-authentication"><a href="#Graph-API-authentication" class="headerlink" title="Graph API authentication"></a>Graph API authentication</h1><p><a href="https://docs.microsoft.com/en-us/graph/auth/" target="_blank" rel="noopener">How to get Auth tokens</a></p>
<h1 id="OAuth-Authentication-flows"><a href="#OAuth-Authentication-flows" class="headerlink" title="OAuth Authentication flows"></a>OAuth Authentication flows</h1><p><a href="https://docs.microsoft.com/en-us/azure/active-directory/develop/active-directory-v2-protocols" target="_blank" rel="noopener">Microsoft Introduction</a></p>
<p><a href="https://docs.microsoft.com/en-us/azure/active-directory/develop/authentication-flows-app-scenarios" target="_blank" rel="noopener">Apps and authentication senarios</a></p>
<h1 id="Call-Graph-API-from-Office-Web-Addin"><a href="#Call-Graph-API-from-Office-Web-Addin" class="headerlink" title="Call Graph API from Office Web Addin"></a>Call Graph API from Office Web Addin</h1><h2 id="Call-via-https-outlook-office-com-api"><a href="#Call-via-https-outlook-office-com-api" class="headerlink" title="Call via https://outlook.office.com/api"></a>Call via <a href="https://outlook.office.com/api" target="_blank" rel="noopener">https://outlook.office.com/api</a></h2><p><a href="https://docs.microsoft.com/en-us/office/dev/add-ins/outlook/use-rest-api" target="_blank" rel="noopener">Call visa Office.js for Outlook REST API</a></p>
<p><a href="https://docs.microsoft.com/en-us/previous-versions/office/office-365-api/api/version-2.0/use-outlook-rest-api" target="_blank" rel="noopener">Outlook REST API via outlook.office.com</a></p>
<h2 id="Call-via-https-grsph-microsoft-com"><a href="#Call-via-https-grsph-microsoft-com" class="headerlink" title="Call via https://grsph.microsoft.com/"></a>Call via <a href="https://grsph.microsoft.com/" target="_blank" rel="noopener">https://grsph.microsoft.com/</a></h2><h3 id="with-Authentication-with-SSO-token"><a href="#with-Authentication-with-SSO-token" class="headerlink" title="with Authentication with SSO token"></a>with Authentication with SSO token</h3><p><a href="https://docs.microsoft.com/en-us/office/dev/add-ins/develop/sso-in-office-add-ins" target="_blank" rel="noopener">Microsfot Setup Guide</a></p>
<p><a href="https://docs.microsoft.com/en-us/office/dev/add-ins/develop/register-sso-add-in-aad-v2" target="_blank" rel="noopener">AAD client app registration</a></p>
<p><a href="https://docs.microsoft.com/en-us/office/dev/add-ins/develop/troubleshoot-sso-in-office-add-ins" target="_blank" rel="noopener">Troubleshooting GetAccessToken</a></p>
<h1 id="Other-Option-use-EWS-call-from-Office-js"><a href="#Other-Option-use-EWS-call-from-Office-js" class="headerlink" title="Other Option: use EWS call from Office.js"></a>Other Option: use EWS call from Office.js</h1><p><a href="https://docs.microsoft.com/en-us/office/dev/add-ins/outlook/web-services" target="_blank" rel="noopener">call EWS from Office.js</a></p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <tags>
        <tag>肉肉</tag>
      </tags>
  </entry>
  <entry>
    <title>Office 365 Addin ESC POC</title>
    <url>/2020/11/07/Office-365-Addin-ESC-POC/</url>
    <content><![CDATA[<h1 id="project-bootstrap"><a href="#project-bootstrap" class="headerlink" title="project bootstrap"></a>project bootstrap</h1><p> Demo项目是通过VS2019自带的Addin模板生成。默认debug模式部署在一个o365 dev tenant上。目前已有Github demo项目也可以直接下载，相关<a href="https://docs.microsoft.com/en-us/office/dev/add-ins/outlook/outlook-on-send-addins?tabs=windows#install-outlook-add-ins-that-use-on-send" target="_blank" rel="noopener">链接</a>。</p>
<h2 id="Demo-项目原型简述"><a href="#Demo-项目原型简述" class="headerlink" title="Demo 项目原型简述"></a>Demo 项目原型简述</h2><p>引入demo项目是一个查看邮件各种属性的ESCPOC项目，在读取一封邮件时，可以点击ESCPOC按钮查看邮件的属性。在启动debug并上传manifest后，点击Ribbon上的MyAddinGroup按钮，显示如下图所示：</p>
<p> <img src="/2020/11/07/Office-365-Addin-ESC-POC/ESCPOC.PNG" alt="ESCPOCDemo"></p>
<p>我们的目标POC项目是一个非常简单的发送弹框程序，需要订阅每一封邮件的发送事件itemsend并且根据Web API调用结果显示一个web UI.</p>
<h3 id="ESCPOC-xml-修改剖析"><a href="#ESCPOC-xml-修改剖析" class="headerlink" title="ESCPOC.xml 修改剖析"></a>ESCPOC.xml 修改剖析</h3><p>Manifest文件是O365插件加载的关键配置，需要完全符合schema定义的规则才能正确显式UI以及相应的回调API。</p>
<ol>
<li>Validation<br>Manifest 文件具有很强的格式要求，需要运用微软提供的工具对自己的manifest文件进行语法检查。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#install latest version</span></span><br><span class="line">npm install -g office-addin-manifest</span><br><span class="line">office-addin-manifest validate PATH_MANIFEST_FILE</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>创建ItemSend相关配置<br>目前微软已经有开源的示例代码于<a href="https://github.com/OfficeDev/outlook-add-in-command-demo，可以作为参考。" target="_blank" rel="noopener">https://github.com/OfficeDev/outlook-add-in-command-demo，可以作为参考。</a><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Event</span> <span class="attr">Type</span>=<span class="string">"ItemSend"</span> <span class="attr">FunctionExecution</span>=<span class="string">"synchronous"</span> <span class="attr">FunctionName</span>=<span class="string">"itemSendHandler"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>注意配置上下文需要在VersionOverrides 1.1框架下。</p>
<h2 id="O365-环境准备"><a href="#O365-环境准备" class="headerlink" title="O365 环境准备"></a>O365 环境准备</h2><p>对于跨平台的O365 Addin，一个合法的O365账号是需要的，而且需要拥有上传插件的权限。在用用MSDN订阅的情况下，可以创建合适的E3等级Office Tenant。例如本文则使用<a href="mailto:huangsun@sunnyhll.onmicrosoft.com" target="_blank" rel="noopener">huangsun@sunnyhll.onmicrosoft.com</a>作为测试账号，密码为系统密码。</p>
<p>Web Addin查看可以点击Outlook桌面客户端的Manage Addin按钮，也可以在<a href="https://outlook.office365.com/owa/?path=/options/manageapps" target="_blank" rel="noopener">https://outlook.office365.com/owa/?path=/options/manageapps</a> 链接中看到。可以看到即使安装了很多插件，这些插件却不是实时安装在本地Outlook桌面客户端上的， 而是在需要访问的时候才进行加载执行的。</p>
<h3 id="开启ItemSend事件监听"><a href="#开启ItemSend事件监听" class="headerlink" title="开启ItemSend事件监听"></a>开启ItemSend事件监听</h3><p>相关<a href="https://docs.microsoft.com/en-us/powershell/exchange/exchange-online/connect-to-exchange-online-powershell/connect-to-exchange-online-powershell?view=exchange-ps" target="_blank" rel="noopener">链接</a>.</p>
<h3 id="“My-Custom-Roles”权限"><a href="#“My-Custom-Roles”权限" class="headerlink" title="“My Custom Roles”权限"></a>“My Custom Roles”权限</h3><p>对于个人O365账号，这里不需要进行权限获取，Microsoft Tenant默认每个客户的SideLoad权限开启。</p>
<h3 id="Web-Addin部署"><a href="#Web-Addin部署" class="headerlink" title="Web Addin部署"></a>Web Addin部署</h3><p>对于Outlook Web Addin, 主要分成两部分部署：</p>
<ul>
<li>Manifest配置文件部署，在Exchange Mailbox 上注册插件</li>
<li>插件服务部署，必须采用https协议，插件服务前后端本身需要在同一域名下。<br>部署完成即可进行测试。</li>
</ul>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <tags>
        <tag>肉肉</tag>
        <tag>Office Addin</tag>
      </tags>
  </entry>
  <entry>
    <title>Office 365 Addin development guide</title>
    <url>/2019/04/12/Office-365-Addin-development-guide/</url>
    <content><![CDATA[<p>This is a guide for how to develop Office 365 cross platform addin.</p>
<h1 id="Front-end-UI-framework"><a href="#Front-end-UI-framework" class="headerlink" title="Front end UI framework"></a>Front end UI framework</h1><p>Microsoft has provided offical Office UI framework: Office Fabric UI. The office site is at <a href="https://developer.microsoft.com/en-us/fabric" target="_blank" rel="noopener">https://developer.microsoft.com/en-us/fabric</a>. The are three directions of the UI project future roadmap. All the three projects are implementation of UI components, demos are available at <a href="https://developer.microsoft.com/en-us/fabric#/components" target="_blank" rel="noopener">https://developer.microsoft.com/en-us/fabric#/components</a>.</p>
<ol>
<li>Fabric React (Official support)</li>
<li>AngularJS (Community version, no updates)</li>
<li>Fabric iOS</li>
<li>Fabric JS (Stop support from MSFT)</li>
</ol>
<p>New UI design sytem is called fluent, the website is at <a href="https://www.microsoft.com/design/fluent/" target="_blank" rel="noopener">https://www.microsoft.com/design/fluent/</a>. It can help let developer know how to design an Windows style application UI and the guide of UWP web app design. </p>
<p>Fabric.js is an open source js framework using canvas as the basic style of UI components, the official site is at <a href="http://fabricjs.com/" target="_blank" rel="noopener">http://fabricjs.com/</a>.</p>
<h2 id="Useful-links"><a href="#Useful-links" class="headerlink" title="Useful links:"></a>Useful links:</h2><p>Directly reuse existing Microsoft designed and implemented components is very convinient as long as your application can work well with these codes.</p>
<ul>
<li>Office UI Fabric Core (Style and fonts): <a href="https://github.com/OfficeDev/office-ui-fabric-core" target="_blank" rel="noopener">https://github.com/OfficeDev/office-ui-fabric-core</a></li>
<li>Office UI Fabric React (Full components): <a href="https://github.com/OfficeDev/office-ui-fabric-react" target="_blank" rel="noopener">https://github.com/OfficeDev/office-ui-fabric-react</a></li>
<li>Office UI Fabric JS (Full components in JS): <a href="https://github.com/OfficeDev/office-ui-fabric-js/" target="_blank" rel="noopener">https://github.com/OfficeDev/office-ui-fabric-js/</a></li>
</ul>
<p>Except Windows style UI frameworks, there are other frameworks using morden components:</p>
<ul>
<li>Material-UI: <a href="https://www.jianshu.com/p/b3cfaca94596" target="_blank" rel="noopener">https://www.jianshu.com/p/b3cfaca94596</a> , <a href="https://material-ui.com/getting-started/example-projects/" target="_blank" rel="noopener">https://material-ui.com/getting-started/example-projects/</a></li>
<li>PrimeNG: <a href="https://www.primefaces.org/primeng" target="_blank" rel="noopener">https://www.primefaces.org/primeng</a> </li>
</ul>
<h1 id="Front-end-Office-js-framework"><a href="#Front-end-Office-js-framework" class="headerlink" title="Front end Office.js framework"></a>Front end Office.js framework</h1><p>Office.js is the JavaScript based Office model provided by Microsoft, there are also Excel-15.js or Outlook-15.js for application respectively.</p>
<h2 id="Office-JavaScript-API-object-model"><a href="#Office-JavaScript-API-object-model" class="headerlink" title="Office JavaScript API object model"></a>Office JavaScript API object model</h2><p>This doc <a href="https://docs.microsoft.com/en-us/office/dev/add-ins/develop/office-javascript-api-object-model" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/office/dev/add-ins/develop/office-javascript-api-object-model</a> explains the API model for new O365 addin JS model.</p>
<p>The object is still under active development, there are more and more new features added, reading the documents can get the updated information. As for now, there are below bullet points:</p>
<p><img src="/2019/04/12/Office-365-Addin-development-guide/AddinJSModel.PNG" alt="JSAddinFeatures"></p>
<p>This is also guide for how to develop Addin with Angular front end. <a href="https://docs.microsoft.com/en-us/office/dev/add-ins/develop/add-ins-with-angular2" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/office/dev/add-ins/develop/add-ins-with-angular2</a></p>
<p>Office appication has its own object model, so developers can read the related documents for detailed guide.</p>
<h2 id="Outlook-Backend-service"><a href="#Outlook-Backend-service" class="headerlink" title="Outlook Backend service"></a>Outlook Backend service</h2><p>Except the general Office JS API model, Outlook has its own API. The development guide is at <a href="https://docs.microsoft.com/en-us/outlook/add-ins/" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/outlook/add-ins/</a>. </p>
<h3 id="Manifest-version-and-corresponding-clients-support"><a href="#Manifest-version-and-corresponding-clients-support" class="headerlink" title="Manifest version and corresponding clients support"></a>Manifest version and corresponding clients support</h3><p><img src="/2019/04/12/Office-365-Addin-development-guide/ClientSupport.PNG" alt="ClientSupport"></p>
<p>Troubleshooting manifest file <a href="https://docs.microsoft.com/en-us/office/dev/add-ins/testing/troubleshoot-manifest#to-use-the-office-add-in-validator-to-validate-your-manifest" target="_blank" rel="noopener">here</a></p>
<h3 id="Outlook-Web-Addin-Catalogs"><a href="#Outlook-Web-Addin-Catalogs" class="headerlink" title="Outlook Web Addin Catalogs"></a>Outlook Web Addin Catalogs</h3><p>Outlook Addin has its own concepts and there are many aspects:</p>
<p><img src="/2019/04/12/Office-365-Addin-development-guide/OutlookConcepts.PNG" alt="OutlookCatalog"></p>
<h3 id="Sample-Addins-for-Outlook"><a href="#Sample-Addins-for-Outlook" class="headerlink" title="Sample Addins for Outlook"></a>Sample Addins for Outlook</h3><p><a href="https://developer.microsoft.com/zh-cn/outlook/gallery/?filterBy=Outlook,Samples,Add-ins" target="_blank" rel="noopener">https://developer.microsoft.com/zh-cn/outlook/gallery/?filterBy=Outlook,Samples,Add-ins</a> </p>
<h1 id="Other-Office-Web-Addin-Demos"><a href="#Other-Office-Web-Addin-Demos" class="headerlink" title="Other Office Web Addin Demos"></a>Other Office Web Addin Demos</h1><ul>
<li>Word Style Checker: <a href="https://github.com/OfficeDev/Word-Add-in-Angular2-StyleChecker" target="_blank" rel="noopener">https://github.com/OfficeDev/Word-Add-in-Angular2-StyleChecker</a></li>
<li>Word task pane add-in: <a href="https://github.com/OfficeDev/Office-Add-in-Fabric-UI-Sample" target="_blank" rel="noopener">https://github.com/OfficeDev/Office-Add-in-Fabric-UI-Sample</a></li>
<li>Outlook Addin: <a href="https://github.com/OfficeDev/outlook-add-in-attachments-demo" target="_blank" rel="noopener">https://github.com/OfficeDev/outlook-add-in-attachments-demo</a></li>
<li>Word dialog Addin: <a href="https://github.com/OfficeDev/Office-Add-in-Dialog-API-Simple-Example" target="_blank" rel="noopener">https://github.com/OfficeDev/Office-Add-in-Dialog-API-Simple-Example</a></li>
</ul>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <tags>
        <tag>肉肉</tag>
        <tag>Office Addin</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2018/04/01/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>
<h3 id="Nodejs-and-NPM-requirement"><a href="#Nodejs-and-NPM-requirement" class="headerlink" title="Nodejs and NPM requirement"></a>Nodejs and NPM requirement</h3><p>Nodejs higher than 6.0.0 and NPM higher than 5. Otherwise, Hexo might not work with some strange error!!</p>
<h3 id="Hexo-Mermaid-for-graph"><a href="#Hexo-Mermaid-for-graph" class="headerlink" title="Hexo Mermaid for graph"></a>Hexo Mermaid for graph</h3><p>More info: <a href="https://github.com/webappdevelp/hexo-filter-mermaid-diagrams" target="_blank" rel="noopener">Here</a></p>
<ul>
<li><p>Flow chart</p>
<pre class="mermaid">graph TD;
  A-->B;
  A-->C;
  B-->D;
  C-->D;</pre>
</li>
<li><p>Gannt diagram</p>
</li>
</ul>
<pre class="mermaid">gantt
    dateFormat  YYYY-MM-DD
    title       Adding GANTT diagram functionality to mermaid
    excludes    weekends
    %% (`excludes` accepts specific dates in YYYY-MM-DD format, days of the week ("sunday") or "weekends", but not the word "weekdays".)

    section A section
    Completed task            :done,    des1, 2014-01-06,2014-01-08
    Active task               :active,  des2, 2014-01-09, 3d
    Future task               :         des3, after des2, 5d
    Future task2              :         des4, after des3, 5d

    section Critical tasks
    Completed task in the critical line :crit, done, 2014-01-06,24h
    Implement parser and jison          :crit, done, after des1, 2d
    Create tests for parser             :crit, active, 3d
    Future task in critical line        :crit, 5d
    Create tests for renderer           :2d
    Add to mermaid                      :1d

    section Documentation
    Describe gantt syntax               :active, a1, after des1, 3d
    Add gantt diagram to demo page      :after a1  , 20h
    Add another diagram to demo page    :doc1, after a1  , 48h

    section Last section
    Describe gantt syntax               :after doc1, 3d
    Add gantt diagram to demo page      :20h
    Add another diagram to demo page    :48h</pre>


<h3 id="Hexo-simple-mindmap"><a href="#Hexo-simple-mindmap" class="headerlink" title="Hexo simple mindmap"></a>Hexo simple mindmap</h3><p>Hexo simple mindmap插件提供了对脑图的可视化支持，相较于mermaid插件的流程图，能够提供更加原生的脑图体验。</p>
<p>More info：<a href="https://hunterx.xyz/use-mindmap-in-hexo.html" target="_blank" rel="noopener">here</a></p>
<ul>
<li>Example</li>
</ul>
<blockquote class="pullquote mindmap mindmap-md"><ul>
<li>软件架构师思维导图<ul>
<li>代码规范<ul>
<li>设计模式</li>
<li>重构</li>
<li>源码学习与分析</li>
<li>复杂系统面向对象模型设计</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="Hexo-search功能"><a href="#Hexo-search功能" class="headerlink" title="Hexo search功能"></a>Hexo search功能</h3><p>随着文章数量增加，每一页寻找文档变得耗时间，所以增加了search功能来支持快速文章定位功能。</p>
<p>More info: <a href="https://huangweicai.github.io/2019/01/12/Hexo%E5%A2%9E%E5%8A%A0%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD/" target="_blank" rel="noopener">here</a></p>
<ol>
<li>下载插件</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>配置_config.yaml文件</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">search:</span></span><br><span class="line"><span class="attr">  path:</span> <span class="string">search.xml</span></span><br><span class="line"><span class="attr">  field:</span> <span class="string">post</span></span><br><span class="line"><span class="attr">  format:</span> <span class="string">html</span></span><br><span class="line"><span class="attr">  limit:</span> <span class="number">10000</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>配置next主题的_config.yaml文件</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Local search</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/flashlab/hexo-generator-search</span></span><br><span class="line"><span class="attr">local_search:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># if auto, trigger search by changing input</span></span><br><span class="line">  <span class="comment"># if manual, trigger search by pressing enter key or search button</span></span><br><span class="line"><span class="attr">  trigger:</span> <span class="string">auto</span></span><br><span class="line">  <span class="comment"># show top n results per article, show all results by setting to -1</span></span><br><span class="line"><span class="attr">  top_n_per_article:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
  </entry>
  <entry>
    <title>React Fundamentals</title>
    <url>/2021/05/01/React-Fundamentals/</url>
    <content><![CDATA[<h1 id="Architecture-Overview"><a href="#Architecture-Overview" class="headerlink" title="Architecture Overview"></a>Architecture Overview</h1><h1 id="Design-In-Depth"><a href="#Design-In-Depth" class="headerlink" title="Design In Depth"></a>Design In Depth</h1><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
  </entry>
  <entry>
    <title>Ubuntu-subsystem</title>
    <url>/2018/04/14/ubuntu-subsystem/</url>
    <content><![CDATA[<h2 id="Ubuntu-on-Windows-10"><a href="#Ubuntu-on-Windows-10" class="headerlink" title="Ubuntu on Windows 10"></a>Ubuntu on Windows 10</h2><ol>
<li>Enable Developer mode for Win 10<br><img src="/2018/04/14/ubuntu-subsystem/Developer-mode.PNG" alt="Developer-mode"></li>
<li>Add Windows Linux subsystem<br><img src="/2018/04/14/ubuntu-subsystem/Linux-subsystem.PNG" alt="Linux-subsystem"></li>
<li>Install Ubuntu/SUSE/*** from App Store<br><img src="/2018/04/14/ubuntu-subsystem/Install-ubuntu.PNG" alt="Install-ubuntu"></li>
</ol>
<h2 id="Update-package-sources"><a href="#Update-package-sources" class="headerlink" title="Update package sources"></a>Update package sources</h2><ol>
<li>Edit /etc/apt/source.list<blockquote>
<p>#中国数学物理大学源</p>
<p>deb <a href="http://debian.ustc.edu.cn/ubuntu/" target="_blank" rel="noopener">http://debian.ustc.edu.cn/ubuntu/</a> vivid main multiverse restricted universe</p>
<p>deb <a href="http://debian.ustc.edu.cn/ubuntu/" target="_blank" rel="noopener">http://debian.ustc.edu.cn/ubuntu/</a> vivid-backports main multiverse restricted universe</p>
<p>deb <a href="http://debian.ustc.edu.cn/ubuntu/" target="_blank" rel="noopener">http://debian.ustc.edu.cn/ubuntu/</a> vivid-proposed main multiverse restricted universe</p>
<p>deb <a href="http://debian.ustc.edu.cn/ubuntu/" target="_blank" rel="noopener">http://debian.ustc.edu.cn/ubuntu/</a> vivid-security main multiverse restricted universe</p>
<p>deb <a href="http://debian.ustc.edu.cn/ubuntu/" target="_blank" rel="noopener">http://debian.ustc.edu.cn/ubuntu/</a> vivid-updates main multiverse restricted universe</p>
<p>deb-src <a href="http://debian.ustc.edu.cn/ubuntu/" target="_blank" rel="noopener">http://debian.ustc.edu.cn/ubuntu/</a> vivid main multiverse restricted universe</p>
<p>deb-src <a href="http://debian.ustc.edu.cn/ubuntu/" target="_blank" rel="noopener">http://debian.ustc.edu.cn/ubuntu/</a> vivid-backports main multiverse restricted universe</p>
<p>deb-src <a href="http://debian.ustc.edu.cn/ubuntu/" target="_blank" rel="noopener">http://debian.ustc.edu.cn/ubuntu/</a> vivid-proposed main multiverse restricted universe</p>
<p>deb-src <a href="http://debian.ustc.edu.cn/ubuntu/" target="_blank" rel="noopener">http://debian.ustc.edu.cn/ubuntu/</a> vivid-security main multiverse restricted universe</p>
<p>deb-src <a href="http://debian.ustc.edu.cn/ubuntu/" target="_blank" rel="noopener">http://debian.ustc.edu.cn/ubuntu/</a> vivid-updates main multiverse restricted universe</p>
<p>#阿里云的源：</p>
<p>deb <a href="http://mirrors.aliyun.com/ubuntu/" target="_blank" rel="noopener">http://mirrors.aliyun.com/ubuntu/</a> vivid main restricted universe multiverse</p>
<p>deb <a href="http://mirrors.aliyun.com/ubuntu/" target="_blank" rel="noopener">http://mirrors.aliyun.com/ubuntu/</a> vivid-security main restricted universe multiverse</p>
<p>deb <a href="http://mirrors.aliyun.com/ubuntu/" target="_blank" rel="noopener">http://mirrors.aliyun.com/ubuntu/</a> vivid-updates main restricted universe multiverse</p>
<p>deb <a href="http://mirrors.aliyun.com/ubuntu/" target="_blank" rel="noopener">http://mirrors.aliyun.com/ubuntu/</a> vivid-proposed main restricted universe multiverse</p>
<p>deb <a href="http://mirrors.aliyun.com/ubuntu/" target="_blank" rel="noopener">http://mirrors.aliyun.com/ubuntu/</a> vivid-backports main restricted universe multiverse</p>
<p>deb-src <a href="http://mirrors.aliyun.com/ubuntu/" target="_blank" rel="noopener">http://mirrors.aliyun.com/ubuntu/</a> vivid main restricted universe multiverse</p>
<p>deb-src <a href="http://mirrors.aliyun.com/ubuntu/" target="_blank" rel="noopener">http://mirrors.aliyun.com/ubuntu/</a> vivid-security main restricted universe multiverse</p>
<p>deb-src <a href="http://mirrors.aliyun.com/ubuntu/" target="_blank" rel="noopener">http://mirrors.aliyun.com/ubuntu/</a> vivid-updates main restricted universe multiverse</p>
<p>deb-src <a href="http://mirrors.aliyun.com/ubuntu/" target="_blank" rel="noopener">http://mirrors.aliyun.com/ubuntu/</a> vivid-proposed main restricted universe multiverse</p>
<p>deb-src <a href="http://mirrors.aliyun.com/ubuntu/" target="_blank" rel="noopener">http://mirrors.aliyun.com/ubuntu/</a> vivid-backports main restricted universe multiverse</p>
</blockquote>
</li>
</ol>
<p>作者：sarleon<br>链接：<a href="https://www.zhihu.com/question/41311332/answer/90517838" target="_blank" rel="noopener">https://www.zhihu.com/question/41311332/answer/90517838</a></p>
<ol start="2">
<li>Run apt to udpate<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get update</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="Intall-Nodejs-and-npm"><a href="#Intall-Nodejs-and-npm" class="headerlink" title="Intall Nodejs and npm"></a>Intall Nodejs and npm</h2><ul>
<li><p>Install from Ubuntu apt tool</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt install nodejs nodejs-legacy npm</span><br></pre></td></tr></table></figure>
</li>
<li><p>npm self update for npm</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo npm install -g npm@latest</span><br></pre></td></tr></table></figure>
</li>
<li><p>npm update nodejs using package n</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo npm install -g n</span><br><span class="line">$ sudo n stable <span class="comment">#get latest stable</span></span><br><span class="line">$ sudo n latest <span class="comment">#get latest version</span></span><br></pre></td></tr></table></figure></li>
</ul>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>Runbooks</category>
      </categories>
      <tags>
        <tag>肉肉</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>番茄工作法</title>
    <url>/2021/04/21/%E7%95%AA%E8%8C%84%E5%B7%A5%E4%BD%9C%E6%B3%95/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">
  <script id="hbeData" type="hbeData" data-hmacdigest="4f928f8f5b8169ce868a86a7784e079d028f19024f06d50eebd2cbdaeb5ef397">6ef9acd99eb5d4fdb18c4065071cc80a4d9b823e5aed90909a28677f0e994d4f0cb4080b8fc8ff985a2e32e2f129438c5cb0ec6987b627ea8de2c413fe5192ad9eb1fd40ddc39d0386b10402770a2c089f59de056f5a74cac2d7a2d263eac607ff77cca9966e14a7192f173eef8134253e2254ac7f8651121bfbb51a99b9abe6ce3a054524fd3677244fa18ffdf705e63316739a64762dec152574369eaf7a61b887e4ab75b35377db52f8252d05386bf13346fee7d6ac57d69bbcb723c5ad36f56fbe4e67eccad0e0f222edb3ead7c7a0de9de2ac10bd820bd60f52faad5b55cd5dedd38021c4b61409471e18f220bb496933fc2ff6e5cc8f770a68b1499eaf728fd2e82ae632ed765aaf27593fb146bdb41749c8a8f9f59768fcd12dce04dd657810f9e6ea2032c6f785638eec31abac926a925c16ca80ac4078eaeafe6c826fc785760c0e927df5f1be98d223bf44bdf32481827f5488c176ca160987e31f9ffe1a6c5ff6cd2dd4a0777d917a23c82921fbd0c103ad9493b61fbff61c2e35afff39fc571616c9952648bf33460f415ebc4456f1af3b317861054812815b2c5312f5f3f2a791840a4d5f3ca553de51814cc2bc82f1b120d66450c4afe15c4567e29aa8713698f72cf38825a2012effb159f0086c406d3f018560fdebc18b556e1ab22ab946226e95da5b9e1f186493413f0de635b1784f0abfda92b7efb82affa61a35f68f32074a106158fa310907719707f01d3680e9eb9f194bebcb24ec785d274b9f839d4f190e0141c85ba7616fec87456dd0e073224edc5f20c70b6c5afb2c1335c2db7a807876c09abf8e7f693f43e84b6ba28f753d6abc66bf4e3aa7ab784cd386b38448f675eb04b226a896f37da1e7a9a85538bbd5039263414e9239aa2118a22b8cf85173b43f78a837dd5271cf4be421f74ebee67aa9476ac3271ee9fa6ef9211845a59f5c7e21625d32e2974286cf0a87a546dbf97c4f8a6c16e43162f657ec06b110a99605c22a33d8f6b7124b97c1fbd5882a9ac911e0c57c8f22973d412b9a753702e262ffa0a2c5ab0340fbec14b8d1a13fa08cf6ff7cf42b33750186cbb0183438dde64e1c3a57e180729827bc71fcb5709f8006edc18d9e41255a3717281f43ca69963828bd79242f74cdd3658a3a7452f0ed64015cea95c3d29de9b704bcdf7c5d9ba06b595c0fa836f61ea1385d387ad485a9fd62353ec192f7e62fe38f6ba4fdbc166f0f2357464d9b25f8188e8ff651c1ef0c704b2a8f4e902c89665582755ca246e4cc5505725a52dce8e70ab03caf2bc4c324b5c612497a4893df278260303d2d729b00422df640dc3181dbd403c5b06b5f85d3d5c5c1fcf0ca20c75fededcb04f839a79383acfef1e6c75fbebd0eefc493005c132d9da930a0c9374cfa0554cd24f1d72f63c9dcc1c68150b12337fd0828f2dc2444c86a9d12ae159e6c4080eb5eeece93ee8d94b7d321ec6dab8e5778ec6d46f1f7ccf0a3cc2d36f7460d2a917acecfcd0761240d31f8275258f7cb53424007e417d0d967bd39b9363dcaeedb18d80aa58c27d9ed305b52d91f82dbe5116531d186bca3fdd022c32c40c4afebaf4cd63cdfa7f0506af12a91689535ab9f0f9a63e1d55f6948802570b7fff0801e62469741771d36c33f77b82f276546a0bb1b9827b014f040f2d6bfe620b105324381a9a3008295c7b514bbe026a9e9f39434d784d164e116cb84cea83b9bd20b1f8942a843183a9c6b2930a89d9bb4b3376c2613141956ba086f11b6d6eeae8cddba4ee7d32e1eb87e7076c4a403830a71dbffd9f3fbacab5d8d37e1f8ed06513e4c51497804a49f36b9979c758de3da6c1489915ffe2363a2f2f12daac8ce4064e1ef909921f9be611a782d9d182ed44c2bba8ab6fc1ddf372736d789f4876aa857c37eb7da22217a871be82945aef09f439b65ffcfff33f10da9d425037a5a897fee62f23f623831a7dbcad6c12693f8074d969a06b5db1c3deb231939e25792e11de3fa62b20596a825c151cb5276762f46a6ca577d9070c6aab9d6f59356a8ab5d476c15da485ea934d2cf7b292cbe3d88f23a2454a1be1ae2fef1d7c771ffaada64a1e0fe4459553b91dbcee7739bbcf48c8d54c1b93468a74de4ee965e98a6fc7f36eb40023e043a7b87785b3445d4b97071b561e8e480b1187aa059775ca39407f2412685335588abc2b66a3236b3dd6e5d82189fad91af99683e96fd8d80737277b782f1b54a958dc8b0801dc6816f904233d076ad3d0a8bfc2267cdbeaf5ebe1425ae793bd890f46ca9b460bc2ba5f615b6aa9d6cb5e13d4b83718a88529b5a29aeee256e1d235b42234969ac7c6cbb0c075c7b2949edd8638b4fcca58c64cc7d6860069a5aaf654c64606332dd25477049d23f92b859ae33e8eeb78fa8677be2ceff7f6af4ba84d45affca007b30399e767119e59c2c146dc01d96ec928320ec37b6663f250ed1bede5aa22dee2e79d8280e10c43eb323a12894b0b2394dd6c26658baf1944b6adcd5f2d2af6a378348b0665bf0d121da2493485791d7b74c992b9826edb48870aa3f7a70aac2a75061d19e2a0f49e9843b39057530e9299b7d4c910904005a1d6d03ddcc110915bbbf83e84c076c65a0a0cc9af955d6fe3ff4a53ea2406edfd4cc9fe3fd4a8d9efc796376444e0f0d7cd0dcdad40cc619d82213a589bd35e6d81ff884623c40daba27f93c2138d4e6ea7dd3362b4ddf066ed55026a69ef208f156610ae66f0c077ea73482beb6a110f94ebe9835c089c178e0c96e5a22f56460476dd87e13566dc0cf0b81fa2b6c51e3a88f19a740cd4a41d12a636c0ecf1d2d8a010a9d07b7379a9768425febd15f9615cde1225fad6aad5b3fbb708e8679adc03897d032f0cadb5bd7c2bbefb4cc3f709e9346ed2f5b6db9afc889fa2e0d04a69065cf72a4b49ef0a67b6de4b1fbf8a829c97a11e2412dbf507668f28ab5cb194aaf66027820c2fc4772d5194ec273d06cd84e2d3004f5ea674457cf6b3931518751638c09e0e9e2256ec4551fc0c9e1e508b720ad8c69ef4f45428de693315fc4d5db66a86d377c7b1e951a3492bd467fae0060d5f362c1300df6ddac5409f6164ebb65f1c078374eb331d98eab7e045c4e0113bea497a47627c8adb5f5c164ea53aedd25925e6a3ceb17a910781911ec35dac1b6575876a9d77a2c5388fd556da8bd9e0ff997758821afb3350b07ca8e4f827895225c053b4b7ecca0d4dc4bf58b80435e6e58e673a73eb99878f76580b029ee32add9e9efbd8c570c11e5c376b1e4deec7564c7c8ca609301b9e3f52c28ab60488d9454dabfa5d1125f2220856ddd132e7b61fb857176818eb49bdecb0be75830346a6d3cc4c0ceeb4286b6e5ddcc75a7c269d5340ffa02cafed4b9df24f7bee1bd5994baa620cebbff170ffc6fc14869ab6d9fe51cdef59c5201114513fbef49dd086395961869e6816ae4a808cc850147f240dddb947927747444b91330810302569d16f1eaee7673b7f8f5d11eb4c3d7ea2fdcb77f7c66e12495b16e42a902a15283c267aa521eaebbc7fae1a57afa5d0e3c3e65220f414d305e0611caddec71e1d878de3f2b6e3903f87c766e368bb1d4a112e55d1e6b81be6d46fc6694e524f08933f614891a02b54c1682a11c26cac3acf3477c029385eb536a0da325b3900807675bbe2f27524ec89e3970c5fa22a19865c235d7c838378070527612bb88f18b5a2163114a9242fa1d83f647ee7027a86e5c1b4c2d6ff0cc3d931d8b7394921c6fa8d12c6a6104c618f91841585a054a9d3198aa1b5cc4698b74fa0badd5a6d10b5f439c2c48f2bc161d0853e5bac6b688bb58d7aec9e0f3ae87fbc6be614d7abb70905dccdcbb04a9ecc16b62554c09fce2442679b7dfc0dbb1051a42e2074823c01d2069561bf7f9346ce6bf8d1770544c140ba0652c0291628d28cc37cfda8fc73c00054e631e717f490531605abb0217a35058b60f5f70c9d34c4aec6d3803e8c8bbeff1104ecb507f96ede4ce05cfe82fc7f7e804eda61b4ce4f16a38287fca25cbb6bffe748ef5c1b6785fc1346036495e20a287a2dfc1217de34b526b65f72d7f4557221222f93988ccea6cae139e672ab5de86d7dfb376458247e4aa3d5170dcf27e8d8827798f73b98c98742ff7cefcc937071a764e4bcb0c1e1fa59405f20b5e6dcddb66e41b782024706da4a512917129a36f10850541552cc1b6c66fb78606cc32516980d54c0ece31fbe7f3cdefa94b70aa7583c34bb53bef576129b8ed8437db33f46b33c1978eae716f24f5900990736fe10cc5df06dbf32992f706cbfb9c06f4d02eadd5d12ae7c24ea0295f1ae4a52350632825dc31c04658a59c13a834d93e58e4d8674d1ac97c57fd8fe1b88fa971124e19aadbc1702e82a1cfb1d898f304112643790fe8332c72cfcce53aeff3b0fa345350f56b804e022a8a6e39d041643430ebe1b7ddfb37ff66d4cd46c7b1402e9cd41f6ca12458b1b5e66580231d1b63dd6c28cb606dd07fa6d61a3014e3b25336d6ab98e6fd23c6e425e7a3ff391df0eb7d4ba2cf5137bb4ffb47b0febb1d70f327cf18f43280291734b1eee6099b3c5b79b1158147a26dd01fb018a4bd0c495b00e3c5b6a7e268c4abc3df1d94cc12f43b1dc65bc466c1755a11d1f2284624bf8eeac59491eedb58322f23047b5d0f7d5eb211b8ced0cdac591de72161b405e60c0f5f9d65a7736d7f9f779ccd8eb39cdf1c3318b82efb6b200e115a1e364fec7f1b</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-xray">
      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">您好, 这是一篇加密文章，请提供密码.</span>
      </label>
      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">
        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>
        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>
      </svg>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>肉肉</tag>
        <tag>职业发展</tag>
      </tags>
  </entry>
  <entry>
    <title>Authentication</title>
    <url>/2020/11/19/Authentication/</url>
    <content><![CDATA[<h1 id="Authentication服务鉴权机制"><a href="#Authentication服务鉴权机制" class="headerlink" title="Authentication服务鉴权机制"></a>Authentication服务鉴权机制</h1><p>用户在访问系统或者服务时，服务器端需要验证用户是否拥有访问的权力，这个过程称为鉴权。在服务器-客户端架构的软件系统中，当一个没有经过鉴权的用户登录时，服务器可能会返回鉴权请求。鉴权是一种客户端和服务器协同认证的方式，有多种方式可以实现：</p>
<ul>
<li>HTTP Basic Authentication</li>
<li>session-cookie</li>
<li>Token 验证(JWT)</li>
<li>OAuth(开放授权)</li>
</ul>
<h1 id="HTTP-Basic-Authentication"><a href="#HTTP-Basic-Authentication" class="headerlink" title="HTTP Basic Authentication"></a>HTTP Basic Authentication</h1><p>HTTP认证时一种无状态的认证模式，因此用户在提供相关凭据的请求中能够得到认证用户的访问，而服务器本身在接下来的请求中并不能持续保持登录状态。</p>
<p>HTTP基本认证的具体流程如下:</p>
<p>在你访问一个需要HTTP Basic Authentication的URL的时候，如果你没有提供用户名和密码，服务器就会返回401，返回Header中会包含类似”WWW-Authenticate: Basic realm=”test””信息。如果你直接在浏览器中打开，浏览器会弹出对话框提示你输入用户名和密码。</p>
<p>要在发送请求的时候添加HTTP Basic Authentication认证信息到请求中，有两种方法:</p>
<ol>
<li>在请求头中添加Authorization信息：Authorization: “Basic {用户名:密码}的base64加密字符串”。</li>
<li>在url中添加用户名和密码。</li>
</ol>
<p>其中，鉴权机制中的身份验证并非一定要依赖Basic方式的用户名密码作为凭据，可以通过如下方式：</p>
<ol>
<li><p>“WWW-Authenticate: Negotiate” SPNEGO协议,支持Kerberos, NTLM点对点认证方式完成。在协商过程中：</p>
<ul>
<li>可以请求 Authorization: Negotiate {kerberos票据}进行Kerberos验证</li>
<li>或者也能读取返回头中的 Authorization: Negotiate NTLMSSP{八字节质询码} ，并在请求头部中加入 Authorization: Negotiate NTLM{加密的质询码和明码用户名}</li>
</ul>
</li>
<li><p>“WWW-Authenticate: Digest realm=”test”,qop=”auth”,nonce=”{md5加密时间},opaque=”{不透明字符串}”摘要认证协议，能避免明文传输数据。</p>
<ul>
<li>在请求中需要加入 Authoriztion: Digest username=”guest”,realm=”test”,nonce=”{同上},qop=”auth”,nc=”00000001”,response=”{通过md5加密的user paswd httpmethod uri等信息}”,cnonce=”{客户端提供的非明文字符串}”,uri=”{uri信息}”</li>
<li>服务器需要检查时间在允许范围内，而且response匹配本地生成值。使用MD5算法的优势在于可以很快正向哈希，而无法短时间内逆向哈希得出用户密码等信息。</li>
</ul>
</li>
</ol>
<h1 id="session-cookie鉴权"><a href="#session-cookie鉴权" class="headerlink" title="session-cookie鉴权"></a>session-cookie鉴权</h1><p>Session是HTTP协议中为了支持有状态的通信而发明的会话机制，本质上是通过服务器为用户建立sessionid从而保证用户的状态信息能够在服务器端保存。用户不需要反复进行登录认证就能保持会话。</p>
<p>而Cookie则是一种特殊的HTTP头部，能够在HTTP通信中保存一定的用户信息，如sessionid从而达到认证用户的目的。由于Cookie本身是针对某一域名而产生的，所以在发送Cookie过程中必须提供正确域名的sessionid才行。</p>
<p>具体流程如下：</p>
<p><img src="/2020/11/19/Authentication/CookieAuth.jpg" alt="cookieAuth"></p>
<p>Cookie鉴权常用Single Sign On场景，例如，于对于企业中的不同子域名的验证，可以通过结合SAML, CAS等协议完成。对于不同网络更加广泛的第三方验证则有OIDC协议支持。</p>
<h1 id="Token-验证-JWT"><a href="#Token-验证-JWT" class="headerlink" title="Token 验证(JWT)"></a>Token 验证(JWT)</h1><p>Token验证方式和Seesion验证方式很类似，不同的是Token本身包含一些有意义的信息：用户名、密码、过期时间等。Token本身由服务器签发，客户端请求的发送中需要包含 Authorization : JWT “{jwt token}”，服务器提取token信息通过相同的算法验证即可。相较于Session验证方式节约了分布式系统中服务器存储sessionid和用户信息的开销，只需要服务器拥有相同的密钥即可。</p>
<p>具体流程如下:</p>
<p><img src="/2020/11/19/Authentication/TokenAuth.png" alt="tokenAuth"></p>
<p>JWT(json-web-token)算法细节：</p>
<p>JWT由三部分”{header}.{payload}.{signature}’,两种算法生成，公式如下：<br>    signature = sha256(base64(header)+’.’+base64(payload),{服务器密钥})</p>
<ol>
<li>header包含算法和类别信息, </li>
<li>payload为加密部分，包含公有声明和私有声明，公有声明为约定的key，私有为公司定制key，</li>
<li>signature，算法签名。</li>
<li>sha256为header中写的加密算法，基于服务器密钥生成不同的加密签名,具有不可逆性</li>
<li>base64为编码算法，可逆运算</li>
</ol>
<h1 id="OAuth2-OIDC认证"><a href="#OAuth2-OIDC认证" class="headerlink" title="OAuth2/OIDC认证"></a>OAuth2/OIDC认证</h1><p>OIDC 即Open ID Connect, 是一种基于OAuth2授权流程，并且扩展了身份认证层的一种新的认证机制。</p>
<p>OIDC认证模型主要包含如下四个角色和一个令牌（完整术语参见<a href="http://openid.net/specs/openid-connect-core-1_0.html#Terminology）：" target="_blank" rel="noopener">http://openid.net/specs/openid-connect-core-1_0.html#Terminology）：</a></p>
<ul>
<li>EU用户：End User：一个人类用户。</li>
<li>RP客户端：Relying Party ,用来代指OAuth2中的受信任的客户端，身份认证和授权信息的消费方；</li>
<li>OP认证服务器：OpenID Provider，有能力提供EU认证的服务（比如OAuth2中的授权服务），用来为RP提供EU的ID Token身份认证信息和Access Token访问令牌；</li>
<li>UE用户资源服务器：UserInfo Endpoint用户信息接口（受OAuth2保护），当RP使用Access Token访问时，返回授权用户的信息，此接口必须使用HTTPS。</li>
<li>ID Token认证令牌：JWT格式的数据，包含EU身份认证的信息。通过OP提供。</li>
</ul>
<p>认证流程如下：</p>
<p><img src="/2020/11/19/Authentication/OIDCAuth.jpg" alt="OIDCAuth"></p>
<p>其中，UserIndo EndPoint是一个受OAuth2保护的资源。在RP得到Access Token后可以请求此资源，然后获得一组EU相关的Claims，这些信息可以说是ID Token的扩展，比如如果你觉得ID Token中只需包含EU的唯一标识sub即可（避免ID Token过于庞大），然后通过此接口获取完整的EU的信息。此资源必须部署在TLS之上。</p>
<p>OIDC的支持的授权流程如下：</p>
<ol>
<li>Authorization Code(授权码模式)：使用OAuth2的授权码来换取Id Token和Access Token。</li>
<li>Implicit (简化模式)：使用OAuth2的Implicit流程获取Id Token和Access Token。</li>
<li>Hybrid(混合模式)：混合Authorization Code +Implicit。</li>
</ol>
<h2 id="OAuth2授权模型"><a href="#OAuth2授权模型" class="headerlink" title="OAuth2授权模型"></a>OAuth2授权模型</h2><p>OAuth2的授权模型时为了已登录用户通过第三方应用访问资源服务器进行授权的流程，授权模型和OIDC相似，包含如下四个角色:</p>
<ul>
<li>资源拥有者（User） - 指应用的用户，比如github的一个账户拥有者</li>
<li>认证服务器 （Authorization Server） - 提供登录认证接口的服务器，比如：github等</li>
<li>资源服务器 （Resources Server） - 提供资源接口及服务的服务器，通常和认证服务器是同    一个应用。</li>
<li>第三方客户端（Client） - 第三方应用，希望使用资源服务器提供的资源，比如你的一个支持通过github账户登录的应用</li>
<li>服务提供商(Provider): 认证服务和资源服务归属于一个机构，该机构就是服务提供商，比如github公司</li>
</ul>
<p>OAuth2具有四种授权模式，下文将分述这四种模式具体流程：</p>
<ul>
<li>授权码模式（authorization code）</li>
<li>简化模式（implicit）</li>
<li>密码模式（resource owner password credentials）</li>
<li>客户端模式（client credentials）</li>
</ul>
<h3 id="授权码模式-最为常见"><a href="#授权码模式-最为常见" class="headerlink" title="授权码模式(最为常见)"></a>授权码模式(最为常见)</h3><ol>
<li>用户访问客户端应用</li>
<li>引导用户到认证服务器进行登录（此步骤需要携带客户端应用的clientId，可以是html直接转发认证服务器），用户输入用户名、密码</li>
<li>认证成功后，认证服务器向客户端应用发一个授权码code</li>
<li>客户端应用拿着授权码code，和clientId，clientSecret，去换取access_token</li>
<li>返回access_token给客户端应用 </li>
</ol>
<p><img src="/2020/11/19/Authentication/AuthorizationCodeOAuth.png" alt="AuthorizationCodeOAuth"></p>
<p>这种场景下，用户名、密码、客户端应用信息，都没有直接暴露在浏览器，是web下是最安全的。</p>
<h3 id="简化模式"><a href="#简化模式" class="headerlink" title="简化模式"></a>简化模式</h3><p>授权码模式的简化，用户认证成功后，直接将token返回给浏览器。因为某些应用没有前端服务器，只有一堆静态的html（很少见），这种模式，一般不用。</p>
<p><img src="/2020/11/19/Authentication/ImplicitOAuth.png" alt="ImplicitOAuth"></p>
<h3 id="密码模式"><a href="#密码模式" class="headerlink" title="密码模式"></a>密码模式</h3><p>适用场景：手机app ，这个客户端应用是你完全可以信任的，你的app就是自己公司开发的。但是这个模式并不适合在web场景下用，在web下，用户名密码并不是直接填给自己写的应用的，而是填在浏览器呈现的一个页面上的，这个浏览器是客户端应用的一个代理，浏览器是没法保证安全性的。</p>
<p><img src="/2020/11/19/Authentication/PasswordOAuth.png" alt="PasswordOAuth"></p>
<h3 id="客户端证书模式"><a href="#客户端证书模式" class="headerlink" title="客户端证书模式"></a>客户端证书模式</h3><p>客户端应用直接发 clientId、clientSecret给认证服务器，发的令牌是针对客户端应用的，不是针对用户的。跟没授权一样，令牌不能识别用户身份。</p>
<p><img src="/2020/11/19/Authentication/ClientCertOAuth.png" alt="ClientOAuth"></p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>肉肉</tag>
        <tag>Microservice</tag>
        <tag>Authentication</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM Bytecode Execution Engine Subsystem</title>
    <url>/2019/02/13/JVM-Bytecode-Execution-Engine-Subsystem/</url>
    <content><![CDATA[<p>JVM执行引擎是Java虚拟机核心组件之一。物理机的执行引擎是直接建立在处理器、硬件、指令集和操作系统层面上，而虚拟机的执行引擎是自己实现的，可以自行制定指令集与执行引擎的结构体系，并且能够执行那些不被硬件直接支持的指令集格式。</p>
<h1 id="运行时栈帧结构"><a href="#运行时栈帧结构" class="headerlink" title="运行时栈帧结构"></a>运行时栈帧结构</h1><p>栈帧（Stack Frame）是用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时数据区中的虚拟机栈（Virtual Machine Stack）￼的栈元素。栈帧存储了方法的局部变量表、操作数栈、动态连接和方法返回地址等信息。每一个方法从调用开始至执行完成的过程，都对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程。</p>
<p>每一个栈帧都包括了局部变量表、操作数栈、动态连接、方法返回地址和一些额外的附加信息。在编译程序代码的时候，栈帧中需要多大的局部变量表，多深的操作数栈都已经完全确定了，并且写入到方法表的Code属性之中￼，因此一个栈帧需要分配多少内存，不会受到程序运行期变量数据的影响，而仅仅取决于具体的虚拟机实现。</p>
<p><img src="/2019/02/13/JVM-Bytecode-Execution-Engine-Subsystem/StackFrame.jpg" alt="StackFrame"></p>
<h2 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h2><p>局部变量表（Local Variable Table）是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量。在Java程序编译为Class文件时，就在方法的Code属性的max_locals数据项中确定了该方法所需要分配的局部变量表的最大容量。</p>
<p>局部变量表的容量以变量槽（Variable Slot，下称Slot）为最小单位，虚拟机规范中并没有明确指明一个Slot应占用的内存空间大小，只是很有导向性地说到每个Slot都应该能存放一个boolean、byte、char、short、int、float、reference或returnAddress类型的数据，这8种数据类型，都可以使用32位或更小的物理内存来存放。</p>
<p>方法执行时，如果执行的是实例方法，那局部变量表中第0位索引的默认是this的引用，即实例本身。</p>
<p>注1：与虚拟机模型设计不同的是，执行引擎的实现为了节约局部变量表的空间，局部变量表的Slothi可以重用的。</p>
<p><img src="/2019/02/13/JVM-Bytecode-Execution-Engine-Subsystem/LocalVariable.jpg" alt="LocalVariable"></p>
<p>注2：局部变量定义了但没有赋初始值是不能使用的，因为局部变量的加载没有类加载的准备和初始化阶段。</p>
<h2 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h2><p>操作数栈（Operand Stack）也常称为操作栈，它是一个后入先出（Last In First Out, LIFO）栈。同局部变量表一样，操作数栈的最大深度也在编译的时候写入到Code属性的max_stacks数据项中。操作数栈的每一个元素可以是任意的Java数据类型，包括long和double。</p>
<h2 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h2><p>每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接</p>
<h2 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h2><p>当一个方法开始执行后，只有两种方式可以退出这个方法。</p>
<p>第一种方式是执行引擎遇到任意一个方法返回的字节码指令，这时候可能会有返回值传递给上层的方法调用者（调用当前方法的方法称为调用者），是否有返回值和返回值的类型将根据遇到何种方法返回指令来决定，这种退出方法的方式称为正常完成出口（Normal Method Invocation Completion）。</p>
<p>另外一种退出方式是，在方法执行过程中遇到了异常，并且这个异常没有在方法体内得到处理，无论是Java虚拟机内部产生的异常，还是代码中使用athrow字节码指令产生的异常，只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，这种退出方法的方式称为异常完成出口（Abrupt Method Invocation Completion）。一个方法使用异常完成出口的方式退出，是不会给它的上层调用者产生任何返回值的。</p>
<h2 id="附加信息"><a href="#附加信息" class="headerlink" title="附加信息"></a>附加信息</h2><p>调试信息等，属于虚拟机可以自由实现的部分。</p>
<h1 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h1><p>方法调用阶段是确定被调用方法版本的过程。Java的编译过程并不存在连接过程，是在JVM运行时进行动态调用的。</p>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>在类加载的解析阶段，会将其中的一部分符号引用转化为直接引用，这种解析能成立的前提是：方法在程序真正运行之前就有一个可确定的调用版本，并且这个方法的调用版本在运行期是不可改变的。换句话说，调用目标在程序代码写好、编译器进行编译时就必须确定下来。这类方法的调用称为解析（Resolution）。</p>
<ul>
<li>invokestatic：调用静态方法。</li>
<li>invokespecial：调用实例构造器<code>&lt;init&gt;</code>方法、私有方法和父类方法。</li>
<li>invokevirtual：调用所有的虚方法。</li>
<li>invokeinterface：调用接口方法，会在运行时再确定一个实现此接口的对象。</li>
<li>invokedynamic：先在运行时动态解析出调用点限定符所引用的方法，然后再执行该方法，在此之前的4条调用指令，分派逻辑是固化在Java虚拟机内部的。其中只要能被invokestatic和invokespecial指令调用的方法（即非虚方法），都属于静态解析可以确定调用版本的，而invokedynamic指令的分派逻辑是由用户所设定的引导方法决定的。</li>
</ul>
<h2 id="分派Dispatch"><a href="#分派Dispatch" class="headerlink" title="分派Dispatch"></a>分派Dispatch</h2><p>分派调用过程是Java多态的一种基本体现，主要是有重载、重写两块。</p>
<h3 id="静态分派"><a href="#静态分派" class="headerlink" title="静态分派"></a>静态分派</h3><p>在编译阶段，依赖静态类型来定位方法执行版本的动作成为静态分派。典型应用是方法重载。但是，在很多情况下，重载版本并不唯一，所以虚拟机在运行时也会选更加合适的版本。</p>
<p>静态分派示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> org.fenixsoft.polymorphic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticDispatch</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Human guy)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello, guy!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Man guy)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello, gentleman!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Woman guy)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello, lady!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Human man = <span class="keyword">new</span> Man();</span><br><span class="line">        Human woman = <span class="keyword">new</span> Woman();</span><br><span class="line">        StaticDispatch sr = <span class="keyword">new</span> StaticDispatch();</span><br><span class="line">        sr.sayHello(man);</span><br><span class="line">        sr.sayHello(woman);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 实际类型变化，编译器并不能在编译时就这道，只能在运行时才可以确定的。</span></span><br><span class="line">        man = <span class="keyword">new</span> Woman();</span><br><span class="line">        sr.sayHello(man);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 静态类型变化</span></span><br><span class="line">        sr.sayHello((Woman) man);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hello, guy!</span><br><span class="line">hello, guy!</span><br><span class="line">hello, guy!</span><br><span class="line">hello, lady!</span><br></pre></td></tr></table></figure>
<p>重载方法匹配优先级代码示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.fenixsoft.polymorphic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Overload</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Object arg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello Object"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello int"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(<span class="keyword">long</span> arg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello long"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Character arg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello Character"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(<span class="keyword">char</span> arg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello char"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(<span class="keyword">char</span>... arg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello char ..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Serializable arg)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello Serializable"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        sayHello(<span class="string">'a'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>代码输出：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hello char</span><br></pre></td></tr></table></figure>
</li>
<li><p>注释掉sayHello(char arg)方法，代码输出：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hello int</span><br></pre></td></tr></table></figure>
</li>
<li><p>注释掉sayHello(int arg),代码输出：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hello long</span><br></pre></td></tr></table></figure>
</li>
<li><p>注释掉sayHello(long arg),代码输出：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hello Character</span><br></pre></td></tr></table></figure>
</li>
<li><p>注释掉sayHello(Character arg),代码输出：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hello Serializable</span><br></pre></td></tr></table></figure>
</li>
<li><p>注释掉sayHello(Serializable arg),代码输出：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hello Object</span><br></pre></td></tr></table></figure>
</li>
<li><p>注释掉sayHello(Object arg),代码输出：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hello char ...</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这个示例生动的展示了JVM在运行时静态分派时，是从继承关系中从下往上开始搜索，越接近上层的优先级越低。即使方法调用传入的参数值为null，这个规则仍然适用。变长参数的重载优先级是最低的。</p>
<h3 id="动态分派"><a href="#动态分派" class="headerlink" title="动态分派"></a>动态分派</h3><p>动态分派是重写的重要体现。</p>
<p>动态分派示例：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.fenixsoft.polymorphic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicDispatch</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"man say hello"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"woman say hello"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Human man = <span class="keyword">new</span> Man();</span><br><span class="line">        Human woman = <span class="keyword">new</span> Woman();</span><br><span class="line">        man.sayHello(); <span class="comment">// invokevirtual #21  // Method org/fenixsoft/polymorphic/Dynamic-Dispatch$Human.sayHello:()V</span></span><br><span class="line">        woman.sayHello(); <span class="comment">// invokevirtual #21</span></span><br><span class="line">        man = <span class="keyword">new</span> Woman();</span><br><span class="line">        man.sayHello(); <span class="comment">// invokevirtual #21</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">man say hello</span><br><span class="line">woman say hello</span><br><span class="line">woman say hello</span><br></pre></td></tr></table></figure></p>
<p>从字节码的角度来看， sayHello()方法均是通过invokevirtual指令触发，但是最终的执行方法版本却完全不同，invokevirtual执行的运行时解析过程如下：</p>
<ol>
<li>找到操作数栈顶的第一个元素所指向的对象的实际类型，记作C。</li>
<li>如果在类型C中找到与常量中的描述符和简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；如果不通过，则返回java.lang. IllegalAccessError异常。</li>
<li>否则，按照继承关系从下往上依次对C的各个父类进行第2步的搜索和验证过程。</li>
<li>如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodError异常。</li>
</ol>
<h3 id="单分派与多分派"><a href="#单分派与多分派" class="headerlink" title="单分派与多分派"></a>单分派与多分派</h3><p>方法的宗量，即方法的接收者与方法的参数统称。可以有单宗量分派，即根据一个宗量对目标方法进行选择。也可以有多宗量分派，即根据多个宗量对目标方法进行选择。Java的静态分派属于多分派类型。JVM在运行时动态分派属于单宗量分派。</p>
<p>单分派和多分派代码示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dispatch</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">QQ</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">_360</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hardChoice</span><span class="params">(QQ arg)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"father choose qq"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">                </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">hardChoice</span><span class="params">(_360 arg)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"father choose 360"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">hardChoice</span><span class="params">(QQ arg)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"son choose qq"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">hardChoice</span><span class="params">(_360 arg)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"son choose 360"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Father father = <span class="keyword">new</span> Father();</span><br><span class="line">        Father son = <span class="keyword">new</span> Son();</span><br><span class="line">        <span class="comment">// 静态分派：多宗量分派，方法接收者静态类型是Father,方法参数是_360 invokevirtual Father.hardChoice(360)</span></span><br><span class="line">        <span class="comment">// 动态分派：单宗量分派，方法接收者实际类型是Father，执行 Father.hardChoice(360)</span></span><br><span class="line">        father.hardChoice(<span class="keyword">new</span> _360());</span><br><span class="line">        <span class="comment">// 静态分派：静态类型是Father，方法参数是QQ invokevirtual Father.hardChoice(QQ)</span></span><br><span class="line">        <span class="comment">// 动态分派：实际类型是Son，执行Son.hardChoice(QQ)</span></span><br><span class="line">        son.hardChoice(<span class="keyword">new</span> QQ());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">father choose 360</span><br><span class="line">son choose qq</span><br></pre></td></tr></table></figure></p>
<h3 id="虚拟机动态分派的实现"><a href="#虚拟机动态分派的实现" class="headerlink" title="虚拟机动态分派的实现"></a>虚拟机动态分派的实现</h3><p>处于性能考虑，动态分派常用”稳定优化“手段：在类的方法区建立一个虚方法表(Virtual Method Table, vtable)，和接口方法表(Interface Method Table, itable)。从而虚拟机不需要进行元数据查找，直接通过虚方法表确定应该执行的方法版本。</p>
<p><img src="/2019/02/13/JVM-Bytecode-Execution-Engine-Subsystem/vtable.jpg" alt="vtable"></p>
<h2 id="动态类型语言支持"><a href="#动态类型语言支持" class="headerlink" title="动态类型语言支持"></a>动态类型语言支持</h2><p>动态语言的关键特征是它的类型检查的主体过程实在运行期而不是编译期，代码会更加简洁。而静态语言在编译器确定类型，最显著的好处是编译器可以提供严谨的类型检查，利于稳定性及代码达到更大规模。目前JVM支持的动态语言有Clojure, Groovy, Jython, JRuby等。</p>
<h1 id="字节码解释执行引擎"><a href="#字节码解释执行引擎" class="headerlink" title="字节码解释执行引擎"></a>字节码解释执行引擎</h1><p>本节探讨的是JVM将会如何对方法中的字节码进行解释执行的。</p>
<ul>
<li>传统编译过程是从程序源码到目标代码的一个过程，代表有C/C++语言。</li>
<li>Java是采用了现代的编译原理思路，把源码转化成抽象语法树，再由JVM进行解释执行，属于编译半独立实现。C#也是一种半独立实现的编译语言。</li>
<li>而有些语言则将词法分析，抽象语法树，解释执行都封装在一起，例如JavaScript执行器，这类语言一般属于动态语言。</li>
</ul>
<p><img src="/2019/02/13/JVM-Bytecode-Execution-Engine-Subsystem/JIT.jpg" alt="JIT"></p>
<h2 id="指令集架构"><a href="#指令集架构" class="headerlink" title="指令集架构"></a>指令集架构</h2><p>现在的指令执行主要有两种执行方式：</p>
<ol>
<li>基于栈的指令集架构<ul>
<li>可移植</li>
<li>执行速度相对较慢</li>
</ul>
</li>
<li>基于寄存器的指令集架构<ul>
<li>执行速度快</li>
</ul>
</li>
</ol>
<p>Java是基于栈的指令集架构。</p>
<h2 id="基于栈的解释器执行过程示例"><a href="#基于栈的解释器执行过程示例" class="headerlink" title="基于栈的解释器执行过程示例"></a>基于栈的解释器执行过程示例</h2><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>肉肉</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM memory management and GC</title>
    <url>/2018/11/07/JVM-memory-management-and-GC/</url>
    <content><![CDATA[<h1 id="Java-memory-allocation"><a href="#Java-memory-allocation" class="headerlink" title="Java memory allocation"></a>Java memory allocation</h1><p>Java虚拟机管理内存会包括以下几个运行时数据区域，如下图所示。</p>
<p><img src="/2018/11/07/JVM-memory-management-and-GC/jvm_memory_allocation.PNG" alt="jvm"></p>
<h2 id="JVM运行时数据区域简介"><a href="#JVM运行时数据区域简介" class="headerlink" title="JVM运行时数据区域简介"></a>JVM运行时数据区域简介</h2><h3 id="程序计数器-Program-Counter-Register"><a href="#程序计数器-Program-Counter-Register" class="headerlink" title="程序计数器(Program Counter Register)"></a>程序计数器(Program Counter Register)</h3><p>程序计数器时当前线程执行字节码的行号指示器。每条线程有独立的程序计数器。</p>
<ul>
<li>如果线程执行Java方法，这个技术及记录的时真该执行的虚拟机字节码指令的地址。</li>
<li>如果线程执行的时Native方法，这个计数器值则为Undefined。</li>
</ul>
<h3 id="Java虚拟机栈-JVM-stacks"><a href="#Java虚拟机栈-JVM-stacks" class="headerlink" title="Java虚拟机栈(JVM stacks)"></a>Java虚拟机栈(JVM stacks)</h3><p>JVM栈也是线程私有的。虚拟机栈描述的时Java方法执行的内存模型：</p>
<ol>
<li>每个方法会先创建一个栈帧Stack Frame，用于存储局部变量表，操作数栈，动态链接，方法出口等信息。</li>
<li>在方法执行完后，该栈帧会出栈。</li>
</ol>
<p>栈内存说的就是虚拟机中局部变量表部分。</p>
<h3 id="Native方法栈"><a href="#Native方法栈" class="headerlink" title="Native方法栈"></a>Native方法栈</h3><p>本地方法栈为虚拟机使用到的Native方法服务。</p>
<h3 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h3><p>Java堆是虚拟机所管理的内存，被所有线程共享的，目的是存放对象实例。Java堆是垃圾收集器(GC)主要管理的区域。</p>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>方法区是用于存储虚拟机的类信息，常量，静态变量，即时编译器编译后的代码等数据，被所有线程共享。在HotSpot虚拟机中，方法区又叫做“永久代”，是因为GC分代收集扩展至方法区，使得方法区由GC中的永久代区域实现。</p>
<h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><p>运行时常量池是方法区的一部分。本来在方法区中的类信息就包含了除类的版本、字段、方法、接口等描述信息之外，还有一项信息便是常量池，用于存放编译生成的各种字面量和符号引用。常量池信息将在类加载后进入方法区的运行时常量池中存放。同时，一些方法如String类的intern()方法也能将字符串加入运行时常量池。所以在类信息加载完成后，常量池也不是大小就不变的。</p>
<h2 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h2><p>直接内存并不是与JVM运行时数据区的一部分。JDK1.4后引入的NIO(New I/O)类，引入了一种基于通道(Channel)与缓冲区(Buffer)的I/O方式。它可以使用Native函数库直接分配对外内存，然后通过Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。直接内存不属于JVM GC的管理范畴，可以用-Xmx进行设定。</p>
<h2 id="JVM对象的创建"><a href="#JVM对象的创建" class="headerlink" title="JVM对象的创建"></a>JVM对象的创建</h2><p>当JVM遇到一条new指令时，会做出什么样的处理呢?</p>
<ol>
<li>检查指令参数是否能在常量池中定位到一个类的符号引用，并确保其被正确的加载、解析和初始化；</li>
<li><p>在Java堆上分配内存，有两种空闲内存分配方式：</p>
<ul>
<li>空闲列表： 基于Mark-Sweep算法的收集器的GC，如CMS；</li>
<li>指针碰撞： 具有compact过程的收集器的GC，如Serial, ParNew等。</li>
</ul>
</li>
<li><p>为了避免竞争效应即操作的原子性，系统采用如下两种其一的方法：</p>
<ul>
<li>分配内存动作进行同步处理，CAS(Compare and swap)+失败重试机制，</li>
<li>分配内存按照线程划分不同的空间之中进行，即本地线程缓冲机制(TLAB, Thread local allocation buffer)。</li>
</ul>
</li>
<li><p>为新创建对象设置好初始值；</p>
</li>
<li>对对象的对象头信息(Object header)进行相关必要设置，如：<ul>
<li>类型指向</li>
<li>类的元数据</li>
<li>对象哈希值</li>
<li>对象的GC年代信息</li>
</ul>
</li>
<li>类文件bytecode中的&lt; init&gt;方法执行；</li>
</ol>
<blockquote>
<p>init方法是Java的class文件中的各种构造方法经过JIT解释后生成的bytecode代码，一般由invokespecial操作码所调用。</p>
</blockquote>
<p>自此，一个完整的对象就被创建好了。</p>
<h2 id="JVM对象的内存布局"><a href="#JVM对象的内存布局" class="headerlink" title="JVM对象的内存布局"></a>JVM对象的内存布局</h2><p>当JVM对象被创建好了，会被分配在Java堆上，存储布局可以分为三个区域：对象头(header)、实例数据(instance data)和对齐填充(padding)。</p>
<h3 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h3><p>对象头包括两部分，一部分是”Mark Word”,另一部分是类型指针。</p>
<ul>
<li>Mark word: 长度为32bit或64bit。HotSpot 32位虚拟机中具体的对象头存储内容取决于对象的锁状态值，如下：<br><img src="/2018/11/07/JVM-memory-management-and-GC/MarkWord.PNG" alt="Markword"></li>
<li>类型指针: 长度为32bit或64bit，用于存储指向类元数据的指针，并不是所有的虚拟机实现都必须在对象数据上保留类型指针。</li>
<li>数组长度：长度为32bit，当对象为数组时，用于存储数组的长度。注：此数组并非ArrayList泛型，后者属于引用类型。</li>
</ul>
<h3 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h3><p>实例数据部分存储了类对象的所有类型的字段内容。每种虚拟机有自己定义好的参数和字段的分配策略。</p>
<h3 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h3><p>对齐填充的存在是为了满足HotSpot VM自动内存管理系统要求，保证所有对象的地址都是8字节的整数倍。</p>
<h2 id="Java基础类型内存布局"><a href="#Java基础类型内存布局" class="headerlink" title="Java基础类型内存布局"></a>Java基础类型内存布局</h2><p>java的基本数据类型共有8种，即int,short,long,byte,float,double,boolean,char(注意，并没有String的基本类型)。Java基础类型变量是在(Java虚拟机)栈上分配的，当变量的作用域运行结束后，通过出栈的方式回收分配在栈上的变量内存。</p>
<p>当声明分配一个int类型变量a = 3时，JVM会先为该变量创建一个变量为a的引用，再在栈上搜索是否存在字面值为3的引用。</p>
<ul>
<li>如果找到，就直接将a指向3的地址。</li>
<li>如果没有找到，就分配一个内存存放字面值3，并将a指向这个地址。<br>因此说，基础类型字面值在同一个栈上是共享的。</li>
</ul>
<p><strong>问题：已知int类型变量需要32bit内存，具体stack frame上内存分配是什么样子的呢? 变量a是怎么存放的? int类型信息又是放在那里的呢?</strong></p>
<h2 id="JVM对象的访问定位"><a href="#JVM对象的访问定位" class="headerlink" title="JVM对象的访问定位"></a>JVM对象的访问定位</h2><p>对象的访问定位如下图，HOTSOPT用的是第2种算法：</p>
<ol>
<li>使用句柄（先指向堆里的句柄池，再从句柄池找到指针，优点是只需要修改句柄, 缺点就是句柄池也是开销）；</li>
<li>直接指针（减少性能开销）: 需要存2个数据， 到对象实例数据的指针，到对象类数据的指针。<br><img src="/2018/11/07/JVM-memory-management-and-GC/reference.PNG" alt="reference"></li>
</ol>
<h1 id="Garbage-Collection-of-JVM"><a href="#Garbage-Collection-of-JVM" class="headerlink" title="Garbage Collection of JVM"></a>Garbage Collection of JVM</h1><h2 id="GC定义"><a href="#GC定义" class="headerlink" title="GC定义"></a>GC定义</h2><p>Garbage Collection（垃圾回收/GC）是JVM对于Java堆上内存在运行时进行的动态管理，主要是对Java堆上不再被引用的对象进行回收。Minor GC是主要快速回收Eden区和Survivor区对象内存，Full GC则会对老年代也进行回收，后者可能会影响性能。</p>
<h2 id="如何确定对象是否需要回收？"><a href="#如何确定对象是否需要回收？" class="headerlink" title="如何确定对象是否需要回收？"></a>如何确定对象是否需要回收？</h2><h3 id="引用计数算法（Reference-Counting）"><a href="#引用计数算法（Reference-Counting）" class="headerlink" title="引用计数算法（Reference Counting）"></a>引用计数算法（Reference Counting）</h3><p>给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。</p>
<p>缺点：存在循环引用的问题。</p>
<h3 id="可达性分析算法（Reachability-Analysis）"><a href="#可达性分析算法（Reachability-Analysis）" class="headerlink" title="可达性分析算法（Reachability Analysis）"></a>可达性分析算法（Reachability Analysis）</h3><p>通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连（用图论的话来说，就是从GC Roots到这个对象不可达）时，则证明此对象是不可用的。</p>
<p>GC Roots:</p>
<ul>
<li>虚拟机栈中引用的对象</li>
<li>方法去中类静态属性引用的对象</li>
<li>方法去中常量引用的对象</li>
<li>本地方法栈中JNI（Native方法）引用的对象。</li>
</ul>
<h2 id="如何对对象进行回收？"><a href="#如何对对象进行回收？" class="headerlink" title="如何对对象进行回收？"></a>如何对对象进行回收？</h2><h3 id="标记——清除算法"><a href="#标记——清除算法" class="headerlink" title="标记——清除算法"></a>标记——清除算法</h3><p><img src="/2018/11/07/JVM-memory-management-and-GC/MarkSwap.jpg" alt="MarkSwap"></p>
<h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p><img src="/2018/11/07/JVM-memory-management-and-GC/Copying.jpg" alt="Copying"></p>
<h3 id="标记——整理算法"><a href="#标记——整理算法" class="headerlink" title="标记——整理算法"></a>标记——整理算法</h3><p><img src="/2018/11/07/JVM-memory-management-and-GC/MarkCompact.jpg" alt="MarkCompact"></p>
<h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p>对于新生代和老年代的对象进行不同的清理算法，一般来说，复制算法适合新生代，标记-清除算法和标记整理算法更适合老年代内存。</p>
<h2 id="JVM对象内存管理策略"><a href="#JVM对象内存管理策略" class="headerlink" title="JVM对象内存管理策略"></a>JVM对象内存管理策略</h2><p>GC管理的内存分为三类区域，分别是Eden+Survivor（新生代），Tenured（老年代）和Permanent（永久代）。</p>
<p><img src="/2018/11/07/JVM-memory-management-and-GC/GCRegions.png" alt="GCregion"></p>
<ol>
<li><p>对象优先在Eden分配</p>
</li>
<li><p>大对象直接进入老年代</p>
</li>
<li><p>长期存活的对象将进入老年代</p>
</li>
<li><p>动态对象年龄判定：当Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或者等于该年龄的对象可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。这是为了防止Survivor区溢出。</p>
</li>
</ol>
<h2 id="JVM常用的垃圾收集器"><a href="#JVM常用的垃圾收集器" class="headerlink" title="JVM常用的垃圾收集器"></a>JVM常用的垃圾收集器</h2><p><img src="/2018/11/07/JVM-memory-management-and-GC/GCs.jpg" alt="GCs"></p>
<h3 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h3><p>单线程处理<strong>新生代</strong>GC。复制算法。STW</p>
<p><img src="/2018/11/07/JVM-memory-management-and-GC/SerialGC.jpg" alt="Serial/SerialOld"></p>
<h3 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h3><p>采用多线程处理<strong>新生代</strong>GC。复制算法。STW</p>
<p><img src="/2018/11/07/JVM-memory-management-and-GC/ParNewGC.jpg" alt="ParNew"></p>
<h3 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h3><p>处理算法和ParNewGC完全一样。<br>但是，Parallel Scavenge收集器的特点是它的关注点与其他收集器不同，CMS等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量（Throughput）。所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量 = 运行用户代码时间 /（运行用户代码时间 +垃圾收集时间），虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。</p>
<p><img src="/2018/11/07/JVM-memory-management-and-GC/PSPold.jpg" alt="ParallelScavengeAndParOld"></p>
<h3 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h3><p>单线程处理<strong>老年代</strong>GC。采用标记-整理算法。STW</p>
<h3 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h3><p>多线程处理<strong>老年代</strong>GC。采用标记整理算法。STW</p>
<h3 id="CMS-Concurrent-Mark-Sweep-收集器"><a href="#CMS-Concurrent-Mark-Sweep-收集器" class="headerlink" title="CMS(Concurrent Mark Sweep)收集器"></a>CMS(Concurrent Mark Sweep)收集器</h3><p>四个阶段（基于标记-清理算法）：</p>
<ul>
<li>初始标记 STW</li>
<li>并发标记</li>
<li>再次标记 STW</li>
<li>并发清理</li>
</ul>
<p><img src="/2018/11/07/JVM-memory-management-and-GC/CMS.jpg" alt="CMS"></p>
<p>问题：</p>
<ol>
<li>并发清理时预留空间不够造成并发清理(Concurrent Mode Failure)失败=&gt;浮动垃圾(Floating Gabage)过多。</li>
<li>内存碎片化问题。一旦发生大对象触发的FullGC，Serial Old回收则会出现长时间STW。</li>
</ol>
<ul>
<li><p>CMS并发三色标记法</p>
<ol>
<li>黑色：已经标记完引用对象的颜色</li>
<li>灰色：没有标记完引用对象的颜色</li>
<li>白色：默认垃圾（没有被标记颜色）</li>
</ol>
<ul>
<li><p>标记问题：</p>
<ol>
<li>本来A-&gt;B, B-&gt;D;</li>
<li>在A标记完，B部分标记后，B-&gt;D引用消失，D没有被标记，A-&gt;D引用建立</li>
<li>由于D从始至终都没有被标记</li>
</ol>
</li>
<li><p>标记问题一Incremental Update更正：</p>
<ol>
<li>对于A-&gt;D（白)的引用建立，把A修正成灰色。</li>
</ol>
</li>
<li><p>Incremental Update更正存在的ABA问题：</p>
<ol>
<li>回收线程一：标记A属性1，正在标记属性2</li>
<li>业务逻辑线程二：把属性1指向白色D， A保持灰色</li>
<li>回收线程三: 更新属性2的标记，将A标记为黑色</li>
</ol>
</li>
<li><p>CMS最终解决方案：必须STW从头扫描一次</p>
</li>
</ul>
</li>
</ul>
<h3 id="G1-Garbage-First-收集器"><a href="#G1-Garbage-First-收集器" class="headerlink" title="G1(Garbage First)收集器"></a>G1(Garbage First)收集器</h3><p>启动G1需要参数<code>-XX:+UseG1GC</code>，G1不是与其他GC分代处理垃圾的，而是对新生代和老年代均进行不同的GC。</p>
<p>Young GC:</p>
<ul>
<li>标记-清除-复制算法整理 STW<br>只对新生代区块进行清理，但是也会需要扫描所有region的Rset，否则不知道有哪些Old-&gt;Young的引用。</li>
</ul>
<p>Mixed GC:<br>处理Mixed GC时只将将部分old区块进行回收。Rset记录了其他区块对本区块的引用。最终的扫描区域为Young+对Rset进行扫描，缩短了原来需要扫描整个Old时间。而且Young<->Old的引用都能快速找到。</-></p>
<p>并发标记分为四个阶段(基于标记-整理算法)：</p>
<ul>
<li>初始标记 STW</li>
<li>并发标记</li>
<li>最终标记 STW </li>
<li>筛选回收 STW 根据停顿时间要求筛选出Old中的Cset集合，作为回收目标。</li>
</ul>
<p>回收evacuation阶段（小区块进行复制整理避免碎片）：<br>需要STW，将选出的Cset中的对象进行复制到新的区块，清除掉原来的区块，达到收集的效果。</p>
<p><img src="/2018/11/07/JVM-memory-management-and-GC/G1.jpg" alt="G1"></p>
<h3 id="ZGC-Z-Garbage-Collector-收集器"><a href="#ZGC-Z-Garbage-Collector-收集器" class="headerlink" title="ZGC(Z Garbage Collector)收集器"></a>ZGC(Z Garbage Collector)收集器</h3><p>ZGC（Z Garbage Collector）是一款由Oracle公司研发的，以低延迟为首要目标的一款垃圾收集器。它是基于动态Region内存布局，（暂时）不设年龄分代，使用了读屏障、染色指针和内存多重映射等技术来实现可并发的标记-整理算法的收集器。在JDK 11新加入，还在实验阶段，主要特点是：回收TB级内存（最大4T），停顿时间不超过10ms。m目前ZGC是实验性功能，可以通过<code>-XX:+UnlockExperimentalVMOptions -XX:+UseZGC</code>参数启动ZGC。</p>
<h3 id="垃圾收集器参数"><a href="#垃圾收集器参数" class="headerlink" title="垃圾收集器参数"></a>垃圾收集器参数</h3><p><img src="/2018/11/07/JVM-memory-management-and-GC/GCArgs.jpg" alt="GCArgs"></p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>肉肉</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Java集合框架</title>
    <url>/2018/12/08/Java-Collections/</url>
    <content><![CDATA[<h1 id="Java集合框架"><a href="#Java集合框架" class="headerlink" title="Java集合框架"></a>Java集合框架</h1><blockquote>
<p>Reference Link: <a href="http://www.runoob.com/java/java-collections.html" target="_blank" rel="noopener">http://www.runoob.com/java/java-collections.html</a></p>
</blockquote>
<p>集合框架被设计成要满足以下几个目标。</p>
<ul>
<li>该框架必须是高性能的。基本集合（动态数组，链表，树，哈希表）的实现也必须是高效的。</li>
<li>该框架允许不同类型的集合，以类似的方式工作，具有高度的互操作性。</li>
<li>对一个集合的扩展和适应必须是简单的。<br>为此，整个集合框架就围绕一组标准接口而设计。你可以直接使用这些接口的标准实现，如下图所示，诸如： LinkedList, HashSet, 和 TreeSet 等,除此之外你也可以通过这些接口实现自己的集合。</li>
</ul>
<p><img src="/2018/12/08/Java-Collections/JavaCollectionsUML.gif" alt="JavaCollectionsUML"></p>
<p>从上面的集合框架图可以看到，Java 集合框架主要包括两种类型的容器，一种是集合（Collection），存储一个元素集合，另一种是图（Map），存储键/值对映射。Collection 接口又有 3 种子类型，List、Set 和 Queue，再下面是一些抽象类，最后是具体实现类，常用的有 ArrayList、LinkedList、HashSet、LinkedHashSet、HashMap、LinkedHashMap 等等。</p>
<p>集合框架是一个用来代表和操纵集合的统一架构。所有的集合框架都包含如下内容：</p>
<ul>
<li>接口：是代表集合的抽象数据类型。例如 Collection、List、Set、Map 等。之所以定义多个接口，是为了以不同的方式操作集合对象</li>
<li>实现（类）：是集合接口的具体实现。从本质上讲，它们是可重复使用的数据结构，例如：ArrayList、LinkedList、HashSet、HashMap。</li>
<li>算法：是实现集合接口的对象里的方法执行的一些有用的计算，例如：搜索和排序。这些算法被称为多态，那是因为相同的方法可以在相似的接口上有着不同的实现。<br>除了集合，该框架也定义了几个 Map 接口和类。Map 里存储的是键/值对。尽管 Map 不是集合，但是它们完全整合在集合中。</li>
</ul>
<p>集合框架体系如图所示:</p>
<p><img src="/2018/12/08/Java-Collections/java-coll-architecture.png" alt="JavaCollArch"></p>
<h2 id="集合接口"><a href="#集合接口" class="headerlink" title="集合接口"></a>集合接口</h2><ol>
<li><a href="https://docs.oracle.com/javase/tutorial/collections/interfaces/collection.html" target="_blank" rel="noopener">Collection 接口</a></li>
</ol>
<p>Collection 是最基本的集合接口，一个 Collection 代表一组 Object，即 Collection 的元素, Java不提供直接继承自Collection的类，只提供继承于的子接口(如List和set)。<br>Collection 接口存储一组不唯一，无序的对象。</p>
<ol start="2">
<li><a href="https://docs.oracle.com/javase/7/docs/api/java/util/List.html" target="_blank" rel="noopener">List 接口</a></li>
</ol>
<p>List接口是一个有序的 Collection，使用此接口能够精确的控制每个元素插入的位置，能够通过索引(元素在List中位置，类似于数组的下标)来访问List中的元素，第一个元素的索引为 0，而且允许有相同的元素。<br>List 接口存储一组不唯一，有序（插入顺序）的对象。</p>
<ol start="3">
<li><a href="https://docs.oracle.com/javase/7/docs/api/java/util/Set.html" target="_blank" rel="noopener">Set 接口</a></li>
</ol>
<p>Set 具有与 Collection 完全一样的接口，只是行为上不同，Set 不保存重复的元素。<br>Set 接口存储一组唯一，无序的对象。</p>
<ol start="4">
<li><a href="https://docs.oracle.com/javase/7/docs/api/java/util/SortedSet.html" target="_blank" rel="noopener">SortedSet 接口</a></li>
</ol>
<p>继承于Set保存有序的集合。</p>
<ol start="5">
<li><a href="https://docs.oracle.com/javase/7/docs/api/java/util/Map.html" target="_blank" rel="noopener">Map 接口</a></li>
</ol>
<p>Map 接口存储一组键值对象，提供key（键）到value（值）的映射。</p>
<ol start="6">
<li><a href="https://docs.oracle.com/javase/7/docs/api/java/util/Map.Entry.html" target="_blank" rel="noopener">Map.Entry 接口</a></li>
</ol>
<p>描述在一个Map中的一个元素（键/值对）。是一个Map的内部类。</p>
<ol start="7">
<li><a href="https://docs.oracle.com/javase/7/docs/api/java/util/SortedMap.html" target="_blank" rel="noopener">SortedMap 接口</a></li>
</ol>
<p>继承于 Map，使 Key 保持在升序排列。</p>
<ol start="8">
<li><a href="https://www.tutorialspoint.com/java/java_enumeration_interface.htm" target="_blank" rel="noopener">Enumeration 接口</a></li>
</ol>
<p>这是一个传统的接口和定义的方法，通过它可以枚举（一次获得一个）对象集合中的元素。这个传统接口已被迭代器取代。</p>
<ol start="9">
<li><a href="https://docs.oracle.com/javase/tutorial/collections/interfaces/queue.html" target="_blank" rel="noopener">Queue 接口</a></li>
</ol>
<p>Queue是队列实现，实现了先进先出功能。</p>
<h2 id="集合实现类（集合类）"><a href="#集合实现类（集合类）" class="headerlink" title="集合实现类（集合类）"></a>集合实现类（集合类）</h2><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><table>
<thead>
<tr>
<th style="text-align:left">类名</th>
<th style="text-align:center">内容</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">AbstractCollection</td>
<td style="text-align:center">实现了大部分的集合接口。</td>
</tr>
<tr>
<td style="text-align:left">AbstractList</td>
<td style="text-align:center">继承于AbstractCollection 并且实现了大部分List接口。</td>
</tr>
<tr>
<td style="text-align:left">AbstractSequentialList</td>
<td style="text-align:center">继承于 AbstractList ，提供了对数据元素的链式访问而不是随机访问。</td>
</tr>
<tr>
<td style="text-align:left">AbstractSet</td>
<td style="text-align:center">继承于AbstractCollection 并且实现了大部分Set接口。</td>
</tr>
<tr>
<td style="text-align:left">AbstractMap</td>
<td style="text-align:center">实现了大部分的Map接口。</td>
</tr>
</tbody>
</table>
<h3 id="集合类"><a href="#集合类" class="headerlink" title="集合类"></a>集合类</h3><table>
<thead>
<tr>
<th style="text-align:left">类名</th>
<th style="text-align:center">内容</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">LinkedList</td>
<td style="text-align:center">该类实现了List接口，允许有null（空）元素。主要用于创建链表数据结构，该类没有同步方法，如果多个线程同时访问一个List，则必须自己实现访问同步，解决方法就是在创建List时候构造一个同步的List。例如: <code>Listlist=Collections.synchronizedList(newLinkedList(...));</code>LinkedList 查找效率低。</td>
</tr>
<tr>
<td style="text-align:left">ArrayList</td>
<td style="text-align:center">该类也是实现了List的接口，实现了可变大小的数组，随机访问和遍历元素时，提供更好的性能。该类也是非同步的,在多线程的情况下不要使用。ArrayList 增长当前长度的50%，插入删除效率低。</td>
</tr>
<tr>
<td style="text-align:left">HashSet</td>
<td style="text-align:center">该类实现了Set接口，不允许出现重复元素，不保证集合中元素的顺序，允许包含值为null的元素，但最多只能一个。</td>
</tr>
<tr>
<td style="text-align:left">LinkedHashSet</td>
<td style="text-align:center">具有可预知迭代顺序的 Set 接口的哈希表和链接列表实现。</td>
</tr>
<tr>
<td style="text-align:left">TreeSet</td>
<td style="text-align:center">该类实现了Set接口，可以实现排序等功能。</td>
</tr>
<tr>
<td style="text-align:left">HashMap</td>
<td style="text-align:center">HashMap 是一个散列表，它存储的内容是键值对(key-value)映射。该类实现了Map接口，根据键的HashCode值存储数据，具有很快的访问速度，最多允许一条记录的键为null，不支持线程同步。</td>
</tr>
<tr>
<td style="text-align:left">TreeMap</td>
<td style="text-align:center">继承了AbstractMap，并且使用一颗树。</td>
</tr>
<tr>
<td style="text-align:left">WeakHashMap</td>
<td style="text-align:center">继承AbstractMap类，使用弱密钥的哈希表。</td>
</tr>
<tr>
<td style="text-align:left">LinkedHashMap</td>
<td style="text-align:center">继承于HashMap，使用元素的自然顺序对元素进行排序.</td>
</tr>
<tr>
<td style="text-align:left">IdentityHashMap</td>
<td style="text-align:center">继承AbstractMap类，比较文档时使用引用相等。</td>
</tr>
</tbody>
</table>
<h3 id="其他：数据结构类"><a href="#其他：数据结构类" class="headerlink" title="其他：数据结构类"></a>其他：数据结构类</h3><table>
<thead>
<tr>
<th style="text-align:left">类名</th>
<th style="text-align:center">内容</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Vector</td>
<td style="text-align:center">该类和ArrayList非常相似，但是该类是同步的，可以用在多线程的情况，该类允许设置默认的增长长度，默认扩容方式为原来的2倍。</td>
</tr>
<tr>
<td style="text-align:left">Stack</td>
<td style="text-align:center">栈是Vector的一个子类，它实现了一个标准的后进先出的栈。</td>
</tr>
<tr>
<td style="text-align:left">Dictionary</td>
<td style="text-align:center">Dictionary 类是一个抽象类，用来存储键/值对，作用和Map类相似。</td>
</tr>
<tr>
<td style="text-align:left">Hashtable</td>
<td style="text-align:center">Hashtable 是 Dictionary(字典) 类的子类，位于 java.util 包中。</td>
</tr>
<tr>
<td style="text-align:left">Properties</td>
<td style="text-align:center">Properties 继承于 Hashtable，表示一个持久的属性集，属性列表中每个键及其对应值都是一个字符串。</td>
</tr>
<tr>
<td style="text-align:left">BitSet</td>
<td style="text-align:center">一个Bitset类创建一种特殊类型的数组来保存位值。BitSet中数组大小会随需要增加。</td>
</tr>
</tbody>
</table>
<h2 id="遍历示例代码"><a href="#遍历示例代码" class="headerlink" title="遍历示例代码"></a>遍历示例代码</h2><h3 id="遍历ArrayList"><a href="#遍历ArrayList" class="headerlink" title="遍历ArrayList"></a>遍历ArrayList</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">     List&lt;String&gt; list=<span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">     list.add(<span class="string">"Hello"</span>);</span><br><span class="line">     list.add(<span class="string">"World"</span>);</span><br><span class="line">     list.add(<span class="string">"HAHAHAHA"</span>);</span><br><span class="line">     <span class="comment">//第一种遍历方法使用foreach遍历List</span></span><br><span class="line">     <span class="keyword">for</span> (String str : list) &#123;            <span class="comment">//也可以改写for(int i=0;i&lt;list.size();i++)这种形式</span></span><br><span class="line">        System.out.println(str);</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">//第二种遍历，把链表变为数组相关的内容进行遍历</span></span><br><span class="line">     String[] strArray=<span class="keyword">new</span> String[list.size()];</span><br><span class="line">     list.toArray(strArray);</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;strArray.length;i++) <span class="comment">//这里也可以改写为  foreach(String str:strArray)这种形式</span></span><br><span class="line">     &#123;</span><br><span class="line">        System.out.println(strArray[i]);</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//第三种遍历 使用迭代器进行相关遍历</span></span><br><span class="line">     </span><br><span class="line">     Iterator&lt;String&gt; ite=list.iterator();</span><br><span class="line">     <span class="keyword">while</span>(ite.hasNext())<span class="comment">//判断下一个元素之后有值</span></span><br><span class="line">     &#123;</span><br><span class="line">         System.out.println(ite.next());</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="遍历Map"><a href="#遍历Map" class="headerlink" title="遍历Map"></a>遍历Map</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">      map.put(<span class="string">"1"</span>, <span class="string">"value1"</span>);</span><br><span class="line">      map.put(<span class="string">"2"</span>, <span class="string">"value2"</span>);</span><br><span class="line">      map.put(<span class="string">"3"</span>, <span class="string">"value3"</span>);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//第一种：普遍使用，二次取值</span></span><br><span class="line">      System.out.println(<span class="string">"通过Map.keySet遍历key和value："</span>);</span><br><span class="line">      <span class="keyword">for</span> (String key : map.keySet()) &#123;</span><br><span class="line">       System.out.println(<span class="string">"key= "</span>+ key + <span class="string">" and value= "</span> + map.get(key));</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//第二种</span></span><br><span class="line">      System.out.println(<span class="string">"通过Map.entrySet使用iterator遍历key和value："</span>);</span><br><span class="line">      Iterator&lt;Map.Entry&lt;String, String&gt;&gt; it = map.entrySet().iterator();</span><br><span class="line">      <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">       Map.Entry&lt;String, String&gt; entry = it.next();</span><br><span class="line">       System.out.println(<span class="string">"key= "</span> + entry.getKey() + <span class="string">" and value= "</span> + entry.getValue());</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//第三种：推荐，尤其是容量大时</span></span><br><span class="line">      System.out.println(<span class="string">"通过Map.entrySet遍历key和value"</span>);</span><br><span class="line">      <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : map.entrySet()) &#123;</span><br><span class="line">       System.out.println(<span class="string">"key= "</span> + entry.getKey() + <span class="string">" and value= "</span> + entry.getValue());</span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">      <span class="comment">//第四种</span></span><br><span class="line">      System.out.println(<span class="string">"通过Map.values()遍历所有的value，但不能遍历key"</span>);</span><br><span class="line">      <span class="keyword">for</span> (String v : map.values()) &#123;</span><br><span class="line">       System.out.println(<span class="string">"value= "</span> + v);</span><br><span class="line">      &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="题外话：-Java-数组"><a href="#题外话：-Java-数组" class="headerlink" title="题外话： Java 数组"></a>题外话： Java 数组</h1><p>Java 数组是很容易和Java动态数组(ArrayList)进行混淆的数据结构。其实Java数组本身并不具有方法，唯一的属性是length。对于数组的大小也不能改变，很多功能需要借助Utility类Arrays提供的静态方法。</p>
<p>Java中的所有数组都是通过Array类实例化。Array类没有public的构造方法，数组是通过Array的newInstance()方法进行实例化。Java数组是支持所有类型的，也就是说对于自定义引用类型，也能创建数组类型，但是与动态数组的方式不同，内存分配机制上也有所不同。</p>
<h2 id="Array类源码"><a href="#Array类源码" class="headerlink" title="Array类源码"></a>Array类源码</h2><p>数组类的实现主要基于本地方法创建，申请分配一段连续内存，每一个数组元素支持强类型检查。长度不支持扩展。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lang;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">System</span> </span>&#123;</span><br><span class="line">    <span class="comment">//System 类不能被实例化。 </span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">System</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="comment">//在 System 类提供的设施中，有标准输入、标准输出和错误输出流；对外部定义的属性</span></span><br><span class="line">    <span class="comment">//和环境变量的访问；加载文件和库的方法；还有快速复制数组的一部分的实用方法。</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * src and dest都必须是同类型或者可以进行转换类型的数组．</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>      src      the source array.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>      srcPos   starting position in the source array.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>      dest     the destination array.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>      destPos  starting position in the destination data.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>      length   the number of array elements to be copied.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">arraycopy</span><span class="params">(Object src, <span class="keyword">int</span> srcPos, Object dest,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> destPos, <span class="keyword">int</span> length)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">package</span> com.lang.reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Array</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建一个具有指定的组件类型和维度的新数组。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newInstance</span><span class="params">(Class&lt;?&gt; componentType, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> NegativeArraySizeException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> newArray(componentType, length);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> Object <span class="title">newArray</span><span class="params">(Class componentType, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> NegativeArraySizeException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数组声明与初始化"><a href="#数组声明与初始化" class="headerlink" title="数组声明与初始化"></a>数组声明与初始化</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//直接声明空数组</span></span><br><span class="line">dataType[] arrayRefVar = <span class="keyword">new</span> dataType[arraySize];</span><br><span class="line"><span class="comment">//直接引入数组元素，用花括弧创建</span></span><br><span class="line"><span class="keyword">int</span> [] arrayRefVar2 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="comment">//访问时通过下标访问</span></span><br><span class="line">System.out.println(arrayRefVar2[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure>
<h2 id="多维数组声明与初始化"><a href="#多维数组声明与初始化" class="headerlink" title="多维数组声明与初始化"></a>多维数组声明与初始化</h2><p>多维数组其实就是一维数组的嵌套扩展，维度取决于数组各个元素的类型，如果是一个数组则能增加一个维度。因此多维数组的创建与访问也是基于一维数组的方法。Array类属性只有length一个，访问是基于下标的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//直接声明矩阵二维数组</span></span><br><span class="line">dataType[][] arrayRefVar = <span class="keyword">new</span> dataType[colsize][rowsize];</span><br><span class="line"><span class="comment">//分段申明非矩阵二维数组</span></span><br><span class="line">dataType[][] arrayRefVar2 = <span class="keyword">new</span> dataType[colsize][];</span><br><span class="line">arrayRefVar2[<span class="number">0</span>] = <span class="keyword">new</span> dataType[row1size];</span><br><span class="line">arrayRefVar2[<span class="number">1</span>] = <span class="keyword">new</span> dataType[row2size];</span><br><span class="line"><span class="comment">//直接引入数组元素，用嵌套花括弧创建，按照维度分配，第一个是第一列</span></span><br><span class="line"><span class="keyword">int</span>[][] arrayint = &#123;</span><br><span class="line">  &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;,</span><br><span class="line">  &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//直接引入数组元素，用下标顺序填入</span></span><br><span class="line"><span class="keyword">int</span>[][] array2 = &#123;<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>], <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>]&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数组的访问是基于下标 array2[col][row]</span></span><br></pre></td></tr></table></figure>
<h1 id="题外话-Arrays-类"><a href="#题外话-Arrays-类" class="headerlink" title="题外话: Arrays 类"></a>题外话: <a href="https://docs.oracle.com/javase/tutorial/java/nutsandbolts/arrays.html" target="_blank" rel="noopener">Arrays 类</a></h1><p>java.util.Arrays 类能方便地操作数组，它提供的所有方法都是静态的。<br>具有以下功能：</p>
<ul>
<li>给数组赋值：通过 fill 方法。</li>
<li>对数组排序：通过 sort 方法,按升序。</li>
<li>比较数组：通过 equals 方法比较数组中元素值是否相等。</li>
<li>查找数组元素：通过 binarySearch 方法能对排序好的数组进行二分查找法操作。</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">方法名</th>
<th style="text-align:center">内容</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>public static int binarySearch(Object[] a, Object key)</code></td>
<td style="text-align:center">用二分查找算法在给定数组中搜索给定值的对象(Byte,Int,double等)。数组在调用前必须排序好的。如果查找值包含在数组中，则返回搜索键的索引；否则返回 (-(插入点) - 1)。</td>
</tr>
<tr>
<td style="text-align:left"><code>public static boolean equals(long[] a, long[] a2)</code></td>
<td style="text-align:center">如果两个指定的 long 型数组彼此相等，则返回 true。如果两个数组包含相同数量的元素，并且两个数组中的所有相应元素对都是相等的，则认为这两个数组是相等的。换句话说，如果两个数组以相同顺序包含相同的元素，则两个数组是相等的。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等）。</td>
</tr>
<tr>
<td style="text-align:left"><code>public static void fill(int[] a, int val)</code></td>
<td style="text-align:center">将指定的 int 值分配给指定 int 型数组指定范围中的每个元素。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等）。</td>
</tr>
<tr>
<td style="text-align:left"><code>public static void sort(Object[] a)</code></td>
<td style="text-align:center">对指定对象数组根据其元素的自然顺序进行升序排列。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等）。</td>
</tr>
</tbody>
</table>
<h1 id="题外话：-Collections-类"><a href="#题外话：-Collections-类" class="headerlink" title="题外话： Collections 类"></a>题外话： <a href="https://docs.oracle.com/javase/7/docs/api/java/util/Collections.html" target="_blank" rel="noopener">Collections 类</a></h1><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>肉肉</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Angular 5 with Angular CLI</title>
    <url>/2018/04/19/Angular-5-with-Angular-CLI/</url>
    <content><![CDATA[<h2 id="Angular-5-Overview"><a href="#Angular-5-Overview" class="headerlink" title="Angular 5 Overview"></a>Angular 5 Overview</h2><p>Angular 5的快速开发，测试和部署可以使用Angular CLI工具完成。Angular 5是基于Typescript语言开发的Web前端框架。</p>
<h3 id="Angular-5-quick-start"><a href="#Angular-5-quick-start" class="headerlink" title="Angular 5 quick start"></a>Angular 5 quick start</h3><ul>
<li>Environment Setup</li>
<li>ng command</li>
<li>Project structure definition<blockquote>
<p>More at: <a href="https://angular.io/guide/quickstart" target="_blank" rel="noopener">https://angular.io/guide/quickstart</a></p>
</blockquote>
</li>
</ul>
<h3 id="Angular-5-basic-prject-development-tutorial"><a href="#Angular-5-basic-prject-development-tutorial" class="headerlink" title="Angular 5 basic prject development tutorial"></a>Angular 5 basic prject development tutorial</h3><h4 id="Application-shell"><a href="#Application-shell" class="headerlink" title="Application shell"></a>Application shell</h4><p>Angular 5应用的基本框架，可以用ng new {projectname}命令生成，一个简单的Angular项目需要包含一个app module和app component。在app component中，会定义一个<app-root></app-root>控件，作为整个Angular app的入口，一般写在index.html中。</p>
<h4 id="Angular-Component"><a href="#Angular-Component" class="headerlink" title="Angular Component"></a>Angular Component</h4><p>在已经有的app component基础上，可以用ng generate component {dir/componetname}命令生成更多的组件，新的组件组成元素和app component一样，也是html模板，ts组件功能定义，和css组件风格。一般意义上，在ts中定义控件directive的名称，在html模板中，可以直接调用该directive。</p>
<p>每个已经创建好的component会被自动import进入app.module.ts文件，从而在Angular应用启动时，能自动寻找到对应的component并加载。如果developer需要在自己定义的component中引用其他component/service组件，也需要定义相似的import语句，否则Angualr引擎并不能成功识别调用组件。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Angular components</span></span><br><span class="line"><span class="keyword">import</span> &#123; BrowserModule &#125; <span class="keyword">from</span> <span class="string">'@angular/platform-browser'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; NgModule &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; FormsModule &#125; <span class="keyword">from</span> <span class="string">'@angular/forms'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Angular application shell</span></span><br><span class="line"><span class="keyword">import</span> &#123; AppComponent &#125; <span class="keyword">from</span> <span class="string">'./app.component'</span>;</span><br><span class="line"><span class="comment">//Additional costomized components</span></span><br><span class="line"><span class="keyword">import</span> &#123; HeroesComponent &#125; <span class="keyword">from</span> <span class="string">'./heroes/heroes.component'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; HeroDetailComponent &#125; <span class="keyword">from</span> <span class="string">'./hero-detail/hero-detail.component'</span>;</span><br><span class="line"><span class="comment">//Additional service modules</span></span><br><span class="line"><span class="keyword">import</span> &#123; HeroService &#125; <span class="keyword">from</span> <span class="string">'./hero.service'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NgModule</span>(&#123;</span><br><span class="line">  declarations: [</span><br><span class="line">    AppComponent,</span><br><span class="line">    HeroesComponent,</span><br><span class="line">    HeroDetailComponent,</span><br><span class="line">  ],</span><br><span class="line">  imports: [</span><br><span class="line">    BrowserModule,</span><br><span class="line">    FormsModule</span><br><span class="line">  ],</span><br><span class="line">  providers: [</span><br><span class="line">    HeroService</span><br><span class="line">  ],</span><br><span class="line">  bootstrap: [ AppComponent ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="Angular-Service"><a href="#Angular-Service" class="headerlink" title="Angular Service"></a>Angular Service</h4><p>Angular提供了service module来支持现在Web前端数据获取和更新功能。可以用ng generate service {dir/servicename} –module=app命令来生成。</p>
<h4 id="Angular-Routing"><a href="#Angular-Routing" class="headerlink" title="Angular Routing"></a>Angular Routing</h4><p>Angular提供了routing来允许Web前端以single page application(SPA)方式渲染多个url的页面。可以用ng generate module app-routing –flat –module=app生成app.routing.ts模块。app routing模块隐式定义了<router-outlet></router-outlet>控件，这是一个可以根据输入url进行跳转的控件。一般放在app componet html模板中，作为Angular应用的跳转渲染单元。这个控件本身，并不能提供跳转入口，一般需要写锚，在html模板显式来定义url。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">nav</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">routerLink</span>=<span class="string">"/heroes"</span>&gt;</span>Heroes<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">routerLink</span>=<span class="string">"/heroes"</span>&gt;</span>Heroes<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-outlet</span>&gt;</span><span class="tag">&lt;/<span class="name">router-outlet</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>此外，app routing模块本身，定义了url跳转的逻辑。由于Angualar的html模块本身具有嵌套性，因而在routing逻辑中，只要引入自定义的directive控件，就能自动渲染出控件中所嵌套的所有元素。可以说，Angular的程序设计思想，就是基于模板设计的，每个模板都是一个自定义的DOM元素，允许在Angular的控制域中任意的复用。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; NgModule &#125;             <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"><span class="comment">// Angular routing module</span></span><br><span class="line"><span class="keyword">import</span> &#123; RouterModule, Routes &#125; <span class="keyword">from</span> <span class="string">'@angular/router'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> &#123; DashboardComponent &#125;   <span class="keyword">from</span> <span class="string">'./dashboard/dashboard.component'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; HeroesComponent &#125;      <span class="keyword">from</span> <span class="string">'./heroes/heroes.component'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; HeroDetailComponent &#125;  <span class="keyword">from</span> <span class="string">'./hero-detail/hero-detail.component'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> routes: Routes = [</span><br><span class="line">  &#123; path: <span class="string">''</span>, redirectTo: <span class="string">'/dashboard'</span>, pathMatch: <span class="string">'full'</span> &#125;,</span><br><span class="line">  &#123; path: <span class="string">'dashboard'</span>, component: DashboardComponent &#125;,</span><br><span class="line">  &#123; path: <span class="string">'detail/:id'</span>, component: HeroDetailComponent &#125;,</span><br><span class="line">  &#123; path: <span class="string">'heroes'</span>, component: HeroesComponent &#125;</span><br><span class="line">];</span><br><span class="line"> </span><br><span class="line"><span class="meta">@NgModule</span>(&#123;</span><br><span class="line">  imports: [ RouterModule.forRoot(routes) ],</span><br><span class="line">  exports: [ RouterModule ]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> AppRoutingModule &#123;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Angular-HTTP"><a href="#Angular-HTTP" class="headerlink" title="Angular HTTP"></a>Angular HTTP</h4><p>Angular提供了HttpClient库作为Restful API的utility来完成Web前端的服务器数据交互。在程序中，HttpClient库一般本身不会单独存在于componnet中，而是作为Angular Service模块的底层调用库。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Service module</span></span><br><span class="line"><span class="keyword">import</span> &#123; Injectable &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"><span class="comment">// import httpclient Angular module</span></span><br><span class="line"><span class="keyword">import</span> &#123; HttpClient, HttpHeaders &#125; <span class="keyword">from</span> <span class="string">'@angular/common/http'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> &#123; Observable &#125; <span class="keyword">from</span> <span class="string">'rxjs/Observable'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; of &#125; <span class="keyword">from</span> <span class="string">'rxjs/observable/of'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; catchError, map, tap &#125; <span class="keyword">from</span> <span class="string">'rxjs/operators'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> &#123; Hero &#125; <span class="keyword">from</span> <span class="string">'./hero'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; MessageService &#125; <span class="keyword">from</span> <span class="string">'./message.service'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> httpOptions = &#123;</span><br><span class="line">  headers: <span class="keyword">new</span> HttpHeaders(&#123; <span class="string">'Content-Type'</span>: <span class="string">'application/json'</span> &#125;)</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Injectable</span>()</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> HeroService &#123;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">private</span> heroesUrl = <span class="string">'api/heroes'</span>;  <span class="comment">// URL to web api</span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"></span></span><br><span class="line"><span class="params">    <span class="keyword">private</span> http: HttpClient,</span></span><br><span class="line"><span class="params">    <span class="keyword">private</span> messageService: MessageService</span>) &#123; &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/** GET heroes from the server */</span></span><br><span class="line">  getHeroes (): Observable&lt;Hero[]&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.http.get&lt;Hero[]&gt;(<span class="keyword">this</span>.heroesUrl)</span><br><span class="line">      .pipe(</span><br><span class="line">        tap(<span class="function"><span class="params">heroes</span> =&gt;</span> <span class="keyword">this</span>.log(<span class="string">`fetched heroes`</span>)),</span><br><span class="line">        catchError(<span class="keyword">this</span>.handleError(<span class="string">'getHeroes'</span>, []))</span><br><span class="line">      );</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/** GET hero by id. Return `undefined` when id not found */</span></span><br><span class="line">  getHeroNo404&lt;Data&gt;(id: <span class="built_in">number</span>): Observable&lt;Hero&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> url = <span class="string">`<span class="subst">$&#123;this.heroesUrl&#125;</span>/?id=<span class="subst">$&#123;id&#125;</span>`</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.http.get&lt;Hero[]&gt;(url)</span><br><span class="line">      .pipe(</span><br><span class="line">        map(<span class="function"><span class="params">heroes</span> =&gt;</span> heroes[<span class="number">0</span>]), <span class="comment">// returns a &#123;0|1&#125; element array</span></span><br><span class="line">        tap(<span class="function"><span class="params">h</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">const</span> outcome = h ? <span class="string">`fetched`</span> : <span class="string">`did not find`</span>;</span><br><span class="line">          <span class="keyword">this</span>.log(<span class="string">`<span class="subst">$&#123;outcome&#125;</span> hero id=<span class="subst">$&#123;id&#125;</span>`</span>);</span><br><span class="line">        &#125;),</span><br><span class="line">        catchError(<span class="keyword">this</span>.handleError&lt;Hero&gt;(<span class="string">`getHero id=<span class="subst">$&#123;id&#125;</span>`</span>))</span><br><span class="line">      );</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/** GET hero by id. Will 404 if id not found */</span></span><br><span class="line">  getHero(id: <span class="built_in">number</span>): Observable&lt;Hero&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> url = <span class="string">`<span class="subst">$&#123;this.heroesUrl&#125;</span>/<span class="subst">$&#123;id&#125;</span>`</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.http.get&lt;Hero&gt;(url).pipe(</span><br><span class="line">      tap(_ =&gt; <span class="keyword">this</span>.log(<span class="string">`fetched hero id=<span class="subst">$&#123;id&#125;</span>`</span>)),</span><br><span class="line">      catchError(<span class="keyword">this</span>.handleError&lt;Hero&gt;(<span class="string">`getHero id=<span class="subst">$&#123;id&#125;</span>`</span>))</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* GET heroes whose name contains search term */</span></span><br><span class="line">  searchHeroes(term: <span class="built_in">string</span>): Observable&lt;Hero[]&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (!term.trim()) &#123;</span><br><span class="line">      <span class="comment">// if not search term, return empty hero array.</span></span><br><span class="line">      <span class="keyword">return</span> of([]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.http.get&lt;Hero[]&gt;(<span class="string">`api/heroes/?name=<span class="subst">$&#123;term&#125;</span>`</span>).pipe(</span><br><span class="line">      tap(_ =&gt; <span class="keyword">this</span>.log(<span class="string">`found heroes matching "<span class="subst">$&#123;term&#125;</span>"`</span>)),</span><br><span class="line">      catchError(<span class="keyword">this</span>.handleError&lt;Hero[]&gt;(<span class="string">'searchHeroes'</span>, []))</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">//////// Save methods //////////</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">/** POST: add a new hero to the server */</span></span><br><span class="line">  addHero (hero: Hero): Observable&lt;Hero&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.http.post&lt;Hero&gt;(<span class="keyword">this</span>.heroesUrl, hero, httpOptions).pipe(</span><br><span class="line">      tap(<span class="function">(<span class="params">hero: Hero</span>) =&gt;</span> <span class="keyword">this</span>.log(<span class="string">`added hero w/ id=<span class="subst">$&#123;hero.id&#125;</span>`</span>)),</span><br><span class="line">      catchError(<span class="keyword">this</span>.handleError&lt;Hero&gt;(<span class="string">'addHero'</span>))</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/** DELETE: delete the hero from the server */</span></span><br><span class="line">  deleteHero (hero: Hero | <span class="built_in">number</span>): Observable&lt;Hero&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> id = <span class="keyword">typeof</span> hero === <span class="string">'number'</span> ? hero : hero.id;</span><br><span class="line">    <span class="keyword">const</span> url = <span class="string">`<span class="subst">$&#123;this.heroesUrl&#125;</span>/<span class="subst">$&#123;id&#125;</span>`</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.http.delete&lt;Hero&gt;(url, httpOptions).pipe(</span><br><span class="line">      tap(_ =&gt; <span class="keyword">this</span>.log(<span class="string">`deleted hero id=<span class="subst">$&#123;id&#125;</span>`</span>)),</span><br><span class="line">      catchError(<span class="keyword">this</span>.handleError&lt;Hero&gt;(<span class="string">'deleteHero'</span>))</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/** PUT: update the hero on the server */</span></span><br><span class="line">  updateHero (hero: Hero): Observable&lt;<span class="built_in">any</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.http.put(<span class="keyword">this</span>.heroesUrl, hero, httpOptions).pipe(</span><br><span class="line">      tap(_ =&gt; <span class="keyword">this</span>.log(<span class="string">`updated hero id=<span class="subst">$&#123;hero.id&#125;</span>`</span>)),</span><br><span class="line">      catchError(<span class="keyword">this</span>.handleError&lt;<span class="built_in">any</span>&gt;(<span class="string">'updateHero'</span>))</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Handle Http operation that failed.</span></span><br><span class="line"><span class="comment">   * Let the app continue.</span></span><br><span class="line"><span class="comment">   * @param operation - name of the operation that failed</span></span><br><span class="line"><span class="comment">   * @param result - optional value to return as the observable result</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> handleError&lt;T&gt; (operation = <span class="string">'operation'</span>, result?: T) &#123;</span><br><span class="line">    <span class="keyword">return</span> (error: <span class="built_in">any</span>): Observable&lt;T&gt; =&gt; &#123;</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// <span class="doctag">TODO:</span> send the error to remote logging infrastructure</span></span><br><span class="line">      <span class="built_in">console</span>.error(error); <span class="comment">// log to console instead</span></span><br><span class="line"> </span><br><span class="line">      <span class="comment">// <span class="doctag">TODO:</span> better job of transforming error for user consumption</span></span><br><span class="line">      <span class="keyword">this</span>.log(<span class="string">`<span class="subst">$&#123;operation&#125;</span> failed: <span class="subst">$&#123;error.message&#125;</span>`</span>);</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// Let the app keep running by returning an empty result.</span></span><br><span class="line">      <span class="keyword">return</span> of(result <span class="keyword">as</span> T);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/** Log a HeroService message with the MessageService */</span></span><br><span class="line">  <span class="keyword">private</span> log(message: <span class="built_in">string</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.messageService.add(<span class="string">'HeroService: '</span> + message);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>HttpClient除了和真正的服务器交互外，还可以和in-memory的数据服务器进行虚拟交互，也就是说，在不修改(略微)原有程序代码的情况下，可以自己运用一个npm package设立一个in-memory的数据服务器，HttpClient并不知道request已经被这个in-memory服务器拦截并返回内存中的数据。</p>
<p>在前后端分离的开发过程中，如果要引用此功能，需要预先安装angular-in-memory-web-api的npm包。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install angular-in-memory-web-api@0.5 --save</span><br></pre></td></tr></table></figure>
<p>然后，创建in-memory-data.service模块，存储内存中的数据，作为HttpClient访问交互的相关数据。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; InMemoryDbService &#125; <span class="keyword">from</span> <span class="string">'angular-in-memory-web-api'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> InMemoryDataService <span class="keyword">implements</span> InMemoryDbService &#123;</span><br><span class="line">  createDb() &#123;</span><br><span class="line">    <span class="keyword">const</span> heroes = [</span><br><span class="line">      &#123; id: <span class="number">11</span>, name: <span class="string">'Mr. Nice'</span> &#125;,</span><br><span class="line">      &#123; id: <span class="number">12</span>, name: <span class="string">'Narco'</span> &#125;,</span><br><span class="line">      &#123; id: <span class="number">13</span>, name: <span class="string">'Bombasto'</span> &#125;,</span><br><span class="line">      &#123; id: <span class="number">14</span>, name: <span class="string">'Celeritas'</span> &#125;,</span><br><span class="line">      &#123; id: <span class="number">15</span>, name: <span class="string">'Magneta'</span> &#125;,</span><br><span class="line">      &#123; id: <span class="number">16</span>, name: <span class="string">'RubberMan'</span> &#125;,</span><br><span class="line">      &#123; id: <span class="number">17</span>, name: <span class="string">'Dynama'</span> &#125;,</span><br><span class="line">      &#123; id: <span class="number">18</span>, name: <span class="string">'Dr IQ'</span> &#125;,</span><br><span class="line">      &#123; id: <span class="number">19</span>, name: <span class="string">'Magma'</span> &#125;,</span><br><span class="line">      &#123; id: <span class="number">20</span>, name: <span class="string">'Tornado'</span> &#125;</span><br><span class="line">    ];</span><br><span class="line">    <span class="keyword">return</span> &#123;heroes&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，在app module模块中引入对in-memory-web-api的引用，和in-memory-data service模块的使用，并配置好in-memeory-server对应的data/service来源。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; NgModule &#125;       <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; BrowserModule &#125;  <span class="keyword">from</span> <span class="string">'@angular/platform-browser'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; FormsModule &#125;    <span class="keyword">from</span> <span class="string">'@angular/forms'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; HttpClientModule &#125;    <span class="keyword">from</span> <span class="string">'@angular/common/http'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// import in-memroy-data servier related module </span></span><br><span class="line"><span class="keyword">import</span> &#123; HttpClientInMemoryWebApiModule &#125; <span class="keyword">from</span> <span class="string">'angular-in-memory-web-api'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; InMemoryDataService &#125;  <span class="keyword">from</span> <span class="string">'./in-memory-data.service'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> &#123; AppRoutingModule &#125;     <span class="keyword">from</span> <span class="string">'./app-routing.module'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> &#123; AppComponent &#125;         <span class="keyword">from</span> <span class="string">'./app.component'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; DashboardComponent &#125;   <span class="keyword">from</span> <span class="string">'./dashboard/dashboard.component'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; HeroDetailComponent &#125;  <span class="keyword">from</span> <span class="string">'./hero-detail/hero-detail.component'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; HeroesComponent &#125;      <span class="keyword">from</span> <span class="string">'./heroes/heroes.component'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; HeroSearchComponent &#125;  <span class="keyword">from</span> <span class="string">'./hero-search/hero-search.component'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; HeroService &#125;          <span class="keyword">from</span> <span class="string">'./hero.service'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; MessageService &#125;       <span class="keyword">from</span> <span class="string">'./message.service'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; MessagesComponent &#125;    <span class="keyword">from</span> <span class="string">'./messages/messages.component'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@NgModule</span>(&#123;</span><br><span class="line">  imports: [</span><br><span class="line">    BrowserModule,</span><br><span class="line">    FormsModule,</span><br><span class="line">    AppRoutingModule,</span><br><span class="line">    HttpClientModule,</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// The HttpClientInMemoryWebApiModule module intercepts HTTP requests</span></span><br><span class="line">    <span class="comment">// and returns simulated server responses.</span></span><br><span class="line">    <span class="comment">// Remove it when a real server is ready to receive requests.</span></span><br><span class="line">    HttpClientInMemoryWebApiModule.forRoot(</span><br><span class="line">      InMemoryDataService, &#123; dataEncapsulation: <span class="literal">false</span> &#125;</span><br><span class="line">    )</span><br><span class="line">  ],</span><br><span class="line">  declarations: [</span><br><span class="line">    AppComponent,</span><br><span class="line">    DashboardComponent,</span><br><span class="line">    HeroesComponent,</span><br><span class="line">    HeroDetailComponent,</span><br><span class="line">    MessagesComponent,</span><br><span class="line">    HeroSearchComponent</span><br><span class="line">  ],</span><br><span class="line">  providers: [ HeroService, MessageService ],</span><br><span class="line">  bootstrap: [ AppComponent ]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> AppModule &#123; &#125;</span><br></pre></td></tr></table></figure>
<h3 id="Angular-Data-Model-–-Class"><a href="#Angular-Data-Model-–-Class" class="headerlink" title="Angular Data Model – Class"></a>Angular Data Model – Class</h3><p>In Angular 5, data model is encapsulated through classes, mainly for rendering templates in components. Creating a new class by Angular Cli:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ng generate class &#123;classname&#125;</span><br></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title>Microservice Architecture</title>
    <url>/2020/02/22/Microservice-Architecture/</url>
    <content><![CDATA[<h1 id="Why-Microservice"><a href="#Why-Microservice" class="headerlink" title="Why Microservice"></a>Why Microservice</h1><ul>
<li>Heterogenious technical stack：<br>支持多重技术栈，由于HTTP协议被多种编程语言支持，微服务可以用多种语言实现。</li>
<li>Robustness：整个App mesh网络不会因为单一的微服务的奔溃而停止工作。</li>
<li>Extensions：可以针对单一微服务进行扩展。</li>
<li>Simple deployment：微服务可以进行独立部署，不需要因为单一服务升级而多次部署。</li>
<li>Efficiency：微服务小团队开发高效敏捷。</li>
<li>More client support：多种前端客户端支持，可以重复利用同一个微服务后端网络。</li>
<li>Migration：基于单一微服务迁移的整体升级，阻碍更小。</li>
</ul>
<h1 id="What-is-Microservice"><a href="#What-is-Microservice" class="headerlink" title="What is Microservice"></a>What is Microservice</h1><p>微服务就是一些协同工作的小而自治的服务。</p>
<h1 id="How-to-architect-Microservices"><a href="#How-to-architect-Microservices" class="headerlink" title="How to architect Microservices"></a>How to architect Microservices</h1><h2 id="微服务特点"><a href="#微服务特点" class="headerlink" title="微服务特点"></a>微服务特点</h2><ul>
<li>Loose coupling松耦合</li>
</ul>
<ul>
<li>High Cohesion高内聚</li>
</ul>
<h2 id="上下文边界确定"><a href="#上下文边界确定" class="headerlink" title="上下文边界确定"></a>上下文边界确定</h2><p>业务或者职能的界限，往往也可以作为微服务架构中的服务边界。不同的业务只能之间的内部细节并不需要相互知晓。同一个事件，在不同的业务职能会有不同的体现，但是在内部细节上却没有相互交叉。</p>
<h2 id="共享和隐藏模型设计"><a href="#共享和隐藏模型设计" class="headerlink" title="共享和隐藏模型设计"></a>共享和隐藏模型设计</h2><p>限界上下文的确立，能够帮助确立共享模块，对于处于两个上下文边界上需要共同的消息，可以确立一个共享模块，专门进行信息共享。同时，对于上下文内部的逻辑，也能进行对应的逻辑模块设计，从而完成对于整个上下文的设计。</p>
<h2 id="切勿过早划分"><a href="#切勿过早划分" class="headerlink" title="切勿过早划分"></a>切勿过早划分</h2><p>对于一些过早划分的业务产品，警惕由于后期需求用例改变造成多个上下文之间的重叠。比较推荐的是先进行单体设计，不进行划分，在服务稳定之后再进行划分设计迁移，基于以有代码进行划分，比从头开始构建微服务简单得多。</p>
<h2 id="逐步划分上下文"><a href="#逐步划分上下文" class="headerlink" title="逐步划分上下文"></a>逐步划分上下文</h2><p>不断对上下文的界限进行迭代，从复杂的共享模型中慢慢抽出简单的共享模型，将嵌套的模块逐步上升到顶层模型，对其中某些紧密关联模型进行共享。当然，模型共享的粒度取决于代码是分开维护还是集中维护，如果是集中维护也未尝不可进行嵌套模型共享。</p>
<h1 id="微服务的集成"><a href="#微服务的集成" class="headerlink" title="微服务的集成"></a>微服务的集成</h1><p>微服务之间的通信机制，可以成为微服务的集成。微服务间的API相互调用设计需要注意一下几个方面：</p>
<ul>
<li><p>为用户创建接口</p>
<p>  用户上下文会触发一定特定的流程。</p>
</li>
<li><p>共享数据库</p>
<p>  数据库是多个微服务共享的，因为每个微服务都可能对同一个数据库进行修改。</p>
</li>
<li><p>同步与异步通信模式</p>
<p>  两种不同的通信模式中，同步模式会阻塞线程，而异步模式是基于事件响应请求的，能提降低耦合性，提高吞吐量。</p>
</li>
<li><p>编排与协同</p>
<p>  编排和协同是两种管理流程的架构风格。（同步）编排是通过一个中心执行者将每一步的步骤执行，知道获取最终的结果。（异步)协同则是以事件为机制进行执行，执行单元会订阅事件，API调用会触发一个事件，事件订阅者则会自动执行响应的流程。后者会需要监控服务，监控结果要映射到流程中，troubleshooting难度增加，这是一个难题。ATOM是一个符合REST规范的协议可以通过它提供资源feed的发布服务，客户端可以消费该信息。</p>
</li>
<li><p>RPC与REST</p>
<p>  远程调用允许进行本地调用，事实上是由某个远程服务器产生。RPC会有一定的技术耦合要求。protocol buffers, Thrift是比较推荐的RPC框架。REST则是RPC的一个替代方案。通过URI对客户端与服务器进行了松耦合。</p>
</li>
<li><p>Json与XML</p>
<p>  JSON与XML都是一种有效的数据序列化格式，前者更加流行XML对超媒体控制更加好。</p>
</li>
<li><p>API重定向</p>
<p>  API的重定向常常发生在多个API版本共存的时候，当老版本的API准备deco时，需要绞杀者模式将旧的API拦截，选择是否替换成新版本的实现。当旧版本的访问完全消失时，再删除旧的API。</p>
</li>
</ul>
<h1 id="拆分成微服务"><a href="#拆分成微服务" class="headerlink" title="拆分成微服务"></a>拆分成微服务</h1><ol>
<li>寻找独立的上下文边界——接缝</li>
<li>拆分数据库表格的混合加载功能，放弃直接利用数据库命令访问上下文边界间的外键，改为由代码（微服务服务API）</li>
<li>共享的静态数据改由配置维护关联。</li>
<li>针对共享数据，建立合适的领域进行关联，例如代码中建立客户关系，来维护财务——客户——仓库关系。</li>
<li>共享表格，对于有大量列信息的表格，可以根据上下文边界将表格拆分成两个。</li>
<li>自数据库开始进行代码重构。</li>
<li>事务的边界重构，对于多表的修改操作，需要协同处理错误，或者利用分布式事务处理工具代为管理事务。</li>
<li>拆分后的数据库在制作报表时会出现问题，因为不再能用sql语言进行表格操作。解决方法可以是主动定期导出表格合并，或者基于修改时间订阅导出行为。</li>
</ol>
<h1 id="部署微服务"><a href="#部署微服务" class="headerlink" title="部署微服务"></a>部署微服务</h1><ol>
<li>准备CI系统，流水线，自动化流程</li>
<li>Paas，Docker打包部署</li>
</ol>
<h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><ol>
<li>单元测试</li>
<li>服务测试(mock/打桩)</li>
<li>E2E测试 —— 消费者驱动的测试</li>
<li>上线 —— 金丝雀发布法</li>
</ol>
<h1 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h1><p>微服务的监控难度高于单一服务器应用。微服务包含多个服务，而每个服务的实例个数不等。关联标识可以帮忙关联同一个事件服务调用的日志，采用统一标准化的格式能够更快的辅助错误定位。</p>
<p>监控的内容包括CPU，响应时间，以及合理的语义监控（合成事务监控）。</p>
<h1 id="微服务安全"><a href="#微服务安全" class="headerlink" title="微服务安全"></a>微服务安全</h1><ol>
<li>身份验证和授权</li>
</ol>
<p>身份雅正确认了登录者的身份。授权机制能够确定登录者可以访问和进行的操作。常见的单点登录（Single Sign-On)，企业级标准为SAML和OpenID Connect，前者基于SOAP标准，后者基于OAuth2.0. 身份提供者可以是外部系统或者内部目录服务，如LDAP/AD等。</p>
<p>微服务的身份认证和授权部分可以依托于网关，网关可以作为认证代理，通过网管认证的所有查询和操作都可以发送到微服务集群任意一个实例中处理。微服务内部可以决定身份可以授权的操作。</p>
<ol start="2">
<li>服务间的身份验证和授权</li>
</ol>
<p>服务之间的身份验证是指微服务的各个服务之间的身份验证和授权，一般来说有如下几种方式管理:</p>
<ul>
<li>在微服务边界内允许一切</li>
<li>HTTP(S)基本身份验证（HTTP明文传输认证信息，如果基于SSL认证则需要管理多台服务器之间的自签发证书。）</li>
<li>使用SAML或OpenID Connect认证授权，可以有效的避免中间人攻击，这样每个服务也需要一个身份。</li>
<li>客户端证书（采用客户端X.509证书，通过TLS层协议对服务器验证进行保证。)</li>
<li>HMAC（Hash-based Message Authentication Code,请求主题和私有密钥一起被哈希处理后进行发送，服务器使用请求主题和自己私钥副本重建哈希值。如果匹配则接收，防止的中间人攻击。)</li>
<li>JWT(JSON Web Token,JWT的原则是在服务器身份验证之后，将生成一个JSON对象并将其发送回用户。当用户与服务器通信时，客户在请求中发回JSON对象。服务器仅依赖于这个JSON对象来标识用户。为了防止用户篡改数据，服务器将在生成对象时添加签名。)</li>
<li>API密钥(API密钥是给予某种形式的秘密令牌的名称，该秘密令牌与Web服务（或类似）请求一起提交以便识别请求的来源。密钥可以包括在请求内容的一些摘要中，以进一步验证原点并防止篡改值。)</li>
</ul>
<ol start="3">
<li>数据加密（现存多种算法进行数据加密，密钥可以通过加盐哈希保护）</li>
<li>深度防御</li>
</ol>
<ul>
<li>防火墙</li>
<li>日志</li>
<li>入侵监测</li>
<li>网络隔离</li>
<li>操作系统安全</li>
<li>OWASP标准(Open Web Application Security Project开放式Web应用程序安全项目,<a href="https://www.owasp.org" target="_blank" rel="noopener">https://www.owasp.org</a>)</li>
</ul>
<h1 id="系统设计与组织架构"><a href="#系统设计与组织架构" class="headerlink" title="系统设计与组织架构"></a>系统设计与组织架构</h1><p>公司团队的组织架构会影响系统设计。</p>
<ul>
<li><p>单地域的团队拥有更加好的灵活性和效率，因此对于异地团队最好的办法是想办法合理拆分，让不同的团队负责不同的松耦合模块。</p>
</li>
<li><p>每个团队需要负责对服务的需求，更改，构建，部署到运维，自治的团队能够很好的激励团队的效率。</p>
</li>
<li><p>小团队规模，少于10个人的团队能够对其所负责的系统整个生命周期负责，技术选择和实现上具有灵活性。当然这个对服务的高效构建部署效率很高，比如利用云服务的Infra来轻松构建CI/CD流程。</p>
</li>
</ul>
<h1 id="规模化微服务"><a href="#规模化微服务" class="headerlink" title="规模化微服务"></a>规模化微服务</h1><ul>
<li><p>允许故障无处不在，故障永远会在意想不到的时候发生，所以微服务本身需要能够允许故障出现，硬件上也不用为避免故障作特殊设计。</p>
</li>
<li><p>服务平行扩容阈值控制，需要参考一些系统参数，响应时间/延迟，可用性，数据持久性（丢包率）。</p>
</li>
<li><p>当故障出现时，适当的服务功能降级，允许应用能够在其他方面能够正确运行而不是直接返回错误界面。</p>
</li>
<li><p>微服务延迟的影响控制，通常会导致worker线程池的阻塞队列超长，最终线程池没有可用的线程而宕机。合理设置线程池的舱壁bulkhead，在舱位线程用尽后断路该服务，避免因为单个服务的延迟影响导致所有的线程都阻塞于同一个服务。</p>
</li>
<li><p>数据库扩展，当数据库需要服务于高吞吐量服务时，可以通过数据库副本，RDBMS系统，扩展写操作，独立CQRS读写分离系统，等多种方式扩展。</p>
</li>
<li><p>缓存可以优化重复请求，氛围哭护短、代理和服务器端缓存。</p>
</li>
<li><p>自动伸缩，当云管理能够强大到自动调整微服务实例个数，就可以基于当前流量进行自动调整。</p>
</li>
<li><p>CAP定理(一致性consistency、可用性availability和分区容忍性partition tolerance)是分布式系统中需要控制好的三个平衡。</p>
</li>
<li><p>服务发现，可以通过DNS服务器进行关联，负载均衡服务器将查询分发到不同的IP服务器上。</p>
</li>
<li><p>动态服务注册，新加入的微服务实例的IP应用信息需要能共享给其他服务，Zookeeper，consul和Eureka等服务可以管理配置管理和服务发现。</p>
</li>
<li><p>文档服务，为API构建合适的文档，Swagger可以很好的自动生成API文档，HAL和HAL浏览器也可以客户端逐步探索API。</p>
</li>
<li><p>自描述系统（UDDI Universal Description Discovery and Integration通用描述发现与集成服务），这个标准能帮助了解哪些服务正在运行。</p>
</li>
</ul>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>Microservice</tag>
        <tag>Office Addin</tag>
      </tags>
  </entry>
  <entry>
    <title>Phoenix Project Reading Notes</title>
    <url>/2018/11/17/Phoenix-Project-Reading-Notes/</url>
    <content><![CDATA[<h1 id="读书笔记-——-《凤凰项目：一个IT运维的传奇故事》"><a href="#读书笔记-——-《凤凰项目：一个IT运维的传奇故事》" class="headerlink" title="读书笔记 —— 《凤凰项目：一个IT运维的传奇故事》"></a>读书笔记 —— 《凤凰项目：一个IT运维的传奇故事》</h1><p>本书从IT运维管理者的第一视角，讲述了IT部门每天都会发生的事情，并通过从工厂管理经验中借鉴到的方法，改善了IT部分的产能的故事。</p>
<h2 id="IT工作者的每日工作项目"><a href="#IT工作者的每日工作项目" class="headerlink" title="IT工作者的每日工作项目"></a>IT工作者的每日工作项目</h2><p>IT人员的工作往往分为如下几个项目。所以每一个程序员需要重视这四类工作。</p>
<h3 id="业务项目"><a href="#业务项目" class="headerlink" title="业务项目"></a>业务项目</h3><p>这是多数开发项目所包含的业务举措，通常隶属于项目管理办公室。虽然是IT项目，但大多数是跟业务的利润有直接相关联。</p>
<h3 id="IT内部项目"><a href="#IT内部项目" class="headerlink" title="IT内部项目"></a>IT内部项目</h3><p>IT内部项目包括可能由业务项目衍生出的基础架构或IT运维项目，亿级内部生成的改进项目（例如创建新环境和部署自动化等）。这类项目业务部门并不是直接集中跟踪管理的，而属于预算所有者（例如数据库经理、存储管理经理和分布式系统经理）。</p>
<h3 id="变更"><a href="#变更" class="headerlink" title="变更"></a>变更</h3><p>经常由前两种类型的工作引起，往往在保修系统中被跟踪（例如IT运维补救、JIRA或者用于开发的敏捷计划工具）。事实上，在价值流的两个不同部分中存在两个工作跟踪系统，这会引起问题，尤其在交接工作的时候。</p>
<p>某些情况下，在一些兼具功能开发和服务交付指责的专门团队中，所有工作都会处在同一个系统中。这样做的好处是，操作层面的故障会和功能缺陷以及新的特性功能一起，在存量工作和现行工作中显现。</p>
<p>在生产环境的变更是需要严格关注的，有的公司会专门对生产环境的变更进行记录。尤其会对变更本身的原因，步骤，以及风险评估和处理细节都进行记录。变更记录会交由管理者进行审批从而在计划时间窗口生效。</p>
<h3 id="计划外项目-救火"><a href="#计划外项目-救火" class="headerlink" title="计划外项目/救火"></a>计划外项目/救火</h3><p>包括操作事故和操作问题，通常由上述三类型的工作导致，而且往往以牺牲其他计划内工作为代价。</p>
<h2 id="布伦特——约束点问题"><a href="#布伦特——约束点问题" class="headerlink" title="布伦特——约束点问题"></a>布伦特——约束点问题</h2><p>文中的工程师布伦特是IT运维部的约束点，原因是：</p>
<ul>
<li>IT运维工作中最优秀的救火队员</li>
<li>IT运维视角唯一的项目系统架构师</li>
<li>IT变更项目中时常存在的执行者</li>
<li>项目半成品堆积：由于救火项目或者忙等待问题造成。</li>
</ul>
<p>每个工作中心中都存在他的身影，个人能力的有限决定了IT部门的产出有限。</p>
<p><strong>约束点问题解决了，工作产能问题便能解决。所有在非约束点做的改进都是假象。</strong></p>
<p>对应的改善约束点问题的方案：</p>
<ul>
<li>建立L3支持工程师代替执行并学习布伦特的救火技术，建立其他人可以借鉴的trouble shooting检查清单。</li>
<li>专一做到资深架构应该做的工作：关键项目的系统架构</li>
<li>将需要布伦特参与的项目进行工作和流程标准化管理</li>
<li>IT工作可视化并控制半成品</li>
</ul>
<blockquote>
<p>等待时间是工作中心中某个资源忙碌成都的函数。下图横轴坐标上是工作重心中给定资源的忙碌百分比，纵坐标轴上是大致的等待时间（更确切的说是队列长度）。等待时间=忙碌时间百分比/空闲时间百分比。曲线的形状表明，当资源使用率超过80%时，等待时间就会直线上升。这会对项目交付产生灾难性后果。</p>
</blockquote>
<p><img src="/2018/11/17/Phoenix-Project-Reading-Notes/WaitingTime.jpg" alt="waitingtime"></p>
<p>看板对于IT中的半成品问题是最有效、最简单的一种对策。两本书推荐阅读：</p>
<ol>
<li>《个人看板:了解工作/驾驭生活》by吉姆·本森和托尼安妮·德马里亚·巴里</li>
<li>《看板方法：科技企业渐进变革成功之道》by戴维·J·安德森</li>
</ol>
<h2 id="工作流程改进————形"><a href="#工作流程改进————形" class="headerlink" title="工作流程改进————形"></a>工作流程改进————形</h2><p>为了将IT的工作项目完善的进行预先评估和量化分析，每一项工作类型都可以进行执行周期的管理与规划，尽量减少工作半成品的积压，并且最大化工作成品的“吞吐量”。本文提出需要进行“改进形”计划：</p>
<blockquote>
<p>以两周为周期，进行两个“计划-执行-审核-落实”改进周期，确立项目需要的四大要素：机器、方法、人员与测评。每两周必须做出一些改进，无论任何形式的改进。</p>
</blockquote>
<blockquote>
<p>积压的项目分为三类：需要布伦特参与的项目，可以提高布伦特生产力的项目，其他项目。优先开展后两类项目；对于需要布伦特参与的项目遵循约束点问题解决方案进行优化。</p>
</blockquote>
<p>“改进形”带来的好处：</p>
<ul>
<li>提供一种适用于各种问题或挑战的系统化科学规程；</li>
<li>组织成员普遍养成解决问题的习惯；</li>
<li>通过让经理开展周期性指导，让其向教练和导师的角色转变；</li>
<li>通过让人们每天慢慢进步的方法，形成PDCA（Plan-Do-Check-Action）。</li>
</ul>
<blockquote>
<p>微软IT案例研究《在9个月内实现逆袭：在微软IT部门应用鼓点-缓冲-绳子解决法（译注：即限制驱导式排程法）》，作者是戴维·J．安德森和德拉戈什·杜密特里乌。</p>
<p>当时安德森和杜密特里乌两人都在微软，他们描述了以前那种糟透了的状态。大多数IT从业人员&gt;对那种状态都再熟悉不过了。</p>
<p>❑ 完成业务部门要求的工作耗时过长：平均交付周期是155天。</p>
<p>❑ 对于延误和长交付周期的不满迫使IT管理作出“更多的工作预估”，这让经理们不得不把全部时<br>间都用来做PPT，而不是干实事（因为业务部门的结论是他们没有作出正确的工作预估）。</p>
<p>❑ 不管业务部门提出什么要求，回答永远是“做这件事需要5个月”。</p>
<p>❑ 每项任务都预计在20天内完成，但是没人知道多出的那135天都去哪儿了。</p>
<p>杜密特里乌在报修系统中创建了一个名叫“等待德拉戈什”的新字段（实际上，这个报修系统是微&gt;软缺陷跟踪系统），以及时发现工作阻碍。他很快得出结论，项目团队70%的时间都卡在了别人&gt;那里——也就是说，在70%的时间里，工作都在排队。<br>杜密特里乌认为，他的团队一个月只能完成3项工作，按照这个速度，需要三年才能完成所有的&gt;工作。以下是他提出的对策及其惊人结果。</p>
<p>❑ 他们不再预估工作，而采用根据历史数据得出的实际时间——他们有80个人——报修系统里有多&gt;年的工作记录供他们使用。这样做的结果是开发和测试效率立刻提高了30%。</p>
<p>❑ 他们不再采用成本核算，而采用简单的“基于预算贡献的ROI（Return on Investment，投资&gt;回报率）”。所节省的时间让PM能力立刻提高了20%。</p>
<p>❑ 发现约束点是开发部之后，PM接管了许多开发任务，把开发能力提高了20%。这样做也让开发&gt;人员更加高兴，因为他们可以专心写代码，不用再作任务预估了。</p>
<p>❑ 他们引进了一名可用性专家来调整变更申请表。（他打趣说：“我们得填完4页表格，才能得到&gt;一杯水；我们把4页表格换成2页的，上面还有很多自由格式字段，目的是保证从事这项工作的人&gt;了解其所需的全部信息。”）</p>
<p>❑ 接着他们减少了系统中允许的半成品数量：一开始平均有40到60个未结项目，他们把未结项目&gt;数减少到了5个。</p>
<p>❑ 然后他们创建了工作缓冲区，任何遇到阻碍的开发或测试人员都能在缓冲区里做一些工作。</p>
<p>❑ 交付周期从155天下降到22天。这么短的交付周期让他们创造了一个新的SLA认证（SLA &gt;guarantee）,25天（哇哦！）。</p>
<p>❑ 他们的下一轮生产能力大幅提高来自于增加开发人员数量，因为每两天的开发工作就需要一天&gt;的测试工作。他们提拔了愿意参与开发工作的测试人员，把开发人员和测试人员的比例从1∶1提&gt;高到2∶1。</p>
<p>❑ 上述种种的结果是什么？他们在9个月里完成了整整3年积压下来的工作；对他们服务的需求量&gt;也增加了，然后他们继续在其后的每个月都顺利完成并交付了所有业务部门要求的工作；不仅没&gt;人被解雇，而且很多人还升了职。<br>杜密特里乌说：“我们始终致力于降低交付周期，而不是开发和测试自身的优化，因此我们成功&gt;了。”</p>
<p>这只是详细描述的众多惊人转变之一。难以置信的是，转变主要不是基于自动化，相反，这种不&gt;可思议的改进来自于调整关于工作系统的策略和控制半成品的策略，确保有一个高效的跨职能团&gt;队，让所有事情都为约束点服务，以及管理好工作交接。</p>
</blockquote>
<h1 id="IT工作管理核心思想"><a href="#IT工作管理核心思想" class="headerlink" title="IT工作管理核心思想"></a>IT工作管理核心思想</h1><h2 id="三步工作法"><a href="#三步工作法" class="headerlink" title="三步工作法"></a>三步工作法</h2><p><strong>第一工作法</strong>是关于从开发到IT运维再到客户的整个自左向右的工作流。为了使流量最大化，我们需要小的批量规模和工作间隔，决不让缺陷刘翔下游工作中心，并且不断为了整体目标(相对于开发功能完成率、测试发现/修复比率或运维有效性指标等局部目标）进行优化。</p>
<p>必要的做法包括持续构建、集成以及部署，按需创建环境，严控半成品，以及构建起能够顺利变更的安全系统和组织。</p>
<p><strong>第二工作法</strong>是关于价值流各阶段自右向左的快速持续反馈流，放大其效益以确保防止问题再次发生，或者更快地发现和修复问题。这样，我们就能在所需之处获取或嵌入知识，从源头上保证质量。</p>
<p>必要的做法包括：在部署管道中的构建和测试失败时“停止生产线”；日复一日地持续改进日常工作；创建快速的自动化测试套装软件，以确保代码总是处于可部署的状态；在开发和IT运维之间建立共同的目标和共同解决问题的机制；建立普遍的产品遥测技术，让每个人都能知道，代码和环境是否在按照设定的运行，以及是否达到了客户的目标。</p>
<p><strong>第三工作法</strong>是关于创造公司文化，该文化可带动两种风气的形成：不断尝试，这需要承担风险并从成功和失败中吸取经验教训；理解重复和练习是熟练掌握的前提。</p>
<p>尝试和承担风险让我们能够不懈地改进工作系统，这经常要求我们去做一些与几十年来的做法大不相同的事。一旦出了问题，不断重复的日常操练赋予我们的技能和经验，令我们可以撤回至安全区域并恢复正常运作。</p>
<p>必要的做法包括营造一种勇于创新、敢于冒险（相对于畏惧或盲目服从命令）以及高信任度（相对于低信任度和命令控制）的文化，把至少20%的开发和IT运维周期划拨给非功能性需求，并且不断鼓励进行改进。</p>
<h2 id="团队领导力的寓言"><a href="#团队领导力的寓言" class="headerlink" title="团队领导力的寓言"></a>团队领导力的寓言</h2><p>这是帕特里克·兰西奥尼在《团队领导的五大障碍：关于领导力的寓言》（The Five Dysfunctions of a Team: A Leadership Fable）一书中描述的方法。<br>他认为，团队无法达成目标的一个核心诱因是信任缺失。在他的模型中，五大障碍被描述为：</p>
<ul>
<li>信任缺失——不愿在团队中显示弱点；</li>
<li>惧怕冲突——在充满激情的建设性辩论中寻求和谐的假象；</li>
<li>缺乏诚意——假意与团队的决策达成一致，形成模棱两可的公司氛围；</li>
<li>回避问责——面对员工的失职行为，逃避追责，降低了工作标准；</li>
<li>忽视结果——对个人成就、地位和自我价值的关注超过了对团队成功的关注。</li>
</ul>
<p>考虑到开发部和IT运维部之间，以及IT和“业务部门”之间存在着长期、剧烈的部门斗争，我想我们非常需要兰西奥尼先生的教诲以实现开发运维的理想。<br>通常来说，运用兰西奥尼先生方法论的第一步，是领导人要展示自己的弱点（或者起码要从塑造示弱的行为着手）。在《凤凰计划》中，史蒂夫多年来已将这一实践内化于心，并主导了一场关于个人经历的分享活动。</p>
<h2 id="信息安全问题解决思想"><a href="#信息安全问题解决思想" class="headerlink" title="信息安全问题解决思想"></a>信息安全问题解决思想</h2><p>以不对IT系统做过多无用功就保护公司不受审计困扰，才是最终的胜利。而不是一昧的强制加入新的安全补丁，限制IT系统的功能与产出更多的维护问题。正如QA不需要测试不再需要的功能和不可能发生的性能压力，不要犯“眼界的错误”。</p>
<h2 id="优先项目永远优先"><a href="#优先项目永远优先" class="headerlink" title="优先项目永远优先"></a>优先项目永远优先</h2><p>关乎公司存亡的项目永远放在第一位。必要时可以冻结其他项目进度以提供充足的资源，人力和时间。</p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>肉肉</tag>
        <tag>运维管理</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM Class Loader Subsystem</title>
    <url>/2019/02/10/JVM-Class-Loader-Subsystem/</url>
    <content><![CDATA[<h1 id="Class文件结构"><a href="#Class文件结构" class="headerlink" title="Class文件结构"></a>Class文件结构</h1><p>Class文件时一组以8位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在Class文件之中，中间没有添加任何分隔符，这使得整个Class文件中存储的内容几乎全部是程序运行的必要数据。</p>
<p>Class文件本身是由下图的这些数据类型组成，这些数据项之间并没有分隔符，而是通过约定好的规范和表结构填入对应的信息，从而将Java语言代码翻译成字节码。Class文件数据项包含如下这些类型。</p>
<p><img src="/2019/02/10/JVM-Class-Loader-Subsystem/ClassFileDataType.jpg" alt="ClassFileDataType"></p>
<h2 id="1-魔数"><a href="#1-魔数" class="headerlink" title="1. 魔数"></a>1. 魔数</h2><p>第1~4字节：0xCAFEBABE</p>
<h2 id="2-Class文件的版本"><a href="#2-Class文件的版本" class="headerlink" title="2. Class文件的版本"></a>2. Class文件的版本</h2><p>第5、6字节：次版本号（4x.0~4x.65535）</p>
<p>第7、8字节：主版本号 （45~）</p>
<h2 id="3-常量池"><a href="#3-常量池" class="headerlink" title="3. 常量池"></a>3. 常量池</h2><p>常量池入口放置一项u2类型的数据，代表常量池容量计数值，从1开始。0作为没有常量池的表述。</p>
<ul>
<li><p>字面量：接近Java语言层面常量概念，如文本字符串、声明为final的常量值等。</p>
</li>
<li><p>符号引用：<strong>编译原理</strong>概念，包括三类常量：</p>
<ol>
<li>类和接口的全限定名</li>
<li>字段的名称和描述符</li>
<li>方法的名称和描述符</li>
</ol>
</li>
</ul>
<p>常量池中每一项常量都是一个表。JDK中定义了14种结构的表结构数据，如下图所示：</p>
<p><img src="/2019/02/10/JVM-Class-Loader-Subsystem/ConstantFlag.jpg" alt="ConstantFlag"></p>
<p>表开始的第一位都是一个u1类型的标志位（binary 0000 0000 0000 0000 中某几位为1），代表本表属于哪种常量类型，而后则遵从常量表自己的格式填入数据，结构总表如下所示。</p>
<p><img src="/2019/02/10/JVM-Class-Loader-Subsystem/ConstantPool.jpg" alt="ConstantPool"></p>
<h2 id="4-访问标志"><a href="#4-访问标志" class="headerlink" title="4. 访问标志"></a>4. 访问标志</h2><p>常量池后面两个字节：以16个标志位识别类或接口层次的访问信息，包括：</p>
<pre><code>1. Class是类还是接口；
2. 是否为public类型；
3. 是否为abstract类型；
4. 如果是类的话，是否被声明为final。
</code></pre><p>访问标志本身总共由16个标志位可以使用，具体代表如下图所示：</p>
<p><img src="/2019/02/10/JVM-Class-Loader-Subsystem/ClassAccessFlag.jpg" alt="AccessFlag"></p>
<h2 id="5-类索引、父类索引和接口索引集合"><a href="#5-类索引、父类索引和接口索引集合" class="headerlink" title="5. 类索引、父类索引和接口索引集合"></a>5. 类索引、父类索引和接口索引集合</h2><p>类索引和父类索引都是一个u2类型的数据，而接口索引集合是一组u2类型的数据的集合，Class文件中由这三项数据确定这个类的全限定名。</p>
<p>类索引和父类索引都指向了一个CONSTANT_Class_info类，而接口所以则第一位是接口的个数，后面跟了相应个数的索引分别指向CONSTANT_Class_info类。</p>
<h2 id="6-字段表集合"><a href="#6-字段表集合" class="headerlink" title="6. 字段表集合"></a>6. 字段表集合</h2><p>字段表用于描述接口或者类中声明的变量。字段包括类级变量以及实例级变量，但不包括在方法内部声明的局部变量。</p>
<p>字段结构如下所示：</p>
<p><img src="/2019/02/10/JVM-Class-Loader-Subsystem/Field.jpg" alt="Field"></p>
<p>字段的访问标志位有如下这些表格，标志位值和Class访问标志定义一样，但是支持的标志个数不一样：</p>
<p><img src="/2019/02/10/JVM-Class-Loader-Subsystem/FieldAccessFlag.jpg" alt="FieldAccessFlag"></p>
<ol>
<li><p>name_index保存的是对常量池CONSTANT_Utf8的引用，保存了方法简单名称。</p>
<p> 全限定名和简单名称很好理解，“org/fenixsoft/clazz/TestClass”是这个类的全限定名，仅仅是把类全名中的“.”替换成了“/”而已，为了使连续的多个全限定名之间不产生混淆，在使用时最后一般会加入一个“;”表示全限定名结束。简单名称是指没有类型和参数修饰的方法或者字段名称，这个类中的inc()方法和m字段的简单名称分别是“inc”和“m”。</p>
</li>
</ol>
<ol start="2">
<li><p>描述符引用指向了一个字段/方法描述符CONSTANT_Utf8。</p>
<ul>
<li><p>字段描述符，比如int实例变量的描述符是“I”;java.lang.Object 的实例描述符是 “Ljava/lang/Object;”，“double[][][]”的描述符为“[[[D”;</p>
</li>
<li><p>方法描述符，比如Object mymethod(int i, double d, Thread t)的描述符为 (IDLjava/lang/Thread;)Ljava/lang/Object;。</p>
<p>描述符支持如下类型：</p>
<p><img src="/2019/02/10/JVM-Class-Loader-Subsystem/Descriptor.jpg" alt="Descriptor"></p>
</li>
</ul>
</li>
</ol>
<h2 id="7-方法表集合"><a href="#7-方法表集合" class="headerlink" title="7. 方法表集合"></a>7. 方法表集合</h2><p>方法表用于描述接口或者类中声明的方法，包括类级方法以及实例方法。表结构跟字段表相似，在此不再赘述。</p>
<p><img src="/2019/02/10/JVM-Class-Loader-Subsystem/Field.jpg" alt="Field"></p>
<p>方法的访问标志与字段不同，如下图:</p>
<p><img src="/2019/02/10/JVM-Class-Loader-Subsystem/MethodAccessFlag.jpg" alt="MethodAccessFlag"></p>
<h2 id="8-属性表集合"><a href="#8-属性表集合" class="headerlink" title="8. 属性表集合"></a>8. 属性表集合</h2><p>属性表并不是单独存在的表，而是在Class文件、字段表、方法表都可以携带自己的属性表集合，用于描述某些场景专有的信息。属性表结构对后续属性进行了总表，结构如下:</p>
<p><img src="/2019/02/10/JVM-Class-Loader-Subsystem/AttributeInfo.jpg" alt="AttrubuteInfo"></p>
<p>目前虚拟机规范定义了下列属性：</p>
<p><img src="/2019/02/10/JVM-Class-Loader-Subsystem/AttributeCollection.jpg" alt="Attrubute_info"></p>
<h1 id="字节码指令"><a href="#字节码指令" class="headerlink" title="字节码指令"></a>字节码指令</h1><p>Java编译器将代码的操作本身处理生成了字节码指令，放在了Code属性中，JVM读取指令进行执行。JVM支持的字节码指令和操作数如表格所示:</p>
<p><img src="/2019/02/10/JVM-Class-Loader-Subsystem/OptCode.jpg" alt="OptCode"></p>
<h1 id="Class加载时机"><a href="#Class加载时机" class="headerlink" title="Class加载时机"></a>Class加载时机</h1><p>5大主动引用场景：</p>
<ol>
<li>遇到new、getstatic、putstatic或invokestatic这4条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。生成这4条指令的最常见的Java代码场景是：使用new关键字实例化对象的时候、读取或设置一个类的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）的时候，以及调用一个类的静态方法的时候。</li>
<li>使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。</li>
<li>当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</li>
<li>当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。</li>
<li>当使用JDK 1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。</li>
</ol>
<p>不会出发加载的三个被动引用例子：</p>
<ol>
<li>通过子类引用父类的静态字段，不会导致子类初始化。</li>
<li>通过数组定义来引用类，不会出发此类的初始化。</li>
<li>常量在编译阶段会存入调用类的常量池中，本质上没有直接引用到定义敞亮的类，因此不会触发定义常量的类的初始化。</li>
</ol>
<h1 id="Class加载过程"><a href="#Class加载过程" class="headerlink" title="Class加载过程"></a>Class加载过程</h1><p>类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）7个阶段。其中验证、准备、解析3个部分统称为连接（Linking），这7个阶段的发生顺序如下图所示。</p>
<p><img src="/2019/02/10/JVM-Class-Loader-Subsystem/ClassLoader.jpg" alt="ClassLoader"></p>
<h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><ol>
<li><p>通过一个类的全限定名来获取定义此类的二进制字节流</p>
</li>
<li><p>将字节流所代表的静态存储结构转化为方法区的运行时数据结构：</p>
<ul>
<li>如果是数组，JVM会直接创建数组类<ol>
<li>引用类型的数组： 递归采用类加载过程去加载这个类型</li>
<li>如果是非引用类型的数组：JVM将会把数组标记为引导类加载器关联。</li>
</ol>
</li>
</ul>
</li>
<li><p>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据访问入口。</p>
</li>
</ol>
<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><ol>
<li>文件格式验证</li>
</ol>
<p>验证字节流是否符合Class文件格式的规范。</p>
<ol start="2">
<li>元数据验证</li>
</ol>
<p>对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范要求。</p>
<ol start="3">
<li>字节码验证</li>
</ol>
<p>通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。</p>
<ol start="4">
<li>符号引用验证</li>
</ol>
<p>发生在符号引用转化为直接引用的时候，是对类自身意外（常量池里的各种符号引用）信息进行匹配性校验。</p>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>正式为变量分配内存并设置类变量为初始值阶段。引用类型的内存分配具体步骤参考<a href="/2018/11/07/JVM-memory-management-and-GC/#JVM对象的创建">JVM新对象创建</a>。</p>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>虚拟机将常量池内的符号引用替换为直接引用的过程。</p>
<ul>
<li><p>符号引用：符号引用以一组符号来描述引用的目标，符号可与是任何形式的字面量，只要能无歧义的定义到目标即可。</p>
</li>
<li><p>直接引用：直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。</p>
</li>
</ul>
<p>解析动作主要针对如下：</p>
<ol>
<li>类或接口 CONSTANT_Class_info</li>
<li>字段 CONSTANT_Fieldref_info</li>
<li>类方法 CONSTANT_Methodref_info</li>
<li>接口方法 CONSTANT_InterfaceMethodref_info</li>
<li>方法类型 CONSTANT_MethodType_info</li>
<li>方法句柄 CONSTANT_MethodHandle_info</li>
<li>和调用点限定符 CONSTANT_InvokeDynamic_info</li>
</ol>
<p>这7类符号引用进行。</p>
<ul>
<li><p>类或接口的解析</p>
<ol>
<li>如果C不是一个数组类型，那虚拟机将会把代表N的全限定名传递给D的类加载器去加载这个类C。在加载过程中，由于元数据验证、字节码验证的需要，又可能触发其他相关类的加载动作，例如加载这个类的父类或实现的接口。一旦这个加载过程出现了任何异常，解析过程就宣告失败。</li>
<li>如果C是一个数组类型，并且数组的元素类型为对象，也就是N的描述符会是类似“[Ljava/lang/Integer”的形式，那将会按照第1点的规则加载数组元素类型。如果N的描述符如前面所假设的形式，需要加载的元素类型就是“java.lang.Integer”，接着由虚拟机生成一个代表此数组维度和元素的数组对象。</li>
<li>如果上面的步骤没有出现任何异常，那么C在虚拟机中实际上已经成为一个有效的类或接口了，但在解析完成之前还要进行符号引用验证，确认D是否具备对C的访问权限。如果发现不具备访问权限，将抛出java.lang.IllegalAccessError异常。</li>
</ol>
</li>
<li><p>字段解析</p>
<ol start="0">
<li>首先将会对字段表内class_index￼项中索引的CONSTANT_Class_info符号引用进行解析，也就是字段所属的类或接口的符号引用。如果在解析这个类或接口符号引用的过程中出现了任何异常，都会导致字段符号引用解析的失败。</li>
<li>如果C本身就包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。</li>
<li>否则，如果在C中实现了接口，将会按照继承关系从下往上递归搜索各个接口和它的父接口，如果接口中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。</li>
<li>否则，如果C不是java.lang.Object的话，将会按照继承关系从下往上递归搜索其父类，如果在父类中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。</li>
<li>否则，查找失败，抛出java.lang.NoSuchFieldError异常。</li>
</ol>
</li>
<li><p>类方法解析</p>
<ol start="0">
<li>首先将会对字段表内class_index￼项中索引的CONSTANT_Class_info符号引用进行解析</li>
<li>类方法和接口方法符号引用的常量类型定义是分开的，如果在类方法表中发现class_index中索引的C是个接口，那就直接抛出java.lang.IncompatibleClassChangeError异常。</li>
<li>如果通过了第1步，在类C中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</li>
<li>否则，在类C的父类中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</li>
<li>否则，在类C实现的接口列表及它们的父接口之中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果存在匹配的方法，说明类C是一个抽象类，这时查找结束，抛出java.lang.AbstractMethodError异常。</li>
<li>否则，宣告方法查找失败，抛出java.lang.NoSuchMethodError。</li>
</ol>
</li>
<li><p>接口方法解析</p>
<ol start="0">
<li>首先将会对字段表内class_index￼项中索引的CONSTANT_Class_info符号引用进行解析</li>
<li>与类方法解析不同，如果在接口方法表中发现class_index中的索引C是个类而不是接口，那就直接抛出java.lang.IncompatibleClassChangeError异常。</li>
<li>否则，在接口C中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</li>
<li>否则，在接口C的父接口中递归查找，直到java.lang.Object类（查找范围会包括Object类）为止，看是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</li>
<li>否则，宣告方法查找失败，抛出java.lang.NoSuchMethodError异常。</li>
</ol>
</li>
</ul>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>类初始化阶段是类加载过程的最后一步，前面的类加载过程中，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的Java程序代码。</p>
<ul>
<li><p><code>&lt;clinit&gt;()</code>方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{}块）中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问。</p>
</li>
<li><p><code>&lt;clinit&gt;()</code>方法与类的构造函数（或者说实例构造器<code>&lt;init&gt;()</code>方法）不同，它不需要显式地调用父类构造器，虚拟机会保证在子类的<code>&lt;clinit&gt;()</code>方法执行之前，父类的<code>&lt;clinit&gt;()</code>方法已经执行完毕。因此在虚拟机中第一个被执行的<code>&lt;clinit&gt;()</code>方法的类肯定是java.lang.Object。</p>
</li>
<li><p>由于父类的<code>&lt;clinit&gt;()</code>方法先执行，也就意味着父类中定义的静态语句块要优先于子类的变量赋值操作，如下在代码清单中，字段B的值将会是2而不是1。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> A = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        A = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> B = A;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    System.out.println(Sub.B);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>&lt;clinit&gt;()</code>方法对于类或接口来说并不是必需的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成<code>&lt;clinit&gt;()</code>方法。</p>
</li>
<li><p>￼接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口与类一样都会生成<code>&lt;clinit&gt;()</code>方法。但接口与类不同的是，执行接口的<code>&lt;clinit&gt;()</code>方法不需要先执行父接口的<code>&lt;clinit&gt;()</code>方法。只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的<code>&lt;clinit&gt;()</code>方法。</p>
</li>
<li><p>虚拟机会保证一个类的<code>&lt;clinit&gt;()</code>方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的<code>&lt;clinit&gt;()</code>方法，其他线程都需要阻塞等待，直到活动线程执行<code>&lt;clinit&gt;()</code>方法完毕。如果在一个类的<code>&lt;clinit&gt;()</code>方法中有耗时很长的操作，就可能造成多个进程阻塞￼，在实际应用中这种阻塞往往是很隐蔽的。</p>
</li>
</ul>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h2 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h2><h1 id="Class加载器"><a href="#Class加载器" class="headerlink" title="Class加载器"></a>Class加载器</h1><p>虚拟机设计团队把类加载阶段中的“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类。这种实现便是类加载器。</p>
<blockquote>
<p>对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。</p>
</blockquote>
<p>类的相等语义，只有在这两个类是由同一个类加载器加载的前提下才有意义，只要类加载器不同，即使是加载自同一个Class文件，两个类也是不等的。（相等指的是，Class对象的equals(), isAssignableFrom(), isInstance()， instantof 的返回结果。例如下面代码运行结果则是：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class org.fenixsoft.classloading.ClassLoaderTest</span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> throw Exception </span>&#123;</span><br><span class="line">        <span class="comment">// Class ClassLoader define and override</span></span><br><span class="line">        ClassLoader myLoader = <span class="keyword">new</span> ClassLoader() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throw</span> ClassNotFoundException&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    String fileName = name.substring(name.lastIndextOf(<span class="string">"."</span>) + <span class="number">1</span>) + <span class="string">".class"</span>;</span><br><span class="line">                    InputStream is = getClass().getResourceAsStream(fileName);</span><br><span class="line">                    <span class="keyword">if</span>(is == <span class="keyword">null</span>)&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">super</span>.loadClasse(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">byte</span>[] b = <span class="keyword">new</span> bye[is.available()];</span><br><span class="line">                    is.read(b);</span><br><span class="line">                    <span class="keyword">return</span> defineClass(name, b, <span class="number">0</span>, b.length);</span><br><span class="line">                &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Object obj = myLoader.loadClass(<span class="string">"org.fenixsoft.classloading.ClassLoaderTest"</span>).newInstance();</span><br><span class="line"></span><br><span class="line">        System.out.println(obj.getClass());</span><br><span class="line">        System.out.println(obj <span class="keyword">instanceof</span> org.fenixsoft.classloading.ClassLoaderTest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="类加载器类型"><a href="#类加载器类型" class="headerlink" title="类加载器类型"></a>类加载器类型</h2><p>目前只存在两种不同的类加载器：一种是启动类加载器(Bootstrap ClassLoader)，C++语言实现，虚拟机自身的一部分；另一种就是所有其他类加载器，继承自抽象类java.lang.ClassLoader。</p>
<ul>
<li>启动类加载器（Bootstrap ClassLoader）：前面已经介绍过，这个类将器负责将存放在&lt;JAVA_HOME&gt;\lib目录中的，或者被-Xbootclasspath参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如rt.jar，名字不符合的类库即使放在lib目录中也不会被加载）类库加载到虚拟机内存中。启动类加载器无法被Java程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给引导类加载器，那直接使用null代替即可，如下列代码清单所示为java.lang.ClassLoader.getClassLoader()方法的代码片段。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ClassLoader <span class="title">getClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ClassLoader cl = getClassLoader0();</span><br><span class="line">    <span class="keyword">if</span>(cl == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    SecurityManager sm = System.getSecurityManger();</span><br><span class="line">    <span class="keyword">if</span>(sm != <span class="keyword">null</span>)&#123;</span><br><span class="line">        ClassLoader ccl = ClassLoader.getCallerClassLoader();</span><br><span class="line">        <span class="keyword">if</span>(ccl != <span class="keyword">null</span> &amp;&amp; ccl != cl &amp;&amp; !cl.isAncestor(ccl))&#123;</span><br><span class="line">            sm.checkPermission(SecurityConstants.GET_CLASSLOADER_PERMISSION);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>扩展类加载器（Extension ClassLoader）：这个加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载&lt;JAVA_HOME&gt;\lib\ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。</p>
</li>
<li><p>应用程序类加载器（Application ClassLoader）：这个类加载器由sun.misc.Launcher$App-ClassLoader实现。由于这个类加载器是ClassLoader中的getSystemClassLoader()方法的返回值，所以一般也称它为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</p>
</li>
</ul>
<h2 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h2><p>图中展示的类加载器之间的这种层次关系，称为类加载器的双亲委派模型（Parents Delegation Model）。双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。这里类加载器之间的父子关系一般不会以继承（Inheritance）的关系来实现，而是都使用组合（Composition）关系来复用父加载器的代码。</p>
<p><img src="/2019/02/10/JVM-Class-Loader-Subsystem/ParentsDelegationModel.jpg" alt="ParentDelegationModel"></p>
<p>双亲委派模型的工作过程是：</p>
<ol>
<li>所有的加载请求都委派给父类加载器去完成。</li>
<li>当父类加载器反馈自己无法完成加载请求，子加载器才会尝试自己加载。</li>
</ol>
<p>双亲委派模型保证了Java程序优先从启动类加载器进行搜索加载，使得java.lang.Object类型在程序的各种类加载环境中都是同一个类，能够稳定运行程序。</p>
<p>双亲委派模型实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">synchronized</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException&#123;</span><br><span class="line">    <span class="comment">//首先，检查请求的类是否已经加载过了</span></span><br><span class="line">    Class c = findLoadedClass(name);</span><br><span class="line">    <span class="keyword">if</span>( c == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(parent != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="comment">// 委派父类加载器先去尝试加载</span></span><br><span class="line">                c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                c = findBootstrapClassOrNull(name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="comment">// 如果父类加载器抛出异常，说明父类加载器不能加载，因此调用子类进行加载</span></span><br><span class="line">            c = findClass(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(resolve) &#123;</span><br><span class="line">        resolveClass(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="破坏双亲委派模型情况"><a href="#破坏双亲委派模型情况" class="headerlink" title="破坏双亲委派模型情况"></a>破坏双亲委派模型情况</h2><ol>
<li><p>loadClass没有按照双亲委派模型进行实现： 目前已经不推荐重写loadClass方法，而是重写findClass方法，从而保证模型安全。</p>
</li>
<li><p>第三方JNDI接口提供者/SPI的代码不能被启动类加载器加载：线程上下文类加载器(Tread Context ClassLoader)。可以通过java.lang.Thread类的setContextClassLoader()进行设置。如果父类及应用全局都没有设置过，则默认就是应用程序类加载器。这样就让父类加载器请求子类加载器去加载SPI的代码。</p>
</li>
<li><p>为程序动态性的追求导致：代码热替换(HotSwap),模块热部署(Hot Deployment)等。每一个程序模块都有自己的类加载器，当需要更换一块程序模块是，就把这块代码以及类加载器一起换掉以实现代码的热替换。OSGi收到类加载请求时：</p>
<ol>
<li>将以java.*开头的类委派给父类加载器加载。</li>
<li>否则，将委派列表名单内的类委派给父类加载器加载。</li>
<li>否则，将Import列表中的类委派给Export这个类的Bundle的类加载器加载。</li>
<li>否则，查找当前Bundle的ClassPath，使用自己的类加载器加载。</li>
<li>否则，查找类是否在自己的Fragment Bundle中，如果在，则委派给Fragment Bundle的类加载器加载。</li>
<li>否则，查找Dynamic Import列表的Bundle，委派给对应Bundle的类加载器加载。</li>
<li><p>否则，类查找失败。</p>
<p>此实现只有前两个点符合双亲委派模型，后面的都是平级的类加载器中进行。</p>
</li>
</ol>
</li>
</ol>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>肉肉</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Java Memory Model</title>
    <url>/2018/12/24/Java-Memory-Model/</url>
    <content><![CDATA[<p>本文将从JMM的理论模型和系统设计角度切入讲述并发工具的内存语义与实现细节。</p>
<h1 id="JMM存在的目的"><a href="#JMM存在的目的" class="headerlink" title="JMM存在的目的"></a>JMM存在的目的</h1><p>Java虚拟机规范中试图定义一种Java内存模型来屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各个平台下都能达到一致的内存访问效果。</p>
<p><img src="/2018/12/24/Java-Memory-Model/JMM.jpg" alt="JMM"></p>
<h1 id="JVM内存模型操作"><a href="#JVM内存模型操作" class="headerlink" title="JVM内存模型操作"></a>JVM内存模型操作</h1><p><strong>主内存操作</strong></p>
<ul>
<li>lock：将一个变量表示为一条线程独占的状态。</li>
<li>unlock: 将一个处于锁定状态的变量释放，释放后的变量才可以被其他线程锁定。</li>
<li>read: 将一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用。</li>
<li>write: 将store操作从工作内存中得到的变量值放入主内存的变量中。</li>
</ul>
<p><strong>工作内存操作</strong></p>
<ul>
<li>load: 把read操作从主内存得到的变量值放入到工作内存的变量副本中。</li>
<li>use: 把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到需要使用变量复制的字节码指令时执行这个操作。</li>
<li>assign: 把一个执行引擎的接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。 </li>
<li>store: 把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用。</li>
</ul>
<h2 id="内存操作执行基本规则"><a href="#内存操作执行基本规则" class="headerlink" title="内存操作执行基本规则"></a>内存操作执行基本规则</h2><ul>
<li><p>不允许read和load、store和write操作之一单独出现，即不允许一个变量从主内存读取了但工作内存不接受，或者从工作内存发起回写了但主内存不接受的情况出现。</p>
</li>
<li><p>不允许一个线程丢弃它的最近的assign操作，即变量在工作内存中改变了之后必须把该变化同步回主内存。</p>
</li>
<li><p>不允许一个线程无原因地（没有发生过任何assign操作）把数据从线程的工作内存同步回主内存中。</p>
</li>
<li><p>一个新的变量只能在主内存中“诞生”，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量，换句话说，就是对一个变量实施use、store操作之前，必须先执行过了assign和load操作。</p>
</li>
<li><p>一个变量在同一个时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。</p>
</li>
<li><p>如果对一个变量执行lock操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或assign操作初始化变量的值。</p>
</li>
<li><p>如果一个变量事先没有被lock操作锁定，那就不允许对它执行unlock操作，也不允许去unlock一个被其他线程锁定住的变量。</p>
</li>
<li><p>对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行store、write操作）。</p>
</li>
</ul>
<h1 id="JVM内存模型特性"><a href="#JVM内存模型特性" class="headerlink" title="JVM内存模型特性"></a>JVM内存模型特性</h1><ul>
<li>原子性 JVM对基本数据类型的访问读写（上述操作）是具备原子性的。</li>
<li>可见性 当一个线程修改了共享变量的值，其他线程能够立刻知道这个修改。而volatile变量较普通变量能够保证多线程场景下线程在每次读写前都能刷新。</li>
<li>有序性 本线程内，操作都是有序；多线程场景下，线程间操作是无序的。</li>
</ul>
<h2 id="Happen-Before先行发生法则"><a href="#Happen-Before先行发生法则" class="headerlink" title="Happen-Before先行发生法则"></a>Happen-Before先行发生法则</h2><p>先行发生是JMM中定义的两项操作之前的偏序关系，如果说操作A先行发生于操作B，其实就是说发生操作B之前，操作A产生的影响能够被B观察到，“影响”包括修改了内存中共享变量的值、发送了消息、调用了方法等。</p>
<p>具体体现：</p>
<ul>
<li><p><strong>程序次序规则（Program Order Rule）</strong>：在一个线程内，按照程序代码顺序，书写在前面的操作先行发生于书写在后面的操作。准确地说，应该是控制流顺序而不是程序代码顺序，因为要考虑分支、循环等结构。</p>
</li>
<li><p><strong>管程锁定规则（Monitor Lock Rule）</strong>：一个unlock操作先行发生于后面对同一个锁的lock操作。这里必须强调的是同一个锁，而“后面”是指时间上的先后顺序。</p>
</li>
<li><p><strong>volatile变量规则（Volatile Variable Rule）</strong>：对一个volatile变量的写操作先行发生于后面对这个变量的读操作，这里的“后面”同样是指时间上的先后顺序。</p>
</li>
<li><p><strong>线程终止规则（Thread Termination Rule）</strong>：线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值等手段检测到线程已经终止执行。</p>
</li>
<li><p><strong>线程中断规则（Thread Interruption Rule）</strong>：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测到是否有中断发生。</p>
</li>
<li><p><strong>对象终结规则（Finalizer Rule）</strong>：一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize()方法的开始。</p>
</li>
<li><p><strong>传递性（Transitivity）</strong>：如果操作A先行发生于操作B，操作B先行发生于操作C，那就可以得出操作A先行发生于操作C的结论。</p>
</li>
</ul>
<h1 id="指令重排"><a href="#指令重排" class="headerlink" title="指令重排"></a>指令重排</h1><p>编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段。</p>
<h2 id="单线程重排序："><a href="#单线程重排序：" class="headerlink" title="单线程重排序："></a>单线程重排序：</h2><ul>
<li><strong>数据依赖性</strong>：程序的任意两个操作的执行是可能具有一定的依赖性，不能改变。</li>
<li><strong>as-if-serial语义</strong>：单线程程序的执行结果不能改变。</li>
<li><strong>程序顺序规则</strong>: happens-before的顺序规则不能修改。</li>
</ul>
<h2 id="多线程重排序："><a href="#多线程重排序：" class="headerlink" title="多线程重排序："></a>多线程重排序：</h2><ul>
<li><strong>顺序一致性模型</strong>：概念上模型只有一个单一的全局内存，所有操作线程在每一步操作后看到的内存内容都是一致的。实际上并不能完全保证，只能保证同步程序在进出临界区内代码各个线程的内存视图能够一致。</li>
</ul>
<h1 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h1><p>硬件层的内存屏障分为两种：Load Barrier 和 Store Barrier即读屏障和写屏障。<br>内存屏障有两个作用：</p>
<ol>
<li>阻止屏障两侧的指令重排序；</li>
<li>强制把写缓冲区/高速缓存中的脏数据等写回主内存，让缓存中相应的数据失效。</li>
</ol>
<p>对于Load Barrier来说，在指令前插入Load Barrier，可以让高速缓存中的数据失效，强制从新从主内存加载数据；</p>
<p>对于Store Barrier来说，在指令后插入Store Barrier，能让写入缓存中的最新数据更新写入主内存，让其他线程可见。</p>
<h2 id="java内存屏障"><a href="#java内存屏障" class="headerlink" title="java内存屏障"></a>java内存屏障</h2><p>java的内存屏障通常所谓的四种即LoadLoad,StoreStore,LoadStore,StoreLoad实际上也是上述两种的组合，完成一系列的屏障和数据同步功能。</p>
<ul>
<li>LoadLoad屏障：对于这样的语句Load1; LoadLoad; Load2，在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。</li>
<li>StoreStore屏障：对于这样的语句Store1; StoreStore; Store2，在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。</li>
<li>LoadStore屏障：对于这样的语句Load1; LoadStore; Store2，在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕。</li>
<li>StoreLoad屏障：对于这样的语句Store1; StoreLoad; Load2，在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。它的开销是四种屏障中最大的。在大多数处理器的实现中，这个屏障是个万能屏障，兼具其它三种内存屏障的功能</li>
</ul>
<h1 id="Java同步工具的内存语义及实现"><a href="#Java同步工具的内存语义及实现" class="headerlink" title="Java同步工具的内存语义及实现"></a>Java同步工具的内存语义及实现</h1><h2 id="锁的内存语义及实现"><a href="#锁的内存语义及实现" class="headerlink" title="锁的内存语义及实现"></a>锁的内存语义及实现</h2><p>锁的语义决定了临界区代码的执行具有原子性。</p>
<h3 id="内存语义"><a href="#内存语义" class="headerlink" title="内存语义"></a>内存语义</h3><p>锁的释放可以让线程向获取同一个锁的线程发送消息。<br>锁的获取可以让线程对应的内存失效使得临界代码必须从主内存获取共享变量。</p>
<h3 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h3><p>公平锁获取通过AbstractQueuedSynchronizer即AQS实现，通过一个整型的volatile变量state来维护同步状态。拿锁时，tryAcquire方法会查看state值是否为0，即无锁状态，并将state值设置为传入变量acquires，如果state不为0，且owner不是current线程，则返回false.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span></span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">  <span class="keyword">int</span> c = getState();</span><br><span class="line">  <span class="keyword">if</span>(c == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>( isFirst(current)) &amp;&amp; compareAndSetState(<span class="number">0</span>, acquires) &#123;</span><br><span class="line">      setExclusiveOwnerThread(current);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(current == getExclusiveOwnerThread())&#123;</span><br><span class="line">    <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">    <span class="keyword">if</span>(nextc &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Max lock count exceeded"</span>);</span><br><span class="line">      setState(nextc);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>非公平锁的获取不需要tryAcquire方法中通过isFirst(current))方法进行竞争，而是直接调用compareAndSetState(int expect, int update)。</p>
<p>(非)公平锁释放通过tryRelease(int releases)实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">  <span class="keyword">if</span>( Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IlleagalMonitorStateException();</span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span>( c == <span class="number">0</span>)&#123;</span><br><span class="line">      free = <span class="keyword">true</span>;</span><br><span class="line">      setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="CAS-内存语义及操作内容"><a href="#CAS-内存语义及操作内容" class="headerlink" title="CAS 内存语义及操作内容"></a>CAS 内存语义及操作内容</h2><h3 id="内存语义-1"><a href="#内存语义-1" class="headerlink" title="内存语义"></a>内存语义</h3><p>CAS更新操作，同时具有volatile读和volatile写的内存语义。</p>
<h3 id="操作内容"><a href="#操作内容" class="headerlink" title="操作内容"></a>操作内容</h3><p>CAS是处理器的一种操作，是native方法API。</p>
<ol>
<li>确保对内存读-改-写的原子性。</li>
<li>禁止CAS指令前后读写指令重排。</li>
<li>把缓存区的<strong>所有</strong>数据刷新到内存中。</li>
</ol>
<h2 id="volatile-内存语义及实现"><a href="#volatile-内存语义及实现" class="headerlink" title="volatile 内存语义及实现"></a>volatile 内存语义及实现</h2><h3 id="内存语义-2"><a href="#内存语义-2" class="headerlink" title="内存语义"></a>内存语义</h3><p>volatile写与锁的释放有相同的内存语义，volatile读与锁的获取有相同内存语义。</p>
<h3 id="实现细节-1"><a href="#实现细节-1" class="headerlink" title="实现细节"></a>实现细节</h3><ul>
<li>通过插入内存屏障，来组织编译器/操作系统进行指令重排序。</li>
<li><p>通过关联读/写操作和使用操作（用之前必须从主内存读，assign后必须写入主内存，以及写happens-before读规则）强制CPU的缓存失效来保证内存可见性。<br>volatile的内存屏障策略如下：</p>
</li>
<li><p>在每个volatile写操作前插入StoreStore屏障，在写操作后插入StoreLoad屏障；<br><img src="/2018/12/24/Java-Memory-Model/VolatileWrite.png" alt="volatile-write"></p>
</li>
<li>在每个volatile读操作后分别插入LoadLoad屏障，和LoadStore屏障；<br><img src="/2018/12/24/Java-Memory-Model/VolatileRead.png" alt="volatile-read"></li>
</ul>
<p>由于内存屏障的作用，避免了volatile变量和其它指令重排序、线程之间实现了通信，使得volatile表现出了锁的特性。</p>
<p>volatile强制缓存失效策略如下:</p>
<ul>
<li><p><strong>线程的Load、read和Use进行关联</strong>:只有当线程T对变量V执行的前一个动作是load的时候，线程T才能对变量V执行use动作；并且，只有当线程T对变量V执行的后一个动作是use的时候，线程T才能对变量V执行load动作。线程T对变量V的use动作可以认为是和线程T对变量V的load、read动作相关联，必须连续一起出现（这条规则要求在工作内存中，每次使用V前都必须先从主内存刷新最新的值，用于保证能看见其他线程对变量V所做的修改后的值）。</p>
</li>
<li><p><strong>Assign和所有线程的store，write进行关联</strong>只有当线程T对变量V执行的前一个动作是assign的时候，线程T才能对变量V执行store动作；并且，只有当线程T对变量V执行的后一个动作是store的时候，线程T才能对变量V执行assign动作。线程T对变量V的assign动作可以认为是和线程T对变量V的store、write动作相关联，必须连续一起出现（这条规则要求在工作内存中，每次修改V后都必须立刻同步回主内存中，用于保证其他线程可以看到自己对变量V所做的修改）。</p>
</li>
<li><p><strong>不同变量的上述的两段操作顺序一致</strong>假定动作A是线程T对变量V实施的use或assign动作，假定动作F是和动作A相关联的load或store动作，假定动作P是和动作F相应的对变量V的read或write动作；类似的，假定动作B是线程T对变量W实施的use或assign动作，假定动作G是和动作B相关联的load或store动作，假定动作Q是和动作G相应的对变量W的read或write动作。如果A先于B，那么P先于Q（这条规则要求volatile修饰的变量不会被指令重排序优化，保证代码的执行顺序与程序的顺序相同）。</p>
<blockquote>
<p>Happens before法则: 前一个操作的执行结果要对第二个操作可见。</p>
</blockquote>
</li>
</ul>
<h2 id="final-内存语义与实现细节"><a href="#final-内存语义与实现细节" class="headerlink" title="final 内存语义与实现细节"></a>final 内存语义与实现细节</h2><p>final关键字可以放在static域，实例成员域，和局部变量三种变量前。其中final修饰的局部变量的可以作为线程的局部变量传递给子线程。也能保证并发情况下的内存语义。</p>
<h3 id="内存语义-3"><a href="#内存语义-3" class="headerlink" title="内存语义"></a>内存语义</h3><p>对于final域，编译器和CPU会遵循两个重排序规则：</p>
<ul>
<li>新建对象过程中，构造体中对final域的初始化写入和这个对象赋值给其他引用变量，这两个操作不能重排序；（废话嘛）</li>
<li>初次读包含final域的对象引用和读取这个final域，这两个操作不能重排序；（晦涩，意思就是先赋值引用，再调用final值）</li>
</ul>
<p>总之上面规则的意思可以这样理解，必需保证一个对象的所有final域被写入完毕后才能引用和读取。这也是内存屏障的起的作用：</p>
<h3 id="实现细节-2"><a href="#实现细节-2" class="headerlink" title="实现细节"></a>实现细节</h3><ul>
<li><p>写final域：在编译器写final域完毕，构造体结束之前，会插入一个StoreStore屏障，保证前面的对final写入对其他线程/CPU可见，并阻止this指针赋值与final域写被重排序(this = new Object(){ finalField = …})。（如果没有，普通域的写可以被重排到构造函数外）<br><img src="/2018/12/24/Java-Memory-Model/FinalWrite.png" alt="final-write"></p>
</li>
<li><p>写final域的成员域:构造函数内对一个final引用的对象的成员域的写入，与随后在构造函数外把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。<br><img src="/2018/12/24/Java-Memory-Model/FinalElementWrite.png" alt="final-element-write"></p>
</li>
<li><p>读final域：在上述规则2中，两步操作不能重排序的机理就是在读final域前插入了LoadLoad屏障，这个阻止了读取this引用和读取final域的重排序（isntance.finalField）。<br><img src="/2018/12/24/Java-Memory-Model/FinalRead.png" alt="final-read"></p>
</li>
</ul>
<p>X86处理器中，由于CPU不会对写-写操作进行重排序，所以StoreStore屏障会被省略；而X86也不会对逻辑上有先后依赖关系的操作进行重排序，所以LoadLoad也会变省略。</p>
<blockquote>
<p>只要对象是正确构造的（被构造对象的引用在构造函数中没有“逸出”），那么不需要使用同步（指 lock 和 volatile 的使用），就可以保证任意线程都能看到这个 final 域在构造函数中被初始化之后的值。</p>
</blockquote>
<p>this逸出代码：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalReferenceEscapeExample</span> </span>&#123;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">static</span> FinalReferenceEscapeExample obj;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FinalReferenceEscapeExample</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    i = <span class="number">1</span>;                              <span class="comment">//1写final域</span></span><br><span class="line">    obj = <span class="keyword">this</span>;                          <span class="comment">//2 this引用在此“逸出”</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> FinalReferenceEscapeExample ();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> reader &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj != <span class="keyword">null</span>) &#123;                     <span class="comment">//3</span></span><br><span class="line">        <span class="keyword">int</span> temp = obj.i;                 <span class="comment">//4</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Concurrent包的内存语义及实现"><a href="#Concurrent包的内存语义及实现" class="headerlink" title="Concurrent包的内存语义及实现"></a>Concurrent包的内存语义及实现</h2><p>Concurrent包底层实现依赖如下图所示：</p>
<p><img src="/2018/12/24/Java-Memory-Model/Concurrent.png" alt="Cocurrent"></p>
<h1 id="延迟初始化问题讨论"><a href="#延迟初始化问题讨论" class="headerlink" title="延迟初始化问题讨论"></a>延迟初始化问题讨论</h1><p>延迟初始化是在需要实例的时候再进行初始化，从而达到提升程序初始化性能的目的。然而延迟初始化需要考虑多线程并发访问，和指令重排序问题。</p>
<h2 id="静态域延迟初始化"><a href="#静态域延迟初始化" class="headerlink" title="静态域延迟初始化"></a>静态域延迟初始化</h2><p>静态域的延迟初始化能通过final关键词实现，因为final静态域能保证多线程安全初始化，同事也能保证computeFieldValue()方法不会溢出FieldHolder的构造方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FieldHolder</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> FieldType field = computeFieldValue();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> FieldType <span class="title">getField</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> FieldHolder.field;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="成员域延迟初始化"><a href="#成员域延迟初始化" class="headerlink" title="成员域延迟初始化"></a>成员域延迟初始化</h2><h3 id="单重检查模式"><a href="#单重检查模式" class="headerlink" title="单重检查模式"></a>单重检查模式</h3><p>单重检查模式能够确保大多数情况的fiel的同步，但是当computeFieldValue()执行和field赋值可以重排序，导致在第一次检查时其他线程可能看到不完整的field值，并返回。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> FieldType field;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> FieldType <span class="title">getField</span><span class="params">()</span></span>&#123;</span><br><span class="line">  FieldType result = field;</span><br><span class="line">  <span class="keyword">if</span>(result == <span class="keyword">null</span>)&#123;</span><br><span class="line">    field = result = computeFieldValue();</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="双重检查模式"><a href="#双重检查模式" class="headerlink" title="双重检查模式"></a>双重检查模式</h3><p>双重检查模式通过synchronized和volatile的内存语义，3, 4对其他线程可见，且其他线程在1处的读不会重排序到2语块的内部，能够确保在线程更新field值时，与其他线程查看field值之间的读写能够顺序执行。</p>
<p>局部变量result的使用能够保证尽量少次数的访问field和取锁，提升运行效率。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> FieldType field;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> FieldType <span class="title">getField</span><span class="params">()</span></span>&#123;</span><br><span class="line">  FieldType result = field;</span><br><span class="line">  <span class="keyword">if</span>(result == <span class="keyword">null</span>)&#123;</span><br><span class="line">    result = field;</span><br><span class="line">    <span class="keyword">if</span>(result == <span class="keyword">null</span>)&#123; <span class="comment">// 1</span></span><br><span class="line">      synchornized(<span class="keyword">this</span>)&#123; <span class="comment">// 2</span></span><br><span class="line">        field = result = computeFieldValue(); <span class="comment">//3, 4</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>肉肉</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java NIO</title>
    <url>/2020/12/18/Java-NIO/</url>
    <content><![CDATA[<h1 id="Java异步计算方法与异步网络通信框架"><a href="#Java异步计算方法与异步网络通信框架" class="headerlink" title="Java异步计算方法与异步网络通信框架"></a>Java异步计算方法与异步网络通信框架</h1><h2 id="Java异步方法"><a href="#Java异步方法" class="headerlink" title="Java异步方法"></a>Java异步方法</h2><p>异步方法(Java asynchronized programming)是提升程序性能的一个有效手段，采用已经封装好的方法，让JVM去控制线程的创建和回收管理，减少了线程的阻塞，让程序员更加关注方法的设计。</p>
<h3 id="Callable-Future-和FutureTask"><a href="#Callable-Future-和FutureTask" class="headerlink" title="Callable,Future, 和FutureTask"></a>Callable,Future, 和FutureTask</h3><ul>
<li>Callable</li>
</ul>
<p>Callable接口使用泛型去定义它的返回类型。Executors类提供了一些有用的方法去在线程池中执行Callable内的任务。由于Callable任务是并行的，必须等待它返回的结果。java.util.concurrent.Future对象解决了这个问题。</p>
<p>在线程池提交Callable任务后返回了一个Future对象，使用它可以知道Callable任务的状态和得到Callable返回的执行结果。Future提供了get()方法，等待Callable结束并获取它的执行结果。</p>
<p>Callable与Runnable接口很相似，不同之处在于一个需要返回值，一个不需要。而且Callable可以抛出异常。</p>
<ul>
<li>Future和FutureTask</li>
</ul>
<p>FutureTask是Future接口的一个唯一实现类。</p>
<p>FutureTask类实现了RunnableFuture接口，RunnableFuture继承了Runnable接口和Future接口，所以它既可以作为Runnable被线程执行，又可以作为Future得到Callable的返回值。</p>
<p><strong>Future接口的不足：</strong></p>
<p>Future接口可以构建异步应用，但依然有其局限性。它很难直接表述多个Future 结果之间的依赖性。实际开发中，我们经常需要达成以下目的：</p>
<pre><code>* 将两个异步计算合并为一个——这两个异步计算之间相互独立，同时第二个又依赖于第一个的结果。
* 等待 Future 集合中的所有任务都完成。
* 仅等待 Future 集合中最快结束的任务完成（有可能因为它们试图通过不同的方式计算同一个值），并返回它的结果。
* 通过编程方式完成一个 Future 任务的执行（即以手工设定异步操作结果的方式）。
* 应对 Future 的完成事件（即当 Future 的完成事件发生时会收到通知，并能使用 Future计算的结果进行下一步的操作，不只是简单地阻塞等待操作的结果）
</code></pre><p>在CompletableFuture中，满足了上述的目的。</p>
<blockquote>
<p><a href="https://www.cnblogs.com/dolphin0520/p/3949310.html" target="_blank" rel="noopener">https://www.cnblogs.com/dolphin0520/p/3949310.html</a></p>
</blockquote>
<h3 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html" target="_blank" rel="noopener">CompletableFuture</a></h3><p>通过静态方法产生CompletableFuture实例。CompletableFuture的底层实现原理：</p>
<table>
<thead>
<tr>
<th style="text-align:left">静态方法</th>
<th style="text-align:center">内容</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>runAsync(Runnable runnable)</code></td>
<td style="text-align:center">使用ForkJoinPool.commonPool()作为它的线程池执行异步代码。</td>
</tr>
<tr>
<td style="text-align:left"><code>runAsync(Runnable runnable, Executor executor)</code></td>
<td style="text-align:center">使用指定的thread pool执行异步代码。</td>
</tr>
<tr>
<td style="text-align:left"><code>supplyAsync(Supplier&lt;U&gt; supplier)</code></td>
<td style="text-align:center">使用ForkJoinPool.commonPool()作为它的线程池执行异步代码，异步操作有返回值</td>
</tr>
<tr>
<td style="text-align:left"><code>supplyAsync(Supplier&lt;U&gt; supplier, Executor executor)</code></td>
<td style="text-align:center">使用指定的thread pool执行异步代码，异步操作有返回值</td>
</tr>
</tbody>
</table>
<p><strong>示例代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CompletableFuture 在调用runAsync后会立刻执行，定义的Runnable输入参入与.NET中定义的Task.Run(Action a)很相似。</span></span><br><span class="line">CompletableFuture cf = CompletableFuture.runAsync(()=&gt; System.out.println(<span class="string">"Hello"</span>));</span><br><span class="line">CompletableFuture&lt;String&gt; cf2 = CompletableFuture.supplierAsync(()=&gt;<span class="string">"Hello"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// get()方法会阻塞当前线程等待结果，类似于.NET的Task.Result属性。此接口继承于Future的get()方法，运行方式和CompletableFuture的join()一致，与之不相同的是get()会抛出InterruptedException 和ExecutionException异常需要开发者手动处理，而join()抛出的异常则交由exceptionally()中的callback进行处理。</span></span><br><span class="line">        cf.get();</span><br><span class="line">        <span class="comment">// join()方法也会阻塞当前线程，同步执行等待结果，和.NET的Task.wait()方法相似，如果有异常/在等待时被取消，会抛出相应未经过检查的exception，比如CompletionException异常 /CancellationException异常。</span></span><br><span class="line">        System.out.println(cf2.get());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>底层是通过一个线程池接收提交的任务，源码是用一个Executor实例执行lamda表达式，一般默认是运用ForJoinPool线程池中的线程执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Executor ASYNC_POOL = USE_COMMON_POOL ?</span><br><span class="line">        ForkJoinPool.commonPool() : <span class="keyword">new</span> ThreadPerTaskExecutor();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** Fallback if ForkJoinPool.commonPool() cannot support parallelism */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPerTaskExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable r)</span> </span>&#123; <span class="keyword">new</span> Thread(r).start(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:left">实例方法</th>
<th style="text-align:center">内容</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>thenRun(Runnable runnable)</code></td>
<td style="text-align:center">可以传入一个Lamda表达式作为后续处理方法</td>
</tr>
<tr>
<td style="text-align:left"><code>thenAccept(Comsummer&lt;? super T&gt; consummer)</code></td>
<td style="text-align:center">在异步task执行完成后传入一个Action方法来处理输出参数,如果void输出是不需要thenAccept(**),也有async版本</td>
</tr>
<tr>
<td style="text-align:left"><code>thenApply(Function&lt;? super T, ? super E&gt; function)</code></td>
<td style="text-align:center">在异步task执行完成后传入一个Func来处理输出参数，并且得出返回值，也有async版本</td>
</tr>
<tr>
<td style="text-align:left"><code>thenCombine(CompletionStage&lt;? extends U&gt; taskToBeCombined, Function&lt;? super T, ? super U&gt; function)</code></td>
<td style="text-align:center">Task并联，两个都执行完成了再继续fucntion)</td>
</tr>
<tr>
<td style="text-align:left"><code>thenCompose(Function&lt;? extends U&gt; function, CompletionStage&lt;U&gt; cf)</code></td>
<td style="text-align:center">Task串联，本task执行完成后再执行下一步</td>
</tr>
<tr>
<td style="text-align:left"><code>complete(T t)</code></td>
<td style="text-align:center">立刻返回Task的结果，并且返回值是t。当然如果Task已经异步执行完毕，则设置失效</td>
</tr>
<tr>
<td style="text-align:left"><code>completeExceptionally(Throwable x)</code></td>
<td style="text-align:center">立刻返回Task并且抛出对应的Exception。如果Task已经结束，则不变。</td>
</tr>
<tr>
<td style="text-align:left"><code>get()</code></td>
<td style="text-align:center">尝试获取结果，如果没有结束/抛出exception/cancel掉，都会抛出对应的exception.</td>
</tr>
<tr>
<td style="text-align:left"><code>join()</code></td>
<td style="text-align:center">join()方法会阻塞当前线程，同步执行等待结果，和.NET的Task.wait()方法相似，如果有异常/被取消，会抛出相应的exception。</td>
</tr>
<tr>
<td style="text-align:left"><code>handle(BiFunction&lt;? super T, Throwable, ? extends U&gt; fn)</code></td>
<td style="text-align:center">将event handler传入，待到task执行完毕后进行处理/exception handling。也有async版本</td>
</tr>
<tr>
<td style="text-align:left"><code>exceptionally​(Function&lt;Throwable,? extends T&gt; fn)</code></td>
<td style="text-align:center">为异步方法注册exception的callback，当然也可以给该task注册下一步的方法在thenApply(..)中。</td>
</tr>
</tbody>
</table>
<ul>
<li>Lambda表达式</li>
</ul>
<p>在Java里，lamda表达式的实质是函数。Runnable是一种特殊的lamda表达式，也就是.NET 中的Action类型委托实例，()-&gt; { ….; return void;}</p>
<blockquote>
<p><a href="https://www.jianshu.com/p/dff9063e1ab6" target="_blank" rel="noopener">https://www.jianshu.com/p/dff9063e1ab6</a></p>
</blockquote>
<h1 id="题外话-C-异步编程方法"><a href="#题外话-C-异步编程方法" class="headerlink" title="题外话: C#异步编程方法"></a>题外话: C#异步编程方法</h1><p>C#异步编程框架依赖于CLR的实现，更加高效和简单明了，而Java的异步方法依赖线程池实现。</p>
<h1 id="Java-NIO网络编程框架"><a href="#Java-NIO网络编程框架" class="headerlink" title="Java NIO网络编程框架"></a>Java NIO网络编程框架</h1><p>在网络编程领域，节点间式依赖TCP/UDP协议进行通信，Java提供的Socket实现在JDK 1.4以前是阻塞I/O, 也就是说每一个Socket连接，JVM中会分配一个线程阻塞等待连接建立，数据通信，在高并发场景下会发生线程池线程用尽的情况，为了优化网络通信效率，出现了非阻塞/异步I/O的设计方案。</p>
<h2 id="Reactor模式设计思想"><a href="#Reactor模式设计思想" class="headerlink" title="Reactor模式设计思想"></a>Reactor模式设计思想</h2><p>Netty通信框架的设计思想是基于Reactor模式思想，这是一种基于事件驱动的设计思想。能够高效的解决很多程序设计中的线程不必要阻塞问题。Java NIO也是基于Reactor设计思想实现的，在JVM本地方法层面做到了多路复用I/O。</p>
<p><img src="/2020/12/18/Java-NIO/Reactor.png" alt="NettyNIO"></p>
<p>Reactor模式中的五个角色:</p>
<ol>
<li>Handle(句柄或描述符，在Windows下称为句柄，在Linux下称为描述符)：<br> 本质上表示一种资源(比如说文件描述符，或是针对网络编程中的socket描述符)，是由操作系统提供的；该资源用于表示一个个的事件，事件既可以来自于外部，也可以来自于内部；外部事件比如说客户端的连接请求，客户端发送过来的数据等；内部事件比如说操作系统产生的定时事件等。它本质上就是一个文件描述符，Handle是事件产生的发源地。</li>
<li>Synchronous Event Demultiplexer(同步事件分离器)：<br> 它本身是一个系统调用，用于等待事件的发生(事件可能是一个，也可能是多个)。调用方在调用它的时候会被阻塞，一直阻塞到同步事件分离器上有事件产生为止。对于Linux来说，同步事件分离器指的就是常用的I/O多路复用机制，比如说select、poll、epoll等。在Java NIO领域中，同步事件分离器对应的组件就是Selector；对应的阻塞方法就是select方法。</li>
<li>Event Handler(事件处理器)：<br> 本身由多个回调方法构成，这些回调方法构成了与应用相关的对于某个事件的反馈机制。在Java NIO领域中并没有提供事件处理器机制让我们调用或去进行回调，是由我们自己编写代码完成的。Netty相比于Java NIO来说，在事件处理器这个角色上进行了一个升级，它为我们开发者提供了大量的回调方法，供我们在特定事件产生时实现相应的回调方法进行业务逻辑的处理，即，ChannelHandler。ChannelHandler中的方法对应的都是一个个事件的回调。</li>
<li>Concrete Event Handler(具体事件处理器)：<br> 是事件处理器的实现。它本身实现了事件处理器所提供的各种回调方法，从而实现了特定于业务的逻辑。它本质上就是我们所编写的一个个的处理器实现。</li>
<li>Initiation Dispatcher(初始分发器)：<br> 实际上就是Reactor角色。它本身定义了一些规范，这些规范用于控制事件的调度方式，同时又提供了应用进行事件处理器的注册、删除等设施。它本身是整个事件处理器的核心所在，Initiation Dispatcher会通过Synchronous Event Demultiplexer来等待事件的发生。一旦事件发生，Initiation Dispatcher首先会分离出每一个事件，然后调用事件处理器，最后调用相关的回调方法来处理这些事件。Netty中ChannelHandler里的一个个回调方法都是由bossGroup或workGroup中的某个EventLoop来调用的。</li>
</ol>
<h3 id="Reactor线程处理流程理解"><a href="#Reactor线程处理流程理解" class="headerlink" title="Reactor线程处理流程理解:"></a>Reactor线程处理流程理解:</h3><ol>
<li><p>初始化Initiation Dispatcher，然后将若干个Concrete Event Handler注册到Initiation Dispatcher中。当应用向Initiation Dispatcher注册Concrete Event Handler时，会在注册的同时指定感兴趣的事件，即，应用会标识出该事件处理器希望Initiation Dispatcher在某些事件发生时向其发出通知，事件通过Handle来标识，而Concrete Event Handler又持有该Handle。这样，事件 ————&gt; Handle ————&gt; Concrete Event Handler 就关联起来了。</p>
</li>
<li><p>Initiation Dispatcher 会要求每个事件处理器向其传递内部的Handle。该Handle向操作系统标识了事件处理器。</p>
</li>
<li><p>当所有的Concrete Event Handler都注册完毕后，应用会调用handle_events方法来启动Initiation Dispatcher的事件循环。这是，Initiation Dispatcher会将每个注册的Concrete Event Handler的Handle合并起来，并使用Synchronous Event Demultiplexer(同步事件分离器)同步阻塞的等待事件的发生。比如说，TCP协议层会使用select同步事件分离器操作来等待客户端发送的数据到达连接的socket handler上。</p>
</li>
</ol>
<p>比如，在Java中通过Selector的select()方法来实现这个同步阻塞等待事件发生的操作。在Linux操作系统下，select()的实现中:</p>
<ul>
<li><p>会将已经注册到Initiation Dispatcher的事件调用epollCtl(epfd, opcode, fd, events)注册到linux系统中，这里fd表示Handle，events表示我们所感兴趣的Handle的事件；</p>
</li>
<li><p>通过调用epollWait方法同步阻塞的等待已经注册的事件的发生。不同事件源上的事件可能同时发生，一旦有事件被触发了，epollWait方法就会返回；</p>
</li>
<li><p>最后通过发生的事件找到相关联的SelectorKeyImpl对象，并设置其发生的事件为就绪状态，然后将SelectorKeyImpl放入selectedSet中。这样一来我们就可以通过Selector.selectedKeys()方法得到事件就绪的SelectorKeyImpl集合了。</p>
</li>
</ul>
<ol start="4">
<li><p>当与某个事件源对应的Handle变为ready状态时(比如说，TCP socket变为等待读状态时)，Synchronous Event Demultiplexer就会通知Initiation Dispatcher。</p>
</li>
<li><p>Initiation Dispatcher会触发事件处理器的回调方法，从而响应这个处于ready状态的Handle。当事件发生时，Initiation Dispatcher会将被事件源激活的Handle作为『key』来寻找并分发恰当的事件处理器回调方法。</p>
</li>
<li><p>Initiation Dispatcher会回调事件处理器的handle_event(type)回调方法来执行特定于应用的功能(开发者自己所编写的功能)，从而相应这个事件。所发生的事件类型可以作为该方法参数并被该方法内部使用来执行额外的特定于服务的分离与分发。</p>
</li>
</ol>
<h2 id="Netty通信框架之NIO的源码分析"><a href="#Netty通信框架之NIO的源码分析" class="headerlink" title="Netty通信框架之NIO的源码分析"></a>Netty通信框架之NIO的源码分析</h2><h3 id="Netty服务器单线程Reactor处理模型源码分析"><a href="#Netty服务器单线程Reactor处理模型源码分析" class="headerlink" title="Netty服务器单线程Reactor处理模型源码分析"></a>Netty服务器单线程Reactor处理模型源码分析</h3><ol>
<li><p>服务器端的Reactor是一个线程对象（EventLoopGroup），该线程会启动事件循环，并使用Selector来实现IO的多路复用。注册Channel通道（包含Acceptor事件处理器Selector）到Reactor中，Acceptor事件处理器所关注的事件是<em>ACCEPT（IO）事件</em>，这样Reactor会循环监听客户端向服务器端发起的连接请求事件(ACCEPT事件)。</p>
</li>
<li><p>当客户端向服务器端发起一个连接请求，Reactor监听到了该ACCEPT事件的发生并将该ACCEPT事件派发给相应的Acceptor处理器来进行处理。Acceptor处理器通过accept()方法得到与这个客户端对应的连接(SocketChannel)，然后将该连接所关注的<em>READ（IO）事件</em>以及对应的READ事件处理器注册到Reactor中，这样一来Reactor就会监听该连接的READ事件了。或者当你需要向客户端发送数据时，就向Reactor注册该连接的WRITE事件和其处理器。</p>
</li>
<li><p>当Reactor监听到有读或者写事件发生时，将相关的事件派发给对应的处理器（另一个EventLoopGroup工作循环线程组）进行处理。比如，读处理器会通过SocketChannel的read()方法读取数据，此时read()操作可以直接读取到数据，而不会堵塞与等待可读的数据到来。</p>
</li>
<li><p>每当处理完所有就绪的感兴趣的I/O事件后，Reactor线程会再次执行select()阻塞等待新的事件就绪并将其分派给对应处理器进行处理。</p>
</li>
</ol>
<p>注意，Reactor的单线程模式的单线程主要是针对于I/O操作而言，也就是所以的I/O的accept()、read()、write()以及connect()操作都在一个线程上完成的。</p>
<p>但在目前的单线程Reactor模式中，不仅I/O操作在该Reactor线程上，连非I/O的业务操作也在该线程上进行处理了，这可能会大大延迟I/O请求的响应。所以我们应该将非I/O的业务逻辑操作从Reactor线程上卸载，以此来加速Reactor线程对I/O请求的响应。</p>
<h3 id="服务器多线程Reactor处理流程："><a href="#服务器多线程Reactor处理流程：" class="headerlink" title="服务器多线程Reactor处理流程："></a>服务器多线程Reactor处理流程：</h3><p>Reactor线程池中的每一Reactor线程都会有自己的多路复用器Selector、线程和分发的事件循环逻辑。<br>mainReactor可以只有一个，但subReactor一般会有多个。mainReactor线程主要负责接收客户端的连接请求，然后将接收到的SocketChannel传递给subReactor，由subReactor来完成和客户端的通信。</p>
<ol>
<li><p>注册一个Acceptor事件处理器到mainReactor中，Acceptor事件处理器所关注的事件是ACCEPT事件，这样mainReactor会监听客户端向服务器端发起的连接请求事件(ACCEPT事件)。启动mainReactor的事件循环。</p>
</li>
<li><p>客户端向服务器端发起一个连接请求，mainReactor监听到了该ACCEPT事件并将该ACCEPT事件派发给Acceptor处理器来进行处理。Acceptor处理器通过accept()方法得到与这个客户端对应的连接(SocketChannel)，然后将这个SocketChannel传递给subReactor线程池。</p>
</li>
<li><p>subReactor线程池分配一个subReactor线程给这个SocketChannel，即，将SocketChannel关注的READ事件以及对应的READ事件处理器注册到subReactor线程中。当然你也注册WRITE事件以及WRITE事件处理器到subReactor线程中以完成I/O写操作。Reactor线程池中的每一Reactor线程都会有自己的Selector、线程和分发的循环逻辑。</p>
</li>
<li><p>当有I/O事件就绪时，相关的subReactor就将事件派发给响应的处理器处理。注意，这里subReactor线程只负责完成I/O的read()操作，在读取到数据后将非I/O事件——业务逻辑的处理放入到EventExecutorGroup工作线程池的EventExecutor中完成，若完成业务逻辑后需要返回数据给客户端，则相关的I/O的write操作还是会被提交回subReactor线程来完成。</p>
</li>
</ol>
<h2 id="扩展知识：Tomcat-同步-阻塞BIO的源码分析"><a href="#扩展知识：Tomcat-同步-阻塞BIO的源码分析" class="headerlink" title="扩展知识：Tomcat 同步/阻塞BIO的源码分析"></a>扩展知识：Tomcat 同步/阻塞BIO的源码分析</h2><h3 id="基于阻塞I-O服务器流程："><a href="#基于阻塞I-O服务器流程：" class="headerlink" title="基于阻塞I/O服务器流程："></a>基于阻塞I/O服务器流程：</h3><ol>
<li><p>服务器端的Server是一个线程，线程中执行一个死循环来阻塞的监听客户端的连接请求和通信。</p>
</li>
<li><p>当客户端向服务器端发送一个连接请求后，服务器端的Server会接受客户端的请求，ServerSocket.accept()从阻塞中返回，得到一个与客户端连接相对于的Socket。</p>
</li>
<li><p>构建一个handler，将Socket传入该handler。创建一个线程并启动该线程，在线程中执行handler，这样与客户端的所有的通信以及数据处理都在该线程中执行。当该客户端和服务器端完成通信关闭连接后，线程就会被销毁。</p>
</li>
<li><p>然后Server继续执行accept()操作等待新的连接请求。</p>
</li>
</ol>
<ul>
<li><p>优点：</p>
<ul>
<li>使用简单，容易编程</li>
<li>在多核系统下，能够充分利用了多核CPU的资源。即，当I/O阻塞系统，但CPU空闲的时候，可以利用多线程使用CPU资源。</li>
</ul>
</li>
<li><p>缺点：该模式的本质问题在于严重依赖线程，但线程Java虚拟机非常宝贵的资源。随着客户端并发访问量的急剧增加，线程数量的不断膨胀将服务器端的性能将急剧下降。</p>
<ul>
<li>线程生命周期的开销非常高。线程的创建与销毁并不是没有代价的。在Linux这样的操作系统中，线程本质上就是一个进程，创建和销毁都是重量级的系统函数。</li>
<li>资源消耗。内存：大量空闲的线程会占用许多内存，给垃圾回收器带来压力。；CPU：如果你已经拥有足够多的线程使所有CPU保持忙碌状态，那么再创建更过的线程反而会降低性能。</li>
<li>稳定性。在可创建线程的数量上存在一个限制。这个限制值将随着平台的不同而不同，并且受多个因素制约：a)JVM的启动参数、b)Threa的构造函数中请求的栈大小、c)底层操作系统对线程的限制 等。如果破坏了这些限制，那么很可能抛出OutOfMemoryError异常。</li>
<li>线程的切换成本是很高的。操作系统发生线程切换的时候，需要保留线程的上下文，然后执行系统调用。如果线程数过高，不仅会带来许多无用的上下文切换，还可能导致执行线程切换的时间甚至会大于线程执行的时间，这时候带来的表现往往是系统负载偏高、CPU sy(系统CPU)使用率特别高，导致系统几乎陷入不可用的状态。</li>
<li>容易造成锯齿状的系统负载。一旦线程数量高但外部网络环境不是很稳定，就很容易造成大量请求的结果同时返回，激活大量阻塞线程从而使系统负载压力过大。</li>
<li>若是长连接的情况下并且客户端与服务器端交互并不频繁的，那么客户端和服务器端的连接会一直保留着，对应的线程也就一直存在在，但因为不频繁的通信，导致大量线程在大量时间内都处于空置状态。</li>
</ul>
</li>
<li><p>适用场景：如果你有少量的连接使用非常高的带宽，一次发送大量的数据，也许典型的IO服务器实现可能非常契合。</p>
</li>
</ul>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>肉肉</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java Questions and Answers</title>
    <url>/2020/12/07/Java-Questions-and-Answers/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">
  <script id="hbeData" type="hbeData" data-hmacdigest="18edda5617cce8ac5470a082198c718ec895c2ef18e690359db5011b93a610bd">6ef9acd99eb5d4fdb18c4065071cc80a6fb6c8fcd3d074d3b8a555a7e89663215ae00f08003c6525ec82e068a601a60cc1f6eed74c1499720073ef92faaed91eec39cf33a62ba7079c9aecd6f8e47df1f36191a5cec091cace659a84756379d5bed27abc8525289566c9035c33ad4c145ef339e8c417a5f8892ef861d22556c359bb0df51f82961bdf9dbacd3ddd76d038895a24758f47ebe8ff939eb48e4b9b6f3a5e08807e5527c9f1d71a9acb5c5df841a2b38dcbf37b7790147a82e6075b8dc1a8eb60e6fad8db6870f1a6af5a50de685b05b7e5f55e4d1ad2b288915ffc5bd25ae324eaedf1c583aa5e4dabf5fd53bb74eb3c2b4c77c749c32f62b1a758c16dd6a44c430d66301f35962518851199117c571f4a97479e058ba650523f6e49f8cfd74e40c3f940d1c6b5a35d3022cd8fd6edd4a96242f54b5b25ea5311f8dce8b977d73360a38c9dc8a48bf7e03bcb0459d763a8f8b5732ecc60803e930dcfa62b845057a757e8f6a418478f207a938d90c9fa11f49c8a296721dfca6fa24ee26d901ab9dd935a77b456f62ba32fc30e5e50af41e2c7f73b3679e498710690156ce75e76a627824213525ff5243f182d0e75c4ea2f892b15ae77d6cd4a2ecd53a0017d01522e0b83840b6c81897eecc73596275597fa3f3594927f934b7ce8413694ba4b6a579cb0b7e242f937d545b6b1af51521587a5c77a0d09760ae990c529039b1d0522e66188720133abd89c2c0d51f5c19b1af7ce56cca711ecfce2a77f947b12d5ba333aa994abb106fc4787b0914ed1c914fd818205895202053d3a974c4b068d24579e95c7b518022d9d2916abbafcae9689266a429697153286f501ee3bc9af5dad21379b03bad7d79a0615ac9a406088232bf0e26543836ebe62925a2ffbdd6e3ce369178fa2b5fbc3d042128c4a5b5a8f3d768c87e01bb270c010ff5b03a08131a724992e9f3378f9af2d50a908dfe02ea12324a3accd3f6abfd1bd32ac3fd8088c33c915b4c750fd7a7e8a39747a72025581a546d3dc2414ce10562248ef29ddc47438459445750db3d588c06feb2177077d0038f4f7c74161e79dce191dcedd68ea83997dcfdf28dcf3fd14905581b7f7e7864640d89c3a6a31a8112f93070170aa45efd8df6b3c55734d096d956114c9f8db5e71486477f6b27a963aa3154b819027fa891645116782feeb4fe8c39afffbd49d2ec4e9c10f17040f419c69ba4e6d6cbed1d6eda67c7060349b5c57a5e3d7b56baa50a7ce2dbd00e563cb6ead8217b1aa1b7018fd63cd856ef53265a2477a2467ebda9e69fd3d6ac312ef7720a91c7a0138511a97d8841622c0e8934177fc7bd3c01cccde00aada67c7a3240d98267082000e2cf7a4b16903d067ca94e10b432f1f1b6818ab19991046dabe4fad35060f5782377c7bc4decdfedf9b3b9a1bf90c6458025aafdc31a1a606b2854932d40fdb1e79c48b68408e5ce0975344c78047e39def280d8cb5c55cd7a46abc561893be5746d4016e333c3168b8eb824d1c81b57c900a7b173f4511b9ac29f2f1be5bb852c39cc9a2ca06d39a5fe3941fe12138cf2e1ed8eaa069c47007b84db5261f35f21e073537aeb74641d76a2c6f048e66bbfefb375b74960a76482e9a3594d13f7463e3d919e7270272bb151ad49e2d716fea009ef0d67a15faba606a275ad8e627190f0cdcc6a5db920e5ae277f931d90e51e54b64beb785923413d4d27df8565256d90c1f8025c0dcecca3b8ea251122eb342ebb99722565531a9022c8127f4f46c7e7488197328f55e891ad688ae26740ba9010aac03ccebda0917817e9c9c950664bb81c0620a9d11bfaf803ad33ba1ce9761c02d07d5a39c1923054548d7d9201c70cc5705b5994382684aa0ea7d65127434f96bfd8e35d065817d18601b5abe87224d6ced416b90a9ef76d5998b64f225fd97d7baabc5ac5203fbe1a8cb2ecec83c807cfd04bd5709acaed6a568e7bc24e3b7e17f53fd59ecc31f6ee6952093b652c8637461493915b5165ca96660bcb7fde7ce0e458fedc585b87444c6751f1cd265cd592004da79defc6b268839d942f9b5fd5315d543b7ac838fff83a7b61ac489387561f5db18f22c96c7400db5eef4d6858f5954590ae822a2706a0c753f06ccfbae437df93b80108ff2d6d5afc300be33f63c563749febd048af8cd4d1e046ba2161bfbb02f50012f29eb8abbd2d0da45e38b45ddbf42f9339d5872eec1c8f414ac1fc0ffcd7864a5a43f4ef6f1f6d84682f62da1abae389bf588c1509534a11739e49a799aa22ba4a2ddefb49afb8709a0504e02993b0b95b028b2599cb99e3922619ab7c923741e0e6954c3463ec8581e9bc2c060f62bd2209a25fbbddeaec62ce8f4027ec241043fb1f8be78a3fb1f98e8d25cefb057949495ffd20ed447ca41b220f8f67e07b9855ce062db1880686fe6d0e7458f936e29c8b2653fd091fb1240f983ef33cce95da14b3a8951bc94bfff7fcfe4d385abc44c2562438bf77ca2dcde06b05cbedf07b4869d78402e32e75b9bb4f65bad8c52831e661f56164dec6dc8f2d51f29e87a1b1ee7811cde02b0136895671ee81649cef855ebdcac62477fe4b90a7e00498b4be38d979d5b7059259372ccde6029a773bb368f17f4a9b9b529f5b006de9f98f62c2e14c676c567b9f2c2fd6978b8181e0acbcc571e85e16fc58580a55583e7d39fbd8548a147cc98ed9cad1d2059d59d76ad87140ed20c7e145bd158e9010e37a620e1aa1cd9429330f91a24d5c990902fa3590376937c6286074f0f472407f0418e75aaf2d8c196b1a69d589b7753e72d16e4b1994b965d3a67ff2831a0f9c1bf1bbf2c81aa3c3312611ccdfa2e68f993fdf2670acdc1e95f2d66475f1ab9914eec361d1b4df699f647c1f86736db77a43604ad948bc0e276a650add5695917b7aaabc075fcdfdb54eca310f09d4f14cc7bee9464aaf421618460b05904f8d338147a6b0c522a98cbc5a21c282cd8be2333cc97a6eb4009c1463e2e8ae0de5483e5e8d933cf4f796e36d19d47d94f4a9c3202ce27b848e02ce4b8f7dea0e4433c57dbd9e0d5eaea5c74c5b94416aaa34a1b8848e990850ab51aacbd6c27d124cda4f1a4d5361a3a4f1651b9d04ab1bfee5c8cfe8ff4d691e23acc28b366c13114a9b4a34a09dc99a538feaa6a536326852ba8de980567c93bdfafc354b20b4158043e0bf6c4c3f37dc44213d0e084127a2435eb79d26eb45f6400b334f0e1401b2966bfefbbfd005d3f0645d18037989398e5fcf08de9e924083c109a4bcbbf5f9073de79a16f5b7f661d3cdc91c3075b66afa0286a05bd3317086a7a13680266e02ebe0ae737b64bdb044190060dc160b3d95b68df811f3e1d7e008a6db4eb1a6503140360395f7e23a3e2fd77ca5fd1563a8e5c68995456e62869c5bba440301f0bcdf8c1aefce4a3f0fece35aca49d172be0a1310f34a7487cc0a477d87e1293b05c5184a4ba1518f1fa7d9740331c9f8747783633fcb18755b4e79d9beaf22d546740511d93923dd25f9edab842075749a74ded57982bb627fe7defef04eb219d9b59756e0bf58827ebc1f40e1083d5a2ade62c9ae270d8db657550c713a4e66c304c37c85e9c0b18b272e249a4332d4eca5991f9148a34d5d0b233f081230361f77e21f4914b8e0c8cbda0faafd0ac6bc0454a568c069c536e5e10a928fd28fb094cf5a9973ba5f277907425208628c8b138b86547a8d19a0a651050ee74355d40cc47be9bd4c2c298e3d526458cc8ed862eb7fbda2c79b7b5f208c49a7ab7316de4e50487406224d8f7417f24e47cad1fcd02b1995521766beab09761b8ec6c3fd08c80dc53bcf962a418c129bd88a888a3bd3f5b0641ccfd22d81b419e2adc1ffb02884cc3cfef591d37fee690b349e6eb6de6ff73c4dbe6669aea8a9c6ba7b9287a5227617c5ab9218e49e50adf6e36cffcd61e269ab406d3f922e502461b51066693382aec4b09a6ab14c4cb89235a73267e4acfc3e9ec4d793762595aa0d9edc2acdb5212d51240ab86c060e395afba923010cb5a0ad32aab20a7a9e44dcbca934186f98217a82c79e732fcb321b612e9c768a8813412003f1624654eea60639e00a51b6527f766aac07e04bf41f3dfc7bed465417cd5682b83666f80b22c4dac2cd381bdc3ff3dcc67bcca5d850ec488a72788d72cb2715836c290a19d300986e1a16dc4b0e61f4839d40082cfacc035e470fea45b795b1d2454f530bbde5ab0e10b462e0d0b34949ccb0d25d9f6b9ed3558565e99ad5a6dc4cbbe280813a706eb112c0afb91451d685fea493a984a115c0ae2f7dfd21d758964f087887b336ed8a23f9fbd04d4c78565746a42733532e8a227dc316abaab6deab27a4fe6b286a5bdfc7a3c5d01eddcaeba72b0bcd64d8548759f73ec875443fc8b0b951b028d17990990a09796796e9c485d80e5b86983c05c90b8c95c4657fbc9ec378bac48e54cf656b9203362cd45bc8862bc7782ecb16cfb8e99106b9b7be9f6e0ca88bc6d2d725eb40888b554628abc2efd0d4d9bbc57c21b0f9bdea9434997e51acbbde4ced935d553bb2acb09870b4153307906be6bd8fffed58a4a8aacf344f37c0bfc67108b8ee97ed1d05aa6971f95024a577f13c90b6ed6fc91b7a0f71cef2ae54c017f17e6d0c6c3281cd9fda8de2686b996a7e56557b00b8541c6350cc1164bd2e2d92fbe1f7a43cf6842bbfe50867af247d2c7923a844249ef33e5382f11949d34799c1a5812ac2185a853348c07aa07089231981f48f2087682f726d1e64b84ccc8b74b78cbbf94c3eda408b310e772d3a000582c731ef92e7661eecaef3dd61fd936b987ae330f8f3e77984b2ea6b4153e95bb23a3776ff7476545de87ec21c1bfa65545742ae1567fca43fedd35521e76f71dd76f6f2f73e9b3433d7e85ff45ace7d0835b390c058a82c177b31a2635daf030173cbcb7a21700150db439cddf6ed31da2a4dab49f12c488b93da061a9548c678ee1f2c6e902a88754a3263c7af04a320563133492e8e9c501dfba4cf4cd7b1f80b6aa0a89fc84e04935f1b40e0669fd3aa20b5c67cbfd5f9c9e5d92d06affde79be98a03c90a059f35253f48e193ca69374a3f9887f6149d722235d4d77960e2289336e2799bf700dd38b0209025a8968dcbebf5c7f43673670bea5fc20cb3e376efd531077e630bc2ff3efb70a2086d233620b9e8c2a11bee170802a6bdbb2a3a2a78cf3b7cee13f30b04f813194bf11e3b1ed34a8ea6d91a441d50f44a465d99bc858703692805c999fa74aba0900efd301d2e7b65bdf103d09c00780625c89f1ec4b1c68bc93b4af553b77bc784057361333d211cd41598fede629b52426a4747bf27283f10d0ea424d2910958e32e52520f97e379e2b03b9a8adf447e2cd2b9b55a72a1d5aa413a7f9729083c5621cc64ca10263f55f1588a883526b1ed5259266b33696095a07728620a8e135ed3f64d37847b72fc6fd8a41c8afa88d2c931e97ae4c18ba79b7e5269df2c022fb6d8375cb1440f3c8d4140c80d9cd6168783fa705ceb95f2b790ac4c0f7faad7a3a2861f136ee3e8c939b747905a14adafbafaf000a1062b43849be67bfd78189f135bfe3175695269a6f0c4e8433ad1db83f65d11e1cc29b54e735354c2c92dcd7e9c8e954cc8082839a25416b4465cc63afe25f196d12b7ea00c2f7536c3f309f51904c65ef164611089622d2e31547ee5eab1c6f579883a82b424dbbcd64aa6906e6c04e18450218100f302b470957391f4d8057f323bc6881643d7d41590e213cffbba27c2baa17ad5db53183213081961ac54294621ea5ae0428c452b630b90993e1d1fc901f46b5d748c46bf3ceefc001d4315dc175de08ba318acf1b887a19a4204278f12384db289549ff5fd602d97aad15ac73a4c42339aaabb9c3fa5faa8bd5edf7073f1e1b0e97a1e17a0ef52382663772837aea4d78473fd76db22bdc51241ab2342ccf5b53f831819588413c822d7a922c9e9c8e012bd441a0bab2ef2a0b814b297951fdd4c7b948d66a87b14e6517a3dd4267d67b90c71ef1d574deb7cb1e3e5c28feafdb65c51d26bf456e611dcab26aa3a90ea9825e10e45a9891f5533b4bb685f188eed2432db259e95086bcbf00993dbce812209bd57f3cdcae5906f8a1e0378b9064b5e296335b1847003a754d3f30f797dcc3e45ff512b7516ad6dc5c64054f3d1771861a71c88fc5dba603f279379eeacd16908c1eb7fc13475725642fd1e11867042b0ae89f743789d07e4a7ab97b83276303e1fb62e2c4476adaaa24ac226c6c1ed5f4c32ab4cf94d3df64c5983bbbbc3c6b8e60fe0cd502c71264cea4815a2cb64d5810f1f8e05e6a3ef78b5bc5eecba6f0ce6d29b0036c2a151c1850114070c964369842495e7ac08e5d510b50e4e10be6bb6228ad377fd0c25c6889b22d4471f1c87ea108e9b9e3f4f612bdb6a158a36cfae0af42f443178dff19f81d27a21fcd8087fd0a670df4ef9d6c4799a13e5ceb9fa1132f1fcdfe7e15525b485153e1793fcc89bf2fb772456ac5de429b51c88b4985ab8daa3621364ea910b60e265ff214f07c9feb08ddd6278246135b0b39890ef01236e99b61709e68e0172e6d29aa3cfaf1ef480e1d1d8e36873e5d7a90188de2999efb794a87078e74838f75d6f042c2e1e064c6e85874d5468b16734bd07b90470f29377ec6cc2dc7cbf3c8d88b1fdb344c2cce38de605c6bf5197403dcb372928f2fd094ffb7500e2942b9770bb12851237a701a10d9dca5723ddd48ab4914e36b249e941f471fdd289a462eddc8d38abc12e15a3c8f153254d322e2ed684d018f44edefaa95796edae13bb2a5d15435b43034921a966027641bfafdc865fb5a5cdb63864668e400cf501bbdd19eac30b4ad432be14011a2321f2ba10f9521c152e92f7342a1f8f7e22fe0ab1c5527cfb1bd6b45bd2a960966bae755f1d81676b0868d84f4f3ef5b8ad440111ac82c612e861dfab1baf6f6f40607bbc061986a808a923153af18244badddbb8250ac9d409fb6ff59411c5ad1a22ab92c75bcac1513b902f532ed20af813906c358425802fed51b8ec162b282516b9db80fef4aaade5a3f740cd4e1ceb7b2f2bb40e745958338196a61f43c175d86ae92d665b9c939fe020a394d933eba88d6a2211c34684b450889d4a430162e6197e19432c8e6b60d3b7e8226c018b3885695a5e7edfcde70c04ac95daa6f34a82bc0085e8a17b9af74adab8b55c8b2e2138771bf6b58d816186761a89e6fcd72b0d93a5544a0c0214423ac47767f66deb10c3a1c755c5f0e6484ca0781304b9aa483b1b65b7792f82f828929f92a8f2a18b5423818cb27c86913db9559f88b082cd42841e28ba6e2ac7be5f9af08de517adc2c93f1056113bee982680ec74935b3798de9874c3048c45e0f592d9dbfd236cb75742b67a3a2214f9e65e416abd5fad1957f6ee85e687e4000ad7c7f638ee1618e4219fd00da776c741f514b4d1a4de9e8bcfdfa27ef75709a20816105a541ccc79cef1ea194df4e4d20387f125bc2ad6090255590daeb0d1295817160d19aabed18a4b9a6230ed14734500d918c3ed6dc99f2cde898d95e122e5cc037e95d339497f55e243472089c64870306cbc2e6c3277f2de927c5ef749476412eaad7f88532cad4ea748559d5816eeb9604fd2f1c6e11ed605b46e8b17d50366e0ec9922399348b996b6c08e8fbfd2c808f5aa85f5e35a1788a5cb7cf3a11957ff60078c4321d5ee641214cfc9baa60a181f5345765c5f44b3fa4001a0a236b079f4e3d64a684990ee54e2d22f37a65fd04ada9c3b2d84e06ab2a2d58cf8406a259c6b47d40b7997c86eee6ac0d4037f185fea9f6c235536e221aba0a098b73a298a88db23ff2b9409497084fd5017df1be3d4124a327ef007179a1a6fa9dd2e2bfbfb5cf5f9c3a9dc943295269dba6a5fb5d6b09220d9b776436fcaddb78eded5d6234f997dc723b5fb40e755d47e0641c062a57ea8bbefb5c625bed16feba653987c7fb0d96785a13e2d7824492967caa2afcf435c46b25ca36003fea0e0dcf4a48cd333d200796f5d2d327c6c69fa6331f00f3fcdb58d0a2382ca6815b1279aba6ca4ee4fd4c88570f96d4dd6a0c863daeedffe9dff3cb8c695cdc4365e8e9b212a90158cf9ee22c6c5c0ddcb4034fb81e42123af809a2f342052943d049458a318df7eb7d41a73aee15b49037bc24ef72f26349c63c7111ec16c8b42aa94a071bf91ea4a3906b207ffd867643daef55fed66f1011007c9a93ea6b6e82df387f0cf0de2416c1625f6a7563a80c56cfaaa655712338d179d9c799d695f68ddfa8a4c0d18bcac27c9bc7c1c3b4aa80d7b1bea93952e2b09760c0cfbb1bacf19f5e81e2ca910788d122edfa323c6b40a0f9511bc3f5097c97f800f72a3c2eb764cb734c242e8b17254ddaccb2037f5aa62bb380c44fcc8643f81aaec1aa30392a244164d040a2369f747132eddc48817e479abb54636bd527646eccc07734b80da0db4179075d58e6c8c081984318fe21e6fdb24866d2774ac1d78f46024d77ae222ba1b1c7c06a44ca75dc6e383126ae099d127e08740e34055e409bd08c6203dbf4891c7108a764ada7bd60a778e978737a27699faf456106d2c9c2440fa9fb43eeaa3f0b079def548661e55e6e98ddad638c7588b6357c4ee3dc2d0bdc08699db636de7133a6ca2c0084f569341bfbb414e77bb471a08c62e7d3ef357c99f311476799a217eb9a7f8c456e1e0c745fb5edd0dd3855d457939947c11cf5e885aa63022c55686e9822d58701ebebd8a0274ff328061f49cf23a7d3ca91b996fc729f9d8f2d1f628f7189ffb0364211b179b38c76167fa569e256bb7ca9094e59be7c59405c2c06941825d90d60a73dbb49aeda8d40c389aae46c78cc34c0422c5944db8d190c840dfe14a69862060cd44f6999c7dd95245499a8c1577e6a85a678017637ee2c3e90a7fa146d1de2ed972ce465870f0f9a10e1735a9d844895d511fe7024a808b4414c503de48369b2a4d50b89179ba1b681672b6eb1f2aafb5cd5bf32db73835352af4a1a821f0c95ebca71391f503da24f22289ee837d43dc6096a6ca529b8d6734049da92905cdec4821a6fae099c4656f86aed94150af9ee5196f2d3ccd6320f5885afd5be85a096037c680e739b07a384070d91e9a37faacfb78c2a93caf281b826d56167493a990f2174ec94e4cdc14f41c1e36efa9b7949d53f552736e5e347eb9f599fbde05d880d69eb5896fa89decb8c28bace5fc24c62cc261b58378296f5fededa949926e77dd049ef55c0371fe685dc09609b1dc664b484828326bb41e9858b877971c8061c175c904114ed6ad769857f75385c26c6ada91234d6d56079b67d0d9c74b6b6050d722a66a72f1db6e57744e84aa4a41b2948514e14d31eae19cb670e0f7b8f96a94970210b5ee9e6bca8ccf78c3066c4ac19ab805e91d783d15129c1fbe9033dc3532fab6f261b634e6be9993aa22b41708aae8cfdaa1698bbbf7aac8113e4ab2472ee0c291f958588909d0e6d95fb91c7ab619e39cfbb7382c9ecf066b5f84db99a1773080179d20d8724d3749abd3e5fefe7007a1ee0a382617ac80be3be1ce2f1300f2c575d2527a83da245d8b60237a32c6dccbf86cd0a6cdcc3416f58c17cd9507e10e29e59f2e762828243c04bba670f8c984eb2e68ad1b84aac46ab0b6f1f4ca4051a19ff89135eb24d0cb39d20a4bb75d79f538f207153862f1a3649225b5b50a4db9cc4d3397f11a2ac3b0d4f7bce258e14968d7f191a261194e22f80690a316fcb9356e956d59daf26fd631c723095ae4b4fe0cbe1310cf20d5d808521090980dda90fe5721ce6c5c8b077c381a8c991a18f5e5b1a60d08bdd656ff06509cbe5a9de4d971f370714c647dfd9d782e277f227bac26d4484e0396e8b57906143b09ec656afcf7ecab8f65c59244ef6d046c9eb5b9fcdfa0df91e54d14d79ff524dc3d643da8e819ecab47b5a6e66dcd03d6deddfa3d07c9b4156e3a449b02a539a4c34bc30def088070797b77fc50b130360b043b686d01f36604bf2e9286b707e996c5dadf8e54b0f6fdc1e275caa47c3ff71aa7bdb392e63163f82b94d1972ecc7edfa024c48742f826c478621c02cb106511a5992e7c98e599a911efbe3d4ec3f3eaf63cc23cbf165b04a0184e017d0319682779f5bbfbac6b9eb84e17790745c41acfcff9c5fc492a9304e0f24093e8d81274217913072bf103a417eb1b4fe27b8f39a107335f3ba0e289210ad0e81b620593c1aa6a01f346f8e3a3f0d47f43a8b3e0ea86d344c0919ca209100e3d5a2600267820f4c4267ebd7813d9cbd469b37fd489a0cfedddf7648c88cefe154bc8c0765a0917dc6c9d3fd8f6dac0def6838eb643390764e97b042a6fb9b5d85a13a609f793040659d63d12925409463bcc5d99d05efc5eae1b4da367f3b7eb264dfc6a8e65708d4d2c5f70e02258c0d24e1fdeb4203f103c5d3d061678f88be62b0ca6806484b94ca2dc087dfced6566ee17bb33ea5cf7e42d8c3e1357af92eb07db70014313d183d1d57da8d28cb2080b2461667b81d0b40a1a224e94304718b1659fad71d1a01be18b6cca6849b33a7123391342ebbb46fa2b40e72a9fe0c09648d30368d0dd77a7a9cd3fc8f79e46152cdb21a4bb8edf6b2a58fe773039985f69fdb9d1cd98981cc4af7a43d93c7c69c17d3366b0b63b5d472cf6988ebbc9afcc93c31d6d808b6d637a422e18801ea1b6db617e50af51879dafbb9b87b1e6d2179191c00abb035d03077f1387b96cb7730a7c9cfd1e6287de846787cd78c5fd281caaf6f8702c374e55241f23b9b5a7b14e14900c6e3c212e3f9ab3feeb78b0e0b7589f86dcd0cd3da90be037dd0c0c1638bfd3e2fb3c817c98c98173357c472e5d7188a0f894087160b15ea9532d54cf97cc80a5819a3f17ef93cbeac97b5f8328c8b3eeffa0243821bdc3789d62e940d3c533f3cb2558de78399e6a33c1123c6af810b74422fc1672efb1fcbac80aeeefc092a6b50bd9eba6804cf133018b6b41de5192504d390667b1b47218a2b1452afdaa1f8bb2f4b5f9f18b01ae3652debf89b2dfadc6e382598d0756d6beb378fa4355b62a9492006525e0ad4ad256ffe1aff03971227e41391c0ba954cdabfbcb57486e35832a9f462786343e56303ed7e6b998f7656a0c7cd70db98f0d321816e7457c572a7f092b3015acbfeeed255eaadebd1af2b51f05622b3ba56a3d98c6ae4613450904496a9fa494b419acee881d3fabb1e07177ab95964bd19aecbe48e50204580eb8b85ab540a74406e1e0590694d64369b0a35e886345b4e0fb974262fe2c0f002da162ca4cf2c98bb986f6f380a09982ed55d92e593440e66c20dec32ede5ff85db1af92293f65a73451d5e9d9a56bf078d3b9560527a9db34bf0171f09f56ba170b746443dfcfa7ff35a0ced232c93a50d7290f944742f586018ac13e6209c44d570362bf2c2295ea1a5ade66abc4978dcd32a4d5722bdd95e676f472fafba3ed682296ca8484900f5485717cfa69fe30f966f53acc1683e5fb5da1cfac482e917a8f900c2c02779037b6497d2226000e68119a287f3cfc9621c12007cded8f093923bc4ef1afcd87f0875309e81cd7fe63e192a55b2b94448292c7a4b6c15e93cc5643365a8311dd2c86a094eabfec47c8d2a3dfe47378ed6e851e45c7818fc43e949b3fe35a1e9e51442e700c7caafb56904a298c5cbc42b17e221e2b90a652d727be976618d2c6c1e089b8655df6540bb52aa1614f45a613fd050bc44278d7fe84634434051f926a7b70af0bc99cca071e1bc8a69d4b7a1c203ab8b95cab848b5e10e24e9a9471b8657d3e863bb5777e54a5dd76e64958bd9bf31eee2066d7c7f0ebed4a0b101e193dc20700361ad5c89df26f3caf638d12bcb70b95a9d5d6cb49694ea1c6fb09fe792b961590fc40ff66ec241a3f83c1e2e2f7f66917348088688db3e36cdd62196c4c9c10618b65fa8098b9f108fc39fbc020f4ff7b6ab1deeede28e5406ee8237fa186d309a3342892876d76025d0f420c44df1839a07ad7bbb2faeee604822de7006897e2c37b59a1e2628f0ed10fe64d8fb76db71139f3525aaefb5d2ba6d5d1268b34e9bdc3118420321bb4bf414bcfd773a4db532f55f0d5b38ce4e1b3d3cb726f9a32f7c5af313aed9bf559b64bb233c66865fd315fdfa695593bb5e0e979b7dc800b6da3c9ab1e3a93409b1926a9c59782415bcea685fcf0364577b14b9000c82e6d0ee55d7f66e155dde518c98d7517822e1c982d2aad7590619f75e62539a242b48f420eb9dbe1060951115c8b6194cab3dde199683e5da280c13416b7b3582cf5532afb8f36d4c332285cdfad1ac6e55cff99230240cc143ca700adb8a2557e77df2e70f512c2528f233f7e82d066058012462d825a7da9b89365a4b7eb257b0a781209218bda0b20c61bfca3ec35deaf028a0fc808cbfef352c1da047e66c190b439e4aa5051b25e9787d14649a3c91fc443422e9a5fdabd62ec352004c2ec3e7732efac6e37b81b4cb3a3b233c53fd2d9458bffa5c4b408d7ce8092378129fa649b75f2c30f48cd0aa17634cb06f958eeff3340b67c1d301b39916ba8ba545973d275541ef81fb53bf4cd9b6a9eca6fe4f9aefd1884e70f872370a56ffc59542082e01bc5c79a82284b5d79606542f5b6a26f7848b39a61ec2d21a5c357b8bfe2d97d17b835e0d13fa0f159c506005fb745ad322731e5410821586bfd2eaf0b76c0afa8b710b8481126e8c8cc2ad6d123352fc4299633fbf2868b35c3c9b0e2d85b89bddabb736396bb983fae679b0180225a86bfb06db16e7e3f7651d9b09e255e07042b27c72bb3e1e305d59aaf048285e64d2a60efadf161f81defb49103ba66adfa667be2a06060e8a21dc3d96ee5311af50825a9418162112ee8b6313f943c2af2bfe55733c092946bd263e867268369e76b6089e92d83f11d6b583dc3bed34e01206cec124cbe70fa58b8d4df4da397236f06568a19dc742f6340398a1b919405d219e78280cee5cb43b0aa71f4ceafa72c4f523f1ed8d4821e92bbba42ce9ff76664ed2826310b398d7bf3b68739820b81c00ac53cb1824e93d717b1fc88db1eb05cfdd0d0f1d515e5fc6872764a251485c866e27fa2214ae77f7d41518354e07aa3c14d383ec13764268a6a31943dd501a8413d2bcb0efb84d2a6d185cdb2d0bb464cc31ceebc4212545fe50a1dc76dd5c979aab0547e091699ec5c58160fae5cd0ec3a0957d82a31b27abe2be957845b5cc1c9ce74005ea39f95fe58fab9a59b9667f3cea9e0ad1f7e0f77e2b43b12f5c458aecd0474de0110e7d058cae2798075585e33e1f2c8443ce8caab916500fcf0ef1c61fb63fc91129f7bbbb588242b4a2371bda5bc235c4dabbf110875735fc1a06793ac144d906cce3d93b259e8c11e947166c93dd011ad8d0c4ef0af5fe9f40b7ada616ae8e7fe9fbf86cf285340d8b81644e0744ff355aa92696a6ef1158f2debc1b45de46c302e2b4a625e583b6e45bcee8b125181e334349d4239f894dc6a8e149ed00750f2cf7d1b0b12c6c483abecaea30824e248297c46ebce935c2d4ddec74142d8e958693e1f9fc39b4383d933e976ffc42f22aa0dda47e7af8e6ac4e07d57051595e417f3a4ad7d6cad7623aab20c2b3931f8366ceb4e44942c1145f3660b535403c5dcaaae2ebc5352befba886b6b8409b6e7f3569eddc06edf633a000c5ac0883c70ce8ac48d897b05c31d8e17e1b1ea16ef4bb7761e6249584a53d90553b23ed087a49f32793ed4fc71cea5fdf9669bdd74653ea5d4c63e96457753b87755694d26c7b6fcdcac73040136dd1edaec0ec870e9643be0bea2361ca044305fd7f11e7bb2c80b7da07fd23abcf1a77006ea5cadf1430c1e0554060d3f20d32a22f49a76eda046792b90f5fea63916e9274e67c366b1a2c3426d84bff8de9dfdacdcef09d0acca27b2620425b7ad4e46cee10b5cdfdbccb98c712113f02f77e482ed1f0d0bc2387986a265f93d088b5d6a34f5ce685a89f38dba21c908e03af2c2fcc0b9096c5c1a767ed64dea90bf54c91792ccd472fe02725dbaac184621bf34310a72c59a52ead87c500166cad3f8c15804f7d4df16b8e7277c895622bc1478ba4ad1b69e336d826fd45dcc1632ba04fcf2fd3cc7d07710f7b67207932a8d288f6607c1cea1736e41fdd148fabaee156ed4dced95a7b5402765d8db541541e3034ead7459014debc50e17df7151029c5ca308ca6f7af1e57b6aec8f0ab686bc3458deb687d13555bd7bf6f9bdbb2daf51e83d1181394e78d932d22d26d2096bece5dd104f0d4d99efec33d718003c340d61429bb6d609fa1cb6533cc4198b3919517cac61fd3f51e0b07c02ec852c70b7ae8e2293373bbb67c29e6305fb263eae2ec63ee2ba75e8a97e7825ac7723b4209e6ed9632274b3cb89b7585f04746be040f349a61e07442f09056f572a5bef15f706af434fa1fba2e376b72aa677660c385379b62325aa03a10d496fda490c5af77175bc7e442452749a3c6d55b05e464446aad6498e2789ca288f9493da06bb0539e70d70d221bb90ea1008a6d7dce0f83c9d333d70651b03fdf7d220086dd50679e02b8011186c8cad147c52955d4882c734e82c0a076394ea830e1779208c31f66714f7a8f7a781c1fb4827ef32111a4388f190702d52b7b0d7668edc05d6e158e57ae24c314b45f4b92fa34006e5558fd6f9269a333928896e5e9b83d844dc821018e991f5054d4781dbe4b74572e4b1b161272fd261b49aa201183bf25285735f3aee1694f059da04d1593a8bde217e7dac1a52bad3aa1071bbc601e785290781abfd9ce21981fdfc1faceb0427656d361ed0e9a5b28e89b1e9e939e8790a3f0b0659bf840f94874da76ef0703aca17cd73d1bd0416bf7984fc05a6a8c662b6b153622047f777968279eaf89fbbc093205a1ce4676acd56cd68c3dc0bf67bae258356feeab807d384a732e8cc4f695ad2259e4d1f45490b3a4c7e1d127c7a3befbe249706dd4777f775c3c52c10b7fb21e28d42bbc86640f3a0cec4392a9ab691106bb77d34b1ced28283f885c6413d58c84a6fd9673a73f07260e593688d8930a63f86ed36bf40630bea8cde20b85ec8aca8568273b5b73b2c969e6d48d98f38da005d47a2db538f8d9139136cf34b885635caee3e687e5ff7f05bb08f2ee0b8d8227efef9ba22d2a752835265a4b7328b70e7eebd0ae5afca550846a30c2223d0c713df700c50ec68acb63ab6ff93de4cacdf5822e29766d8af3463de9f0fe0e4eb50682a7db18104373b65a233c882599bbfa39abbf634499f64ea61a444aaab74e88cfd41d88f533006ef000039ed623f814e96cce7c25b95a0f2169947e3a8822f36117faba20dff304c0f9f3c2d9b93ff909b833019d9533c7cdfd2848e7c20a0bda7e61121a0d71171e90a80d6b5efb8121bb623c4a591940667c21871b7398d9ef27b4c53388ddf97a00d7196e985303dcf700a73207f509531f7e1a7a62c79b4c1cbf05b66222c9edb888e11c22a2e7117fcba1fab6fea3e8c75066ff830c8a467282558e160dcf8f546dc3717dacc04ccd625d8ba3c012adc8c0eea9e4a0fe42205efed70f70121959efc7ae676963e2bf3cfcab534558e1944d29125b5a3630711efc1d03a64b893e34fc899e492799ee46b9f8ac042899aec7d525a03cf6e71118844e428a28884c3c8e72e05e48a72bb74a47614d3ad8e7dc4032129827b9b36f8d71fbc6142b25c02150d36d47f6578db40528f0f9677c15ed6f712ea72bd3fbf62300525d46ea9e39eb56fc5f483571b60d671b4c69948d9f927e17761a21a357b45527c5cfe761157fe3fa2229ab3189d07f999c683f9824ccf0a0c6e929760b03b7dbbb46ed4d4ada0fddbc98bcfa78a10b5c4c0290460d7e033f267cab67e328651090f52534598f9b3fa4f3c557218b00cf6b12f006d334214c75e11e285985950e0f21177bbd616ed274fc8b5552fe8953692c25da68c77125039d4d36c9378fbca7ffec2418596ba612f9538c080cd463de099ca21dc598161400cad4d14c9d0e4c0398fb5b167c58f4e31c6dc78cad8354fe0c4efccd8cedce2cdaf1473a7f6505327ae2798712a196b99eb4189bd0bfa0388419ed673f76a502e2f709ba82054f3621968ae8916e1656110564491d36ea8c159128a719bf870975f00d025280fc8175ae3a978a842fc6b2ac28c7859b6c66067d2477a94048a3a2e5da8d179a4a1448adcdd14e292b672298912acee6e2c6764fbbfbbbdc284d6706b6e4d7306b9f8e40c7226fd3fc03311d7ca079fe13477b072980f4b2d41d72a3e64a27d54824410377b89efb4eea4a04df1a06ee02e51cb03966033eba194d5eb5e4e099335ab3a8014583c4cd0ef821b31b9a5164e77ad1f564dd0a6f9e19e4422c158e7d2740c31084172307744c45ef6aa5df98b4f28d88185f678dd9f8fc56dac8b227c3772d22fc8087503222e045ab8a148f8944173b3326a5e3de05c3c7b38ea32e4d7f9ace53f80290f86177900f8ac14bc1f1482918b361fd5d9fd86b1548504083817f82dd54da73256ea8e06f4dac1141b14813a92f1fa4d21fde81b0c7c5370343418a56deafb67f6ca7916d69b88bb26efcf24e1cf9f1c10f7a2602f84a7f42790d2c99e3039b248ceca7f2fabe63ea0d26ce28163273fa71dc37834da815c0211814ee55ccec8720f52a6b13bf29de81a2e56528c22142b23c336e2a768b667ae469a8b63556cd0c5de2cc104d5408109dbe8e2b618222040ef0e63ff60bd7d669bda1720a79f997c11d8d5055ef07cd97c4c49865437dc4441389b285d1a8a962e73325e5d9d3142df242a9e6f8474c4e0695f200258a5fed27fb8731c4689fb8e96542a06446e8a1f1d6205414645b32855ff805490509dc0ee383b9e8e01c03b7f3e843b68f3166e38d6c75aafe55edfbf05775041a33583038d992fb88906d593dff88e5c5450b2b69e7a5ccc68fb191020d4c14aade53833fccef376e4b8c82b7f7fe416e77805bf6763b5d6c239ee725d8424ea8f2a0cc632f17eafd3685d9628c2df8b397ef014b12810f2ce75af4ebbe323a1468d3f9269b4648d44dda90b48313220ff8d0d4e9a186a31d16a3a3efca9746400f9fd065dbeca20bc28af73aeff49c2a6ef544a7f60f233c58bda7cb9dd9e6ac8b7dc795bfeeaf0703da02f1ea0a95ff85ee4f925c9b75985248a68fd641fe0fc0979e180da8f4c73a93677ddce7f5f217baa9e956b15f41a1bb5151b340461374bffb59fd586a454ebd21677bc57ceb7bfdf531a36b56457a912587666990af20ce83404546e741640852647cbb3e5437977e8cc4fad16b06fc2b9e5a1ab3bc26c8a573df8b8938e245e79eb4d96752c8e451769d9a044103b38ef90de9d5f33c9a4397420ab5f1a97ca12bd36bf4bfdbb49340c87c70c519a01f79e78c6da0cd57e204f4004c722418f17fbdc14fdc670d1182b1a95ba276479a59463fca3868becb127141e6d5a7f6dc69db59f99cb22cc2476ad72e2938d1321be8fb92361d59d9c5bd6c59b15c739e2d623d86aed8fc464b36c1c630264e0096356d8ccd1ce74ba61a6085ce907d87239e73292ae585a9f2751261160c0f799b96b560a618920d467b1a265d95f8a735136c141f31bead6807c9c2a372acad9cf09c2982cad181650e82bd64af57b38652b5289d08552c47da06a21a71d713f75da2bbcce5af2b2fda502a5a007aa61325ed81701a8fa174f9bafc175d19d970c8e5247214f8eede414ef1479eb4ead1259e6b9a75f7c16d4b6c79bd530d6c3bf17e176fec7ef29aed312ff804fd066c7910495bd2e9d75d6f5c0d50b89b8f7e2553b46888c4e01123e4eddea413f82544298c32fc180fdcfa32821c6d8f03bd5c380b1aa9ea6e7d1f976c36dbb211f52d5f8eff306d608ca5d9ff92bdcd80702cb8dfb71cda260385a6a6b93492f896af63cb9569d6a40837fd081a4ac9a9af71c7b1634ecbea86d7a7a5dcf1fd46a535582275c817cf71ec8a318969e154b370550524f7c288032b79d170323dbe6a76ce4fc40180c6d3cb828fa65bc1e6c510a4b07fba452be511e313979cc99fa6d50466ee3de833381ff292d51636a412da03c3349be1713dc462587d4a4d77270c9611a3680d7b7ffb71b2a943ab358fbc5f357852f1f5bd981331c1ea3a1c918b1682c5f30ce7c954ea6f975edea8b4afe54a135972d002ad9eb8806ffdf9f4784a10bf84c920bc612d4ef77ffa240b79392d95c87db9c7421218ba78c7b5f73bc425dafbc4881c7630161eaf9637a6c37820862d9a2879865d48c39f4513acbe39b266892a0f521c12099e0096b1f41b3055382ec06c86abf9bd185ff9de6f50a23dfb3a7e5b5b8d186371fb0d6585344c328f64097b4497aaf7bb6e60135b007ffafd3e615e5a0fd68d86f85ddafaa83ac62b48224a66746978da0cdcc7a288f0da3eed819e648a63ffd68ce6a4ebc7e95c4cdbcdd2b409a11bce1c9fef23123d99f901963709afd8b7dbe0a4e5b1797b61d79507e0fc083790516a48e9fde3d4a959ab8d1e1287be9e1d91404661d16b7b764611929783c9b17ec65c0bdc82bb403096b702fedf238b62e3d27b562994085ad5124221fc5068904f78a86a1e0ac4fb90893f34f601fe6cd3d4684d95ff32363dbb944b5dd7f6bf3ad81997e992759e40685b925cef4b9692a94233e5aee62a9b458c266f529a55af0960ae1ab97b85237a230682667672259f8557e8e21572eea981b010e08cc880b49ed79af45be536d24e9af3e232308175eeda21a774b18df30ad2e2817d30a6bdf1659c30d6d216fac2213b0a9a9f6a2f332cedb55fed01b399dc8ea49fa51e4f93a158a9fd53e37cac33c10d3c560a31ebb67f7497d33102efdc054111f7703b948f65b34f81af10c44f9463e2534577861f341d4ad8b9c03d9f7349771cdadbe2af1eedf52f524c8adda64f3de5afc2deb6b1ff305e0af7766c3a977b78a060d54b2a0090edfa1faf8fee9d99e42e46acb00388da109c3b795a1aba0df7a0710619632149d144cbac80dea6510c3bee09cddd2c994d309aba36f90c44857e5715bf25248da4bf5e3784614422240af5637e300ee5e58d98550450fa6da26af4067e6cbbd39b050a29df0cb65be139c0355a23ba3288278dd825c9f25b968cb1443b52aee3c9ebbe06b1a2061911f32a1d6724e65d1027c6c747d7da1f5acbcc4f5b1686724be5062793eae2190fc01377c11cfff94a120615c0627f722469a375f640a8590bb5f7dd7531d07723f8982117f7c715d17034a0924286e64f79fe0585a173bb32cb5ba186af52f9c17cf86e3df5b745cad4005faa8f38ed9dcbd1c8358d3ea7de228de66a60509465cb1f4dfbfc5fa9cf33c45d149090754aeb202512029ec5df0419b3ab9c4d4b5a63453ee7d82ac48be9e40fd505c418c381d10b1c240a84e7f16723bfa832e6857e20562505f242251228bd23033cc6360c75be6b80e11798588a73df86b307d81ce5e21b8496b8afc289f74a2827554327f3cfb6abbce056063aa66e9660b961d31a7633a70e5c434c36bc8976e177c5dc9c95878daec814e1106653f6d11764f014037795266a1fa9b1de26ced0b0fa6a0542a0098a5785f475683538fdbe4c8e758d9749c7367ea23bd6bb0415248958707f33d4ebbc1eecb8926cdf49600b9031a8c88e2e609377db2d25808634f513aa23520de41faaebc967f23829dde08cd8fc36ed6d5f65d3ec0132c2a726c81fe578ba136723406c31e721c1101ea887f3dec3e95aba30293a2cd368e4942de451022fe9d643f950d10275924b4b152ee495f25a69725a35af9c09ba104709ec9f9df13f544e316a3c5b693c158f5da19f270bc68f3032dda923d6faf20788e93c14874bba4135b256495601c22fce497b8e5b43fbfaab3520232a0049762896870f8239236416db07152a3900a69a34c08f7a957a1b0d5ef1c2f72228a8034583df7c5214621ce3d1f05b0afd5eb225d04f5e8eccf3ee7511b9b0014feac3a477eef928e13ccc59bb49089fb527790932a7cc2e874aded3f288c36cda2e25b3d9229dea9f0674f4c42dd56f0b7096a5f2d80d13ed1835bdbf87e0606abeddf9c9df1d0ea3c0003ce1609596961a2bce340a2dff4a854fcc5593ee2f019f1e8c3823729620009a958de8079c1b0d048468f0173a807e69c522b7d18a561a939cf3c5ea7c3564a8d4391b8e76c187eb99d67b2d29d3e955cb9d89f17142804c4d7aed50cb734e3eb77a0ef82b4e1d654df55ff3f823cf117cdedeed7c8c9b0ab38df7b7c528b0d9084651d20cea2ae2bc5aa6e1c96a4e6550941463925a7fb6f9e3dca748eb5e658de258786db925636c2eafbd77ecf1f96b584575b7d7bfacd03c39f4a0b9bf6c430e72743162fb3967f32a6973212ef1fcde070140d8eb6a4ece01232f97b9fd01cdb1642c5f48a2e9e254bf2de8f1d5563a97809a29cf72a22bbd92ccbabc58e1351c8d93a64ec196eb17ed145902568c5236015e2d5516d65f655ac43c258ef036e2094e6a445d0db0b789aaca7cacd91a50ff6bd76123aaba2ed4767123012d8e26b09d2c497cb8080f9376fce00bfbc3d3cf27414570946fc4242fa3599221a721fe2a50e12e69238c984495d672bfad699ac4b0edf93ca83eb5e2bfab55566930d4354de4f36a02bc3423f1e10774b2e26003afece675680eedf75462761dff33c81956740e9a0b4f4fc6ca241460cda12637907f83b184eddd7b7cf4739b74341a9dc0ea7a2b9dc0545bc242555f5d413d2ca83bb799913bca62985275170dbb0e61370b560b79ae04f74330891dc85a97acdc8fea42b4381581fd3d8611b22850e35314d1acf967bff4ddd13610ac7febdb09fcffed802e45b7991d6a28673f98806dacf5f55b90060c8f09dfdc2b06d8e272671fc9e004bc859bda30c154410eb6afa75e1459f298d784af4c1f42dcd56dc7dbbbc57c9f319763a56d9fe82e8e36d1d9e9ac1ca2df3b553cf2e3a30b0a5fd84681173815e2e705e1e6fc2fd02046094859cebe55bdb7a2ac5d9e0963caa2cf848dccbf68c5387a70583d0e7fd05abbfde046c62b32455a53f1a0e04f4ca71611ffb6060f76c872a057ae046b9d70f0cd415ef5c9d6ef2737823f5f8510854935d73a1b76ae0182349f64b415f17d22384cc1f565eaa097009fd2da6fef83350e57e7de6553bf81daded4cf28e3a77b63597dee925a34c71632ff44c7ea022e9435e3d0be88e74124f85f179382ef74651650a9fde01a97a1a3e6b705c8dedd6757b3225d6482e85d483a80486ceae508c9b43d838b53f34316933491773b56f311968921bb5e27da886b089af8b7a2971e1373d29a5015a6d180410f08218f266213dc8c4c4b6fd17e06e0b5d4906b01dca813d211383aaaadc19afb0ffb53aefe3e91c81ce5eeb3112c2d8671230800a4137537c949563544a31554a5fc7e55165d01b1a944ad4e2bc817ead6c939a6224fdc343bf69006f85d0080d9eec3ab9b87778649bfc0bf3b43616a536ffe4afeb7a3527c71cf4276a560aaa15282ce35280eb2bde347478f1f5b6766f6bdb5aa0a0f5dad05e46b1e002b5bbbe74b0dee2ff610741b72622a1cdac36b7579afe03dda182d1a17c5718dd95a45c893c461e72eb92be8ccb364052486ae9dc11538f70b51658845025b1bab7e648abe759ef1826e8c4487cd5d771478163283e1e48449ab3be7d65326fdf5891c63c67af8573f9efcdd54babde93b3e579ab2d709e8ca639966577329c77162e6fc5f829d15bc3386ed87fccabda2d105200305959e39e06c7a0b245acb20f3f1262d36fe374a4c928c43ac4a503eaa7d03bc099444d05ed7025d5b30ed4cbacfdb947bd2f4ccb561632bee1d51e849363abea4a41b3e4211d9e11dc4d9d485bb916b64f18c6a6aa7ac8c99e292f8311b3593258bd618a08f6a653c9953f63dcdf2d75a501b44f2a5a0a037a9385fc19008b7c8337245d81489ea4bd1d00a7915f0b91813b5be7095164f650bdefca56417f83e672047bfbcc6934b930645456f8e519d6536718949606bf15902beb16e73457358b916a0db6c545f2580c31faf3982a4045ad67ed3ef00a21d08d0e1a48b8dc017441163f3a21b91832515a59a6879f7bdd464090d182251fe99df74c5663e3fcce4b57e22d760e1f1e3c1b56b4a8f89bbd0e92437de307827eb3057dcd27f8072d0129949cdf138be590764afc937294c7c71a78c114352c6943ed03fb384249f53b781239895430c85c08831086da4b71016275c6fa042b02396a13ee0b996c31ef1395e50219a82020a6fa0fb17e39beeeeb9a93f6f71fe0db08e4afa81c73b257f51e0c372f5b686bf2823cad83e433b6ad105836e65cb46b90771ee0f1866b0fc37652a52c6131b002037f37f52eb89adaed7b3e6077902d3edcca23fca71d112638f292922ebdc6bb752de5486b69f0acc940fcd024015596b7af71fdcd53b1ba86b431c4760435d7603aea57d76565ec5a2fa4a14b3e40fc667502c73a5fb3b5937ca88d79c2198e549bdea3daa8e2f1796ebaf91a9f7bc991b2a21545d3377d30f80aaa01c68d9330fc727f4ac747cb43bed18792afe2b251b46193707c168ef54e32fec65934aa88c65b66c0316c6b3317a80142a37f6ad7312f5a21c377eee7e6666ac826e091b35f0765133c7f77ecad60c12f6f966447f9d971d025c099d0a077eec37916a6f1c67edcf6535d2442a9e981c194d5c035bf4508c5aeced875d48a6670cf73f3d9415a9e2851b0b6fee63196c403ac7e84a442d4d67cc0eb958ea39c0b4e1328bb7fe028cf4c8bb0524fab4b79e917dad6e225b7bf0a32f3016cd69b7139e01e1c7764aa530beabb66ffeab6cc3642981fa3bece5de148d661d6acb4b15311594b28fcc315b8cad6fcae2acab732302ce384265c01843b7fe3f674052bc9c79ec990131055abd560d81c70850510fc8dea45c66e347b81ffbb2aaec541af0d5612020e672e2ff23866d6d738cc562a85ddc8c613e5297de8e49a60cb806dbba371200594c1cc3496f50672e85327dcbbf1b2bc9470a59af365ac0764ae51e63e1548b1e4d9d212f12dc82210352f9e638f2ab3564e7f0b25e90b72c2e1cab1055fffff222c7ee8d29829a8380e23e27b2daf1ba046196937d70dec2dc9cfe770480b367cc239b93071aa8d73aa6138d0220130e55c88c07b566a447bc01aff29df04033be445ee5b3b5ffd37c8ecf465e505cb35b2b1aeadfd274242f3f87bfb7d1ddd68ef3982eefa748fa1a54b1fd206d53c747b536e50ef65a376613b35bc23aac92f9727253778258a95dc47a28d7252e001da763c10cf828226a42ebaa4e1aa848d0a2c25e9b77da4e974933f4ff383ddb31842f1316633f759d0b26b1b77349776be4d2846e472e8021746f3284d2af8fda1cdb5504dc9e699d10d1ee767e652a4fdd4d750bff72e37790ed7fc16130353201534abbdac85f56ea56cf94d63a509c77d892eba838daa79f16204b767e1023ad37816b035c82432d3153975db376dacbbc8086bf83a858dc3c5f0ed6531b889eccb5bfc6d100196010a2ffae269899f96652d11708ad44632c5fa35651f03db185e768bf87dc505b4bc8dd060bea0983ddc1a4b309c98fef7f83317ed52aed7ffa92941dded150b02604ef7ecf9ee4205b07f43fa391f37b6bea84a2f444b959c96ef4686e1a236140ba5d0f8aa311acc08009fe089a4b565d1d8b2aa53521844e29f7e96c81b3db1c232559be27eab1f0a80a43382b10a7ebea8f8903c6dee86ab0c9d55171e15ed439b08cef16eb3999103cbd2f9fdb31a6ae5d4b64bbb7fddabf8df639c1692abe922c5a40621a191a7e1681bfdd0012734afb89508d04189f360df6766d2d0790b5e26df82d7dee9bb7818202811a0e2e85b462956a73b59aad733dd306701a1e686768b62b3d9056fd6efdfc246a4edb294bf01d1f84ff78b7587d4c98aa96be44c651f359cf14ea5316a14c5e43ec9d8614373c4daae6f941c2ad81a06b591a6fa041f6e4236a038635b2a01e6a3ff1a50c916a2335eabcd6d65f711c9105fdfd9b8ac83b0a6a795a12f2ce5cd70c9db065c275d7a038884cc7b2bc93ffdbc2f06d5d89151468cff8ccb0cfccb8644b05663bc966a7d467f285ede84741aec90c006578e7a87a63985b35e33b9c7f7b6e21208e298164ad72d96abb51055fba18eaa921fee2c2637ae1132a70ebc267ad9504de934f19316f6e25e1cb213ccb2a97918838b66b4773c15f230631aba76bcdfe83ea2d95ada932f6e339b48d80df4c19325af385a858e92f86662c28609a29759571060ec3a4845fd6ba36e35ee9294fb458fb46a8ef84647c69b93b6a8221006e33ca5cd1dd66a8dbdc062f783fbe53546a34953039839214e78e9648d00b940e5102894723e25fd5d40bf2cf786ce0c72351a7d15eefc3c30b43884adb2e6bd9260ad62c5ced4b8ba279d7b73bb57d048011872a8a2f64d908a74804ac19ba3263c2bc947e53f51b786e6360b52006af530a3a8ac2825a01f35b58fd79623b4383ca5ac08da04e54e0087034394dfaff4fd5a9c67d76d0d624a30cba9951191da5ef71644ec8bf6d40e64aec57b3523caf327178934951f7545f97629fcc26a87f12127980897ff2d2f38eca9abe7ef9e243ad87c467ed645eac26aec1d425811b1820f64d05146194cd311173898795e41d8ec015787719a1969581ec8df0bee3fcf255b63adb497f8a7bdd0bb1ed3512a75d6bab65f56e449f499babaed4d2e199b6f09d0c9e0b80eaf1c5e54feec1fde1f81b8431881f832782bc8a46eec73471a55f9b5773962c3d267a6c27e4b5cbf1c7fefbce57dd1b3a48aa6631506e779eb71b8ac863cbdb813cc92b4a6f53f9bc49d022c989f883b8be175f15001212975c705825992fd02c1dcf45c39df0663e0b173640520d71948070a97375043ec3b0821a943e19f4e235eb8311602191603a8b6994303f9cbd59ea7f268dd843e148891939913dbd18db7c6b675c05c9ff334bfae143a18c28a3f56d05ab6e4a95eab15d7bc0074674a273a0bf4d9e9ac05a003a0624d2ad4531d28e7ae7835d2097a2afd7e78b8bee62336721ce07946c580a4882c1e4b0eadba5b10dde83366e66ebc4eec5dc1693fcec4781e38d1e98145de8a24eafdf8191e75376673c7901f9a21ce736ff4c2dd8d7ad12efe2ccc474a0aa8592f8244793deaf4bcc46241b720ef3abaf49c41f3e3f482ab1fd96f8ecc12700d2a20d7858ed450123bc929fac36ed7346fdbebdc9d049b493cddbe611bf313f0e84530490df476f49681a1197a6c6221b98761187d3e7c652dcf747640997d8143ff86b92f8d6f40849a9d35f7e9ba61981eae0ef07ae7d32827d9e6f0bc284affc6742e51648170771e0dd0293f580951ef32f724f73d7de7c7e7c3204e9a55fb2042ec6977e50e6e5ccfd0c392e8c6578edc2518de683a780e1a0b8e617c1fa607f54460c584bc662886f0a40371a16357a2fbf998a6e3a2ddc1189416e8b5bd3f97ffdb3dfa3ad81027ecf0957a8b31f703ce17adf58595fa29995ffdd5d60521050fdb3251fa9aa097d01bc1b8be897918aace7e464ea696f1d1f89e093a1d4cd088cbe2b1eaed8014d53dd35e750a56fbcbb0392c963c487656dcd2c9ab384b21bf8bb1ba0cc76080c3e21ef2fb27722166a26d66e0aa7f283fcc74b86efaec81cb8896b3b2c1005b68a827053d4fe7478469e6649ea3396e9ac13d3e7a37f0cfcbf226f0764247c014da29229ade552de9591d9d44a7fc91e99c2972ad00d35f77ea736af24777f8e2d73301fd729b803293d36f18e5ac748684e97b550d7885099bb6f401861ab4dc233ab62afe67c6347a477cfdaa314c114878c55cefd7133ed7b459c89cc3c2aa55c370551a1c4d1b9ad428051043cfc08523b7a11c7c095766a8676a2e175bb06505f5e9d776765dd529757174e41d059b9c2757defa59f07f327bb6c1665eca16f1a7f61ad4e2ef356d7d8515780f3f12beb4e342f8c9e7bb817b12ed4470e14cbf23eab139f430dee4721c43caaed37ee604981faa157d614659e7279461523a3c69eab69677cb24cf936643ea72372cff68ec24bbee2bf7f900a239bc0b00a8928ebacc3af5e174db96df6b1e9f3dc161c2ef7b4faa570b21bf43cb2e557d0808b6536ab7088fdb10875a5ee1cdfd625ffcc4c98c0e534d22c4e2f3c283fa7545e71daf04410ad78c263e4d2a28b26cc771d6d788c047a8edf53b71e939bda884ab8440d1d7f72a47526829a0d4e443c6c9c57a25d19a7211bd334f1fe1e520301915b60c6dd49def0f279f1fa24d185385f37092ba649e171b7596b474818527c9a2d5f757f2c4e6870ca7924a9ac226876b372e641d325b6225f62c3c79492be4f0a0ef19f49f15269e123032db424b32405c0a56e39be64b4a697b49d453cbb4e6324ed2268addedf8c2ac233724692e96eaf2b9db01858510d9e5f70cf9b50b8db57c676627c5617658351ea80383c2aac94afda4a812315e20d88e7bc3218bb27cb7e46e87d3b998eebd575d76f82910f82cb8ce119c7f3f4d8def2ecb3a41ddd78562d52e913e250ebb5b6a6e897df19d391bcafd405e8bc736b1eeedfb1f0c03570712211b77f85277116e6ba4c519271b9c7deda6d00cf605f340ed6fee13b3ab2b486d16fb7361866ad25ab3bf0dfdbe1f28bae527f16523126fb65993e6b76c726154b32c7af18896848da1a7c5103db001b3dc2b545970080cdc797f08b8db4a2905e6a428c9ce02e206f1848743aae9f9c96531f71fbc5ced4c73ecd17978f3a1f259c0eb7ec4eea9185b714675a7fa97d23b6ef74bb0e08b647c78b1906a7fdbadaf1841a3561fa21aa0ca6c54246c00992e5d9c61c781499bb4e3e93a203cc5c71a597f0cfd249ec6351c8beb0708d745e8c5afb3e0069abc12329e25308bd256584cc29b2231a52ce0eafaacfd0a92623f2314ddc6c71a65ece0047478d8b1fefc7b96589eb8e35ea6774807c6d5cac527a4c3b10a356c500af7c8ed734e024c39e2346c07d1921ddaabea455301194f2c21d3dec7e241c93d083d76dc194dcabc3782532c285ed68933d0c493cc0508271960bc732f1b67f9664296485700cbbf51b0d09e737043107ec69d11c8a4e524308c7510d561fe2163bcb2d6dd8e9cfdb11667199cbc1331cfe5529f742e9993af6a0140e001ec353dbf548331ada520d9ff16c0ffa80097dc551eebb04f88e679d892cbbdd687de57f2e62012a1fcb331faf547a1d808321ab034de4d021bdab90694505d8311fa584cedba2612209f09b002e52be7556417f8ec96f7a9b199712671753c109d87ea80804ef51256039476b11507080c0d149511202a3ad1c7ba0f1ff856aba7c67764c9161984048a4282e5b010e180dbecc9c8909f61d36e6883d94208a811983603393ebad8315a32387dd395e1996c323598dfa210b71283fc135895ec582fd0551f809ec26912c7c563888a4f22a0c07b02e7c8a985297e7612d301601f40b69e5705de51fc866b59afe87bb0a1a3332de94638c9062e7205051efe665d0738d1debbca345f7d88b90c9b296cf5fbccc5b9aff25d31ce5c0846a72ffdc60acc0f88ae6722875fa9a7e252ccd8f6da2b519d72e830c7ecbfa232656fd8eab32941ad0f69a295dfb4c7107bb66d8c5187541aa74624e9faa60a8a079de4b09545e2061c850f4a3e02ebcc748653e41361a7d954c3f1c0fd5a717d9662582cd8cb4bdb0ede133f75de3f014d7c7de2d28150ca81781281b6b20edbc7afb774a1cdbb633da3ba766f5a0f54933dc1285eab2739ad09008d858432afe134dd0ff306685235568de32c0c2564f26115d857ce68313daf1301e1270f7d2138115a4384c46ed2b6a1639342183c930f0e6466bf5d1f9e115e6d327f30213dbce4d83da2ec4245439530a45096ac49ed5ff39ac9d4fadf2746d5a7008cafbc60ee28fde2dca567fb49413f577eda799b2bb9d923a6b4c636ecd4c16ff4548050ae322061f3607d96d25b23ff1873058d05a3c80bc067f97ac0c6cacfc9af987d8dfc99ecd8f2fb15f748e1673045b48c7717507e2dda5ee426fedc2d780451f62e68b2fc32234954a6c5399391cc02ffd05aa87339a3cee422928f6c8b1c61ddc4fac69b2ec0a31e7da48ba69a1c728e36d89f74371a8dc16323abc7ff81d407827c5694fe979737636bfec3293cb095caa859b497a9994244db0703f5100777f2e0c58d275385b7cf607d26622a0f2be538f65331a3efc6382e7a85d3497f79f3e3f85c3afcc00b15ae33326e68cf79484243f691139e1df0bd5f2bed638fa16492684d160f6f5fdb588519c45dff8c3430530e534fa4cc14c402ee04a2ea0c6ffd46e6a37cee67fe8b7ad9bc486329489bf1bff7fefdc7ca644566641523862e82f3c8babc5cef763fa93ccb2dc48eba63406a512a1e1d5303658596850f23c3fc0c828fb8e5b6adb6db8bfc97be2c8f4e74932eecb5b6b6e7b6ba57b9a5330237a968e4ffad104fe943410c090235675ec6b944f7a911b71562d3e3ca9a8d30810847b9c5a4c870263a846587bb1806eb3d6e6694902279177480bf242dcaa6dd0e2b49cb198ff2badc13947e2bd7affc3e72d557d8f5ff39043b1122b1679b9f5f377c8649e5c31585c26e843a780ada93a386a4790d56cdd4c785249b1bb91a6ceb1152ce8b43eee9f89ef0aac1d13923f6167667cb69e565d99f2915af2cc06e3823fa3c9845ef9036a119351da30333dfa3b32c15578b9bf47223bcb3b8a20ef9eba2f5f81ebf39133cf23136d3dc9c701c7091d75a9bfc056fd58395a6b79736edf6564ffffeab770fc4feeb03a6399ec1a4e3bcf8426367fbaf6bafeaea2f42f1434310e6b548340fe6e0ea5c6b3af3e4c27ae2df9fb17dfb1810c0ebdfbf2fd2ea79211146f534b70ddec3af37d6cb8ac312218f463b4a47853fe8f2d6c8b17008bb0cd2b3f7076e3ffb7487efce67aac036413f344b7b30b3c0dd1320f5a0e4ae07e50f12488e3496ea3cbc1a1faca881f7c29b807919be4256fdb2679b74a5b75eae24d47a16f6729694ce7a24862d6fbbcf106711075e26095b8166fd267f9de95b485e9116fc7d4fb55416931cd3af3718520f553f76f60fc32dd8fb42f11e4e4720e4b74285b4020735b26b1e96f2a8597f7c3943ed0b57095c2593566b52036e09fa8a43bdd2dfb2ab3a29b7cfe68cc54e95328a4612293994f2c2173f3f6cff8933695cd9a4af9766e94ff8c32a8b438cd55b64ffce4122f202fe83126280edc612fa36269d83a5066d4c2f2bd158663ca25039af29c3870cf8ba33af62299703ae2e5a61c121ffdac4b99841cd98efd92c465d60f7602c5c6f42d4a85607541a942047fb2e0b76bb80cf402eaca5f7d776bcd13e9d396b14ee1220b20516c7063035c68eb3e407128205611fc9f9ad2ee1c9797f7f1c430b647d20f27a87fbab8a0959c4a14cdaa24fe04c7c7617f30a259407ad693edf27b0d4b72381a59ec7cd1c809b04e510bed91d2fca8532733afbb108e84dc3533130b8f4201c1ccb974ccccc4ad8c6e2fddfcb9cf2917b93952c32f9eda8296419ad16472dbb76a7b2a184053366661e87594f59d4be9ce7abbb498fdeeb6cb2218c7af001160a20b5abfaa8e403214d696016d1cf1468c237fe0e1c79795cfa38813b4d77966bf0b1bc263bcfcde05f584aed206282d848a5a646de73a0856849aca8fb5cc605941f68e76bcee0cc2dd7505aa6f058d3f9254ab85fef1e39c95df8e71ca1fca3f7a66b9276f5129d29fbc517cf7f3fcf45be0b98f49ad2b4daa19ba437f0b61c4abe396db0bb8e993f5634cad89966ce7af99255a89a23de9a1115eb47b7c861805025b8f38b77b0e0732b50d3006ae5ac702af7d7ebea0a0134d6672a9c2bd940ec7d1fa3ad5ec6e384bce0b504d3966a94d6c71d5dabecf69683560ee977e7eb0a848f111503faaebf282bd9e1091ca5a8f0a3fdd01c294b2f0564eda44ed1d88644c4c9be218581ccba6a007c097ea76b187ed74e779bdc4c4b36291946cd903f9222626aa493e428f2a0d5960d5573122f1ffe0e2dc9a3e0f8be9d19d2beed9f3ce1384b3270b5e3f70617ff5d9fb2a1fa5f980f48da705d76408c858816fed6fdeebf029c9eacd0dc995ce7c90f1be69fad0e0ba8575ebf989be0b653cd5a436b28bc74bb01be628ae7990cc43f649d5b68aaa60ef194e46258fe41ba48b64ace560ad6c0d4d434967c03fceb0e55f7f173d677ec7ac1366d7bfdd87c4a5418c69961fde2ad9aefc12ea8e2af17f12a56bcf6cc4a0845a9410b7731cd73157dabc122640448685bcf17a14ce6755e4dd3a64e9196b11abd8c96bbb433ce4d103141b1e135be58cfe5036425fc7d92d88c19c5b28fec11fee6d341a121e176e0fc41f6939feec21b5e3b761b0ee967df05de2df0967292151fd949a98eba219d17b7aba94653ced1fa394acf89309c99f784f87d00362e0c3817565efc424e004eac9ac32765a0b2d7482014a5ad1e153b5523b9468d0b95dbc135a6ad513a934c1dd3de4e788369fb1e8afd27e2eedcdb0e41d1edbbf8483eaff26235e4fbe107650ff6aa39e09973869058a04e64463e584cc40ab2af003293c3caf74415e481e49538c43c68f42f962e37493b63747066ba6ebad30592e5fbbfdc8119d489d32612a210bd506622887acc9b8f9414685cb6e6a14ca2c764b490a215a813dd1c553d1a092d3227d95271a268227e91f3bf9407effeaeb5407b177d2284fcee62e1d91732c29f3cebe6d4caa8dee74769ac85a643e3e0648e26e157b73dfa8fa5ec59e505d52af3f9e992c2fe4b2c5959af32c9886b9fec5e131422a281a54493779ce089c6aa2fab0c3acbebb3c31a1be4cd914ea5bbae42c7f8d67de051e4bf80ca0d42bed05f7b8e8889727672e99bb7af2e0d1d601efdb540ebed7bbc7a36f0121e41bacc44a05c34c36f505fa0f1bb3327f68b89d08259b333fdbd675492df05bbfcd7859d5e6c6c6fc1f223dca4cc1456be154fef5986eabe5cedc75ccd425613ffc5a9bbf69e037495846890e0e9e6f57392c0f8f5bc6375ecdcef13d5d70ba71bb8b08c781e91448851e9360f994dddc918a97fcaf58b2e60f0ea9347226534209a4936d030365ad19e72493d34325f0b56ab7ca44cf216b9816649a32abfc6f7ce1a949f31742bdecb945022ec53a1c57eb75fb583b1d871c839387a698811c3fd9e7eabe9ae8b1cefc120ebd55587602e9889d16dd945bf380882ad17a24dc2f1a3aac709ed2e075edc8a1fd5c26e1d6551651797c12a4b84ae531a9e4823526e45fec191c5912870b057723491124a462fbb9999648e113fd5a6f311f0f49c706097ae8af4b302a22ccd7cef3bf843517e3511d4291c64222f5ebaf219b9373d147130b4c3059b6ba6301e411f4673f672c6d415746a0dc269c8f4c3ff3c82a35b3c4c7b8a7556659fb309c938cca39b623876a975351b8ffdab9dd79b847ae8163a3ececb5c854b2fed8ef64f3836e99b43dc93e2c0636786817e5bb3e281696d7b275ba750228fa7bc2dfa44d66f9260aa466af875eb57bfa2ce68abe38238162acf255bce9d4482b6d0aee5f52acd47ee8ce8736c1877e17c9f66a092d100ae1ea50469d2b2d0794a8edbfd4e047f433ab6e32b05b24d218e9b3d9f80b2ae7e5a8b7bfb3b2d71a19ceea637fe8b5578626f6ff7c27d3f31b480825f5c1bccd132cd385d9c3ede5db4b40893d3d09b34290718de029a2ac5f0df1f88035750efd397a9548096e0d5b494d4492fabe404c78e4c0c394f3fcb00c6833e3586367cdaad901919d088d5c6387ef51d2cd4d66e869f4e3cfee71e3b1476b231d72bb80746b7e13e610c9c2f00cd1c9cf2288de8c71d8047ce234cf35153b7d1a7f235cf97a8463bc2ad9e148df17b0958b676056ac95a226d44c3ffc457ded421d9b042282d104ecafd583b9bef28dead0bc9cb4994a7d46932b357cd448a40bc9b90c638a8e5609457c255abffda5ea7a455a65b831e47d6fa3d429ad21cd41eff202d8d8716d56ff18ee02b718240b1ceaae67ce893f52b3cd2218524b37ca60e34d7166cb5b3d61a52e726d39f662cd9ab27ad6c7e948261c320f25e9424ca35cc273b9b6339ad913b4d3ca53e48f3e3b9f81b6c109084368de5cc05b83a3f0368ef99fba7354193eef68210760646e501d77c3da5fea49bdf8fc427cd4f44652e3d444a81a706fe07333065c9377322196328be1a640ab68cb7e4067393f19f24916ce99b614cd04f9beefbeeb597086bad8f4c9d4e91fd162bb7f83ea7437e844483e39691671391fbc9b9d6bd8c5146497e2eaf26a5d363df35e73dd49ebf4555997f35601e33b3da63ef10fea9d46dc06e045ed0d217b71801b0285cbc0956a19e67c72b00f61590cc3a528262093f81681d35bae1e53d2b96c9f09cb0de6b862afa8124f3e0f376958c2cf9f000355f13ea2aada49fa4186cb824213f61d76a011c0c0d4415c437cfab5250598c9b7a8c97a7a87b9a5a2db8f2cc621a6e02024e2513a693bea6ccc51b33c6c2744e713234060a8676dc1ef114bdfa09d93b6357244ea1a5a429e427d1ee92e179e3c77b88c77050f9577263eafe507d0520c0fc97549627f4351972adc2759bceff9913db1b5abb1db02c4b7da16e032084629062eea9caf6d27d2e62284827206713fd79c8f0b1cb05aceb183e23e16812c634bfa12d318039ffd8aeff5d99b4e5c905c4012af14800041b32b66044015cfdeb47c76e8e32775623ccbd695deb96fb3167a6cd4b60cd5786025b87cbd22df7d07efa2b8f9dd9599549212ec309d64907f5521221f792757b1d6cb73cdf54ead6f746417fcc24cf50b1fd79b0f0e4d547f8642c75cb471498860491670f9fba0b3a684d19384994670a05d1aa2736685710f2a87a99dbd0005ff10a0afb1bcaacd108d9b63d61ebe7031b40b668d5b5fd679abdf2dec20d008573e0ddbe0d819e7243b6c7569ffb4da099af781db07d7a5ebe37c57dcfc2b1cfceeb5f8237a38dd269d6bacbb68558537b5ebcd3dffc83451f46f5eb2c60c3696c2556a533733c59f99039fb1915c6e3a1e15c9cd2c3ff26993ceb64a2a75ddd4545587dac7e08626f3e5a931297539305a9fc835b3c35523895655b98ba8bc9f420deb658ada651c120cf4859ca74495274f2a2306a486254af084a2466e1a2ccd7b2fea506802ed897e1c9f81e348746cb7a9b4be2cb990fcda44262d1e84252e42e0d9bd21e86adc9ce9183699d103d0b2d6906e46c8887ecf3b72f058c9a4d5fc5b696274fa67a2675adb719c9fa2c3f3e18a1ef517e45119b37c60427cce4599c95f4be64dc7dcb1d6a6c77e319e6b8f3291c2f7b37feae721819ae4dcce0782d16e47db676d09a55824113fc65f5cec96b0d9078a7a4226dee5f49124f238ea1c2b3374899c524c1e37c8f018e320d714e91f4f3bc1fcf0b1c8a5426e50a8e82f02e871ed86c3becc49f81886820d9b2b2012a7a0ff4d6bfd6ce579de45453f0dc330a2224319202e6c5f7faec2c32148adeb3964278f0b385dc4d1111f20646d4aac84194454df4419f55328c3196ee1de9c18c60c73a2f259e4357469702c218c5d4770605bd476124aa0205ec9681f40afeb325dd7f2b96528b54c661a6fcc5890ad69f9931faa6d361cabfed1e98b03f373ae18024ff0202d0d17b22b8d165ceeae737be3db1219e0649cbea947c338c34b4a12110c0125df5fbf6ee51f079da0b19816c482ca857b6e71dbfda931896bf31d7d8a226111633d84db02eb001fb0da9243cef9899aee8d6b2c34fdc99eead0fc2194ed8ac295b7fa13fa0cb5d08dbe54011a0a8b2eef86e734d7407b55f41cccbef4f2b2aa48fe6d50ce61760f88772016f8ca1831d0562ebb572be99c6cfaf9d189dd414d06a36e731e64cc46b481c15f068141d6f706a77a293b81d10842e93c4d892621e782ec5b84c0e53c7111f1057418772aa9c045ffdbf31a62860412310d5845031baaaaf0a35e9c8b7922421396adc4dd74021926d53acebb6eee668a99fbde6b14c749ff7eec38d6088db6dddb756e10b8463501e023dd2e59fa307d4ac6e26c173bdd0c12c8f04e54b0c5b24a6ed8686cbdd2536693436a7fe966c76d990eafff53ef465c7b1134b084bd2c687f25d934776413cc842f1c6597fe026f6ee750bba3d34d9ae48828de5e9042f2741553ffda4396eb702f868cbc93ea1df41328fb456d308b2f1f0d0cdcb0a87d071ed6efdaf8b9a204f9c907804979db1f8e68608a9d8499a64c3b21807c2ab4f905e32831c89f48a325b783cabaeb7afd8d123e9cd76c32c6b36405755212d55b4d125f05321860eca397cb59cd3fc291b2e73e000c4f45c413b3ff8c75fd4a1a2941f12db71ea306897b1ce1a30eed1ad83cef39682ba5e721fed31b9d165a07801031e9677e116d9e58e2887356f1d1e53eceed3e9d6ebdad1df6817ce857056b644cd08fda1fa8852ed93e9f15956ed9d02f1a2e0906eb8f4d8339c334968074138ebb67eb5559c79a132fa5481d2309b05b611cf4d3a5ca10ca9f4f2ee5a449540fbb8d2479ef3dda251e6a847fbd487fb3f73f609de7b7e3c2ad912db29502a9b84328893b5598dbd31463e3c37c8d8961f06c13fdde13da1e8ccb9fcee2ed5851f2bc702ff8a4e5a41f1cf1abfc021fa5fffd5ab22db9ad1e07390e81dc3787c4beb18282b76570fa82a82cd06a4aa8ef17fd4352abb284b5240d7d44011c9a200a8793b91be75d880a2f4ee769f549b7078ac8f1bb090cc52eaf83596ff89cd27f0da3b0bdbbb280fa52b48e6767b18fba70f8b55c3c30c35caf5d2c44e99e6a3823bb584f8dc853cce35fa0ea7578b3037cd458b93c8259f8164143ad7185f0f03f436abac562daf0c95182cb81b89e6035a6fe548181d675c6c445925396f3e3f16e667bce4852483095c1e869c16f0055b85c0e979218e51521747b37e003372cc930442596d344453dd4aeacf93bdc069bcd87dfdaeff143a938e9b691493f9a0f1e9d0c90857479c5749ec898b3480bef545b44d8a5ccdce9ca3aeeb6880d0d6768238b2d4166fef54b23d98651975da34f04e5b471353de9c066f63090c7d6b29878018f6af28f4ac07fee27ae83bbed818cc06c551aa0dff60b07554889aa20c9242cb66eff8e34209411ac79bc7c97b7f24feef978be170539fe1501ad921c3cfd5099b749a6be42d2e00d0238009bdaac871080e581ec47646ab3e8c3090795787c339b08cc8be71becd4504532db1df6e758d9b78729ff92ee16e2baf212e191154a3455549765dcac145776e7505bb16d98772e9c95d665ed5e98ca55548536fae3ad0b66637ad31391861a12db151062660fb8e394de7c929547240458bb0b955591aeb2bc81575d05872ada3165444f06c6000f204ae76e1aeb8c9dc458b17c3ed746c78cee10482fcfc87a0d3f62a657aa743c18e603aac271e5810e9667544686297d5164224cdafbb401422daf0d1ef76a13c5ad9eaf70102fe8d033d2275058847211122c126eb32d0cc9b47a86f728573fb8475bd2defe533d10c45d32c912f9b5e3e06a4a11a205e12c1b16cdd4964a7689d955ed1ae52d30a4e7ad1c2f2a9e4e2cad528da1f14b61cd3b742ab704d820e5b90785680cbeea159d75fb3b9b4462cd8c35e971953c6a415cba7699c8a7da9c01177fbfd56231112cbd6f3d91629a74469b3c46719662b6f32e70ccbda44cb60125ff54b634ab5c9eca1b16fada11ba5c5260013b2db6e59f13a7e44c27907ed52841da5d73cf9e2a80746ff820c344d0506e83fe9cb961c0fb76add3f311b737a172bb4061d2187378de06dea922c54e32bb57e17d7df38b5d27cac9d70f53deac70852f611ad63643655f2ece9593546758fb716046dec2cbb85f8e01f23c47fb7982824207e9051e288ef0a97a4df72a4a53f0ad240afce20e306db1a505f9cf36d0e49e71dc15e9878ec3e5241e5e5ff2b4e305bf7cac316625c7e2e193c65c316189a8687666b5931ec46621a8112d9a6aaac9786555f56017416f48379972ce81c22aff46868bc4a9d9c2424eb6a96ab9ee34ab85ec77a601a8755c332eb8874882564f29418fcc23d71ac5d157838cd0212b172abf7aa9768e0339094908f8ed90b1d1f1a39b9b429096589dc5da1165d3bacd94e131b3f77bd76d6a4ed62fdfd112b2fb2cadd0aa289959dce4e74a97cdda66311ca000c0cd7297cbb99067c10ad724903900dbae47cbe1655b14e3b41003b517af6a19b151fe5432b613396302c4d07096bbd9dff11b3330fe492a7a40515f60d7870158c8849aa056c04ebb94309abc9d9601f756a6c03b5ac2b3b8b795d8e9478fdbdfdb47591a338bfa360eb6f8900cd95e7fd0deb3ec7598696d455e5780c7201e116f3ae435b54a250d34c765cf00b1b14fc478d327330af674bfc3846440fc2307bf88ed49b763eb11007c45c4c9aff77d9cce67532068c31ba39c34aec7cd230a4abf2a336ac2465fb85d66c75f338e7149f741f8d80ffa323dfd37d83c6c1dedc3f6bd0357b17dcd687515a289f8693cdb94f2fa9538b82c63f34b0bdeba2871d922eeebcb40271f2f42d5adb5f469b5f315788860b097940f9befd8b52c5dcc1a5daf652ff2a889b4559302a5cca547a708bc77027fb1dcdb0be4676d6e37d3e4f2f1a25e2834e55a5ce728a7c01c8c01fb24c9b33faca7cfa1e9c4b94a68f30a929c8e9b77fa72af69f388f0af864e7504638082ac0598d05a199275930e155f77e1b8d6c81c711049974060fc5ec1aec169c730c319f5af9d5f5f8504fa88fabe98769c02214fb5a897634263c6f8692711e3632fe539a26756c709dd2160cc889a8e5a43d856ca77c20a410f653920a0343df17d4e9ad1e1d09a0d8f48f1fb40a0c93e61044db0b9e2c692bb8d957e0c563c57826e5e490363dc6ad572af1e1a2fd2cfba893db6aaf05749a771f3c7f1e7cbf39f3cc732e28365157c46d0a07fc815adefdbcd4c56a8ab22fc186b8556f0c9fabc2a76db4ea812711dc936cc41c5f9acfadbb5b9360718a6d4b65f6a9e2a556ffbf92fb8b56da216b2d053d7f85c671aae6c98a9cbfdd88c7da169e2c8c81025c53e1863080a61e342623999c6ee5949d89988f1f8d1944def59d43e0df821</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-xray">
      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">您好, 这是一篇加密文章，请提供密码.</span>
      </label>
      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">
        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>
        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>
      </svg>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>肉肉</tag>
        <tag>职业发展</tag>
      </tags>
  </entry>
  <entry>
    <title>Microservices via Spring Cloud</title>
    <url>/2020/12/07/Microservices-via-Spring-Cloud/</url>
    <content><![CDATA[<p>目前各大科技公司都提供了各种云平台服务，对于普通地金融科技公司而言，从传统的内部维护基础架构的日子一去不复返。策略转向了开发面向多平台，多终端的服务开发，其中前端开发倾向于web，后端开发倾向于自包含而且能灵活大量部署的微服务架构。如何从传统的开发风格转变为适应云平台服务的应用开发成为了一个需要攻坚的课题。</p>
<p>采用微服务架构拥有诸多好处，在本文中将不做赘述，可参见微服务架构一文。目前，微服务架构已经从设计逐渐落地，开发者社区逐渐贡献出云生态的组件框架，能够让这一战略目标变为可执行方案。</p>
<h1 id="Spring-Cloud微服务框架"><a href="#Spring-Cloud微服务框架" class="headerlink" title="Spring Cloud微服务框架"></a>Spring Cloud微服务框架</h1><p>Spring家族拥有多个方向的项目，目前最为领先行业的就是Spring Framework, Spring Boot, Spring Cloud三大方向，分别致力于帮助开发者开发系统，简化应用初始搭建，以及实现微服务开发设计。</p>
<p>Spring Cloud提供了非常完整的一套微服务实施方案：</p>
<ul>
<li>服务发现</li>
<li>分布式配置</li>
<li>客户端负载均衡</li>
<li>服务容错保护</li>
<li>API网关</li>
<li>安全</li>
<li>事件驱动</li>
<li>分布式服务跟踪</li>
</ul>
<p>当然，代码构建微服务只是微服务落地的第一步，为了支持灵活大量部署，微服务需要借助容器技术来快速部署到各个云平台服务提供商的虚拟机上，Docker则是容器技术实现的一个典范，我将在另一篇文章中介绍容器技术。</p>
<h1 id="Spring-Cloud常用组件"><a href="#Spring-Cloud常用组件" class="headerlink" title="Spring Cloud常用组件"></a>Spring Cloud常用组件</h1><h2 id="API网关"><a href="#API网关" class="headerlink" title="API网关"></a>API网关</h2><p>Spring Cloud Gateway和Netflix Zuul为所有微服务提供了一个单一入口点。API网关是一个单独的中间件。</p>
<h2 id="Spring-Cloud-Gateway源码分析"><a href="#Spring-Cloud-Gateway源码分析" class="headerlink" title="Spring Cloud Gateway源码分析"></a>Spring Cloud Gateway源码分析</h2><p>处理流程：</p>
<ul>
<li>基于webflux容器/Netty通信框架：NIO机制，事件循环监听端口请求</li>
<li>请求的Route Predicate函数式过滤匹配规则<ul>
<li>HTTP请求信息检查例如：Host，Query, Path, Header, Cookie</li>
</ul>
</li>
<li>请求过滤器Filter处理和转发接收<ul>
<li>Pre型在请求转发前执行，可以做鉴权，限流等操作</li>
<li>Post型过滤器可以对返回数据进行增强处理</li>
<li>下游服务可以为注册中心的地址/预先配置好的节点IP信息</li>
</ul>
</li>
</ul>
<h3 id="安全——服务验证和授权"><a href="#安全——服务验证和授权" class="headerlink" title="安全——服务验证和授权"></a>安全——服务验证和授权</h3><p>Spring Cloud Securty为微服务提供了一种灵活的用户验证机制，和授权模型。其中验证机制可以基于OAuth2.0标准下的OpenID协议完成，而用户服务授权模型则通过OAuth 2.0的token提供。云服务中的所有服务都应该引入服务验证和授权机制来保护内容服务的安全性。</p>
<p>如果需要更多的security功能，可以考虑引入spring security中的功能。本文将着重介绍基于OAuth2.0的微服务安全架构。</p>
<p>微服务中一般在gateway进行验证授权，而在下游微服务中只需要确认请求是经过认证的即可。关于鉴权的详细文章请见<a href="/2020/11/16/Authentication/">这里</a>.</p>
<h1 id="Spring-Cloud-Netflix"><a href="#Spring-Cloud-Netflix" class="headerlink" title="Spring Cloud Netflix"></a>Spring Cloud Netflix</h1><h2 id="Netflix-Eureka服务注册"><a href="#Netflix-Eureka服务注册" class="headerlink" title="Netflix Eureka服务注册"></a>Netflix Eureka服务注册</h2><p>Eureka是单独的服务组件，保证了A高可用，和P分区容忍性的中间件，与Zookeeper保证的C一致性，P分区容忍性不同，更加适合微服务架构，通过集群保证了高可用的动态服务注册以及心跳感知。Eureka一般和Ribbon放在同一个服务器上，所以在gateway上需要指向lb://abc-service就能保证负载均衡到对应的已注册资源服务中。</p>
<h2 id="Netflix-Ribbon负载均衡"><a href="#Netflix-Ribbon负载均衡" class="headerlink" title="Netflix Ribbon负载均衡"></a>Netflix Ribbon负载均衡</h2><p>Netflix Ribbon 采用拦截器将请求的Url进行负载均衡分发，从而达到内容微服务的负载均衡效果。Ribbon框架并不是单独执行，往往在前端服务中会通过（服务注册中心获取/API网关中写死）得到提供服务的IP地址，所以服务调用方引入Ribbon通过一定的均衡策略动态生成最终访问的IP地址。</p>
<ul>
<li><p>全局使用既定的某种负载均衡策略：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RandomRule <span class="title">randomRule</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RandomRule();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过配置方式灵活配置服务提供者的负载均衡策略</p>
</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 负载均衡策略</span></span><br><span class="line"><span class="comment"># service-provider-name 为调用的服务的名称</span></span><br><span class="line"><span class="attr">service-provider-name:</span></span><br><span class="line"><span class="attr">  ribbon:</span></span><br><span class="line"><span class="attr">    NFLoadBalancerRuleClassName:</span> <span class="string">com.netflix.loadbalancer.RandomRule</span></span><br></pre></td></tr></table></figure>
<h3 id="Ribbon负载均衡策略比较"><a href="#Ribbon负载均衡策略比较" class="headerlink" title="Ribbon负载均衡策略比较"></a>Ribbon负载均衡策略比较</h3><table>
<thead>
<tr>
<th style="text-align:left">策略名</th>
<th style="text-align:left">策略声明</th>
<th style="text-align:left">策略描述</th>
<th style="text-align:left">实现说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">BestAvailableRule</td>
<td style="text-align:left">public class BestAvailableRule extends ClientConfigEnabledRoundRobinRule</td>
<td style="text-align:left">选择一个最小的并发请求的server</td>
<td style="text-align:left">逐个考察Server：<br> 如果Server被tripped了，则忽略，<br>再选择其中ActiveRequestsCount最小的server</td>
</tr>
<tr>
<td style="text-align:left">AvailabilityFilteringRule</td>
<td style="text-align:left">public class AvailabilityFilteringRule extends PredicateBasedRule</td>
<td style="text-align:left">过滤掉那些因为一直连接失败的被标记为circuit tripped的后端server，并过滤掉那些高并发的的后端server（active connections 超过配置的阈值）</td>
<td style="text-align:left">使用一个AvailabilityPredicate来包含过滤server的逻辑, 其实就就是检查status里记录的各个server的运行状态</td>
</tr>
<tr>
<td style="text-align:left">WeightedResponseTimeRule</td>
<td style="text-align:left">public class WeightedResponseTimeRule extends RoundRobinRule</td>
<td style="text-align:left">根据相应时间分配一个weight，相应时间越长，weight越小，被选中的可能性越低。</td>
<td style="text-align:left">一个后台线程定期的从status里面读取评价响应时间，为每个server计算一个weight;<br>Weight的计算也比较简单responsetime 减去每个server自己平均的responsetime是server的权重;<br>当刚开始运行，没有形成statas时，使用roudrobin策略选择server。</td>
</tr>
<tr>
<td style="text-align:left">RetryRule</td>
<td style="text-align:left">public class RetryRule extends AbstractLoadBalancerRule</td>
<td style="text-align:left">对选定的负载均衡策略机上重试机制。</td>
<td style="text-align:left">在一个配置时间段内当选择server不成功，则一直尝试使用subRule的方式选择一个可用的server</td>
</tr>
<tr>
<td style="text-align:left">RoundRobinRule</td>
<td style="text-align:left">public class RoundRobinRule extends AbstractLoadBalancerRule</td>
<td style="text-align:left">roundRobin方式轮询选择server</td>
<td style="text-align:left">轮询index，选择index对应位置的server</td>
</tr>
<tr>
<td style="text-align:left">RandomRule</td>
<td style="text-align:left">public class RandomRule extends AbstractLoadBalancerRule</td>
<td style="text-align:left">随机选择一个server</td>
<td style="text-align:left">在index上随机，选择index对应位置的server</td>
</tr>
<tr>
<td style="text-align:left">ZoneAvoidanceRule</td>
<td style="text-align:left">public class ZoneAvoidanceRule extends PredicateBasedRule</td>
<td style="text-align:left">复合判断server所在区域的性能和server的可用性选择server</td>
<td style="text-align:left">使用ZoneAvoidancePredicate和AvailabilityPredicate来判断是否选择某个server，前一个判断判定一个zone的运行性能是否可用，剔除不可用的zone（的所有server），AvailabilityPredicate用于过滤掉连接数过多的Server。</td>
</tr>
</tbody>
</table>
<h2 id="Netflix-Feign动态代理RPC调用"><a href="#Netflix-Feign动态代理RPC调用" class="headerlink" title="Netflix Feign动态代理RPC调用"></a>Netflix Feign动态代理RPC调用</h2><p>RPC远程调用的一种经典实现，为了让服务调用的代码跟普通方法调用一样方便，可以使用Netflix Feign动态代理被调用的服务接口，并且在底层实际使用HTTPClient进行调用。</p>
<h2 id="Netflix-Hystrix服务弹性保证"><a href="#Netflix-Hystrix服务弹性保证" class="headerlink" title="Netflix Hystrix服务弹性保证"></a>Netflix Hystrix服务弹性保证</h2><p>对于微服务的调用失败需要进行动态的感知，当大量请求失败后需要主动断路避免延迟。而且需要后备方式记录或者进行服务降级。在.NETcore 中对等的实现是steeltoe.</p>
<h3 id="Hystrix熔断机制源码分析"><a href="#Hystrix熔断机制源码分析" class="headerlink" title="Hystrix熔断机制源码分析"></a>Hystrix熔断机制源码分析</h3><p>基于注解@HystrixCommand和AOP实现，在方法执行前拦截的动态代理执行。对于有弹性机制需要的节点，需要引入Hystrix进行失败回退方法编写。</p>
<h4 id="Hystrix手写代码示例"><a href="#Hystrix手写代码示例" class="headerlink" title="Hystrix手写代码示例"></a>Hystrix手写代码示例</h4><ol>
<li>自定义注解 @WuzzHystrixCommand</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> WuzzHystrixCommand &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认超时时间</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">timeout</span><span class="params">()</span> <span class="keyword">default</span> 1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 回退方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">fallback</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>编写切面类，实现简易的逻辑处理</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WuzzHystrixCommandAspect</span> </span>&#123;</span><br><span class="line">    <span class="comment">//线程池的处理，基于这个线程池的处理统计可以达到 THREAD 资源限流</span></span><br><span class="line">    ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注解切点</span></span><br><span class="line">    <span class="meta">@Pointcut</span>(value = <span class="string">"@annotation(com.wuzz.demo.custom.hystrix.WuzzHystrixCommand)"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointCut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//环绕通知</span></span><br><span class="line">    <span class="meta">@Around</span>(value = <span class="string">"pointCut()&amp;&amp;@annotation(hystrixCommand)"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">doPointCut</span><span class="params">(ProceedingJoinPoint joinPoint, WuzzHystrixCommand hystrixCommand)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException, NoSuchMethodException, InvocationTargetException, IllegalAccessException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> timeout = hystrixCommand.timeout();</span><br><span class="line">        <span class="comment">//前置的判断逻辑</span></span><br><span class="line">        Future future = executorService.submit(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> joinPoint.proceed(); <span class="comment">//执行目标方法</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">                throwable.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        Object result;</span><br><span class="line">        <span class="keyword">try</span> &#123;<span class="comment">// 使用 future 来实现超时</span></span><br><span class="line">            result = future.get(timeout, TimeUnit.MILLISECONDS);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException | TimeoutException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            future.cancel(<span class="keyword">true</span>);</span><br><span class="line">            <span class="comment">// ？</span></span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isBlank(hystrixCommand.fallback())) &#123;</span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//调用fallback</span></span><br><span class="line">            result = invokeFallback(joinPoint, hystrixCommand.fallback());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">invokeFallback</span><span class="params">(ProceedingJoinPoint joinPoint, String fallback)</span> <span class="keyword">throws</span> NoSuchMethodException, InvocationTargetException, IllegalAccessException </span>&#123;</span><br><span class="line">        <span class="comment">//获取被代理的方法的参数和Method</span></span><br><span class="line">        MethodSignature signature = (MethodSignature) joinPoint.getSignature();</span><br><span class="line">        Method method = signature.getMethod();</span><br><span class="line">        Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</span><br><span class="line">        <span class="comment">//得到fallback方法</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Method fallbackMethod = joinPoint.getTarget().getClass().getMethod(fallback, parameterTypes);</span><br><span class="line">            fallbackMethod.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            <span class="comment">//完成反射调用</span></span><br><span class="line">            <span class="keyword">return</span> fallbackMethod.invoke(joinPoint.getTarget(), joinPoint.getArgs());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>编写测试，调用：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WuzzHystrixCommand</span>(fallback = <span class="string">"customFallback"</span>, timeout = <span class="number">3000</span>)</span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/custom/hystrix/test"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Map map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">"id"</span>, <span class="number">666</span>);</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(REST_URL_PREFIX + <span class="string">"/hello?id=&#123;id&#125;"</span>, String.class, map);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">customFallback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"custom 请求被降级"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正常得调用是没有问题的，这个时候我们把服务提供方的服务接口里  sleep 3秒来模仿调用超时，在访问接口就会得到降级服务后的返回。</p>
<h1 id="Spring-Cloud-Alibaba"><a href="#Spring-Cloud-Alibaba" class="headerlink" title="Spring Cloud Alibaba"></a>Spring Cloud Alibaba</h1><h2 id="Nacos-配置中心，负载均衡，服务注册"><a href="#Nacos-配置中心，负载均衡，服务注册" class="headerlink" title="Nacos 配置中心，负载均衡，服务注册"></a>Nacos 配置中心，负载均衡，服务注册</h2><h3 id="Nacos服务注册源码分析"><a href="#Nacos服务注册源码分析" class="headerlink" title="Nacos服务注册源码分析"></a>Nacos服务注册源码分析</h3><ul>
<li>Nacos服务注册Naming Service源码分析<pre><code>* 接受Nacos客户端的API调用注册生成Instance实例
    * 将Instance放入serviceMap中ConcurrentHashMap集合中
    * consitencyService.listen实现数据定期检查
* 通过Namespace对已注册服务的隔离
* 定时检查HeartBeat对已注册Instance实例进行检查，更新实例状态
* 对出现异常的服务进行基于UDP协议推送更新于PushService
</code></pre><ul>
<li>Nacos服务方客户端注册源码分析<ul>
<li>Spring Boot自动启动NacosAutoServiceRegistration进行注册调用</li>
<li>监听ApplicationStartedEvent事件调用NacosServiceRegistry.register方法</li>
<li>namingService.regiterInstance中创建BeanInfo，定时发送心跳包：executorService.schedule(task, period, unit)</li>
</ul>
</li>
<li>Nacos前端客户端服务消费者源码分析<ul>
<li>客户端发起订阅请求会定期发起UpdateTask来获得最新地址</li>
<li>客户端也会提供本地EventListener回调实例处理出现异常的服务</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Sentinel-弹性限流-熔断模式"><a href="#Sentinel-弹性限流-熔断模式" class="headerlink" title="Sentinel 弹性限流/熔断模式"></a>Sentinel 弹性限流/熔断模式</h2><h3 id="Sentinel和Hystrix对比"><a href="#Sentinel和Hystrix对比" class="headerlink" title="Sentinel和Hystrix对比"></a>Sentinel和Hystrix对比</h3><p><img src="/2020/12/07/Microservices-via-Spring-Cloud/SentinelHystrix.png" alt="SH"></p>
<h2 id="Seata-分布式事务"><a href="#Seata-分布式事务" class="headerlink" title="Seata 分布式事务"></a>Seata 分布式事务</h2><p>分布式事务解决了分布式系统中存储数据（数据库/缓存)一致性问题。</p>
<h3 id="分布式事务解决理论"><a href="#分布式事务解决理论" class="headerlink" title="分布式事务解决理论"></a>分布式事务解决理论</h3><h4 id="X-Open分布式事务模型"><a href="#X-Open分布式事务模型" class="headerlink" title="X/Open分布式事务模型"></a>X/Open分布式事务模型</h4><ul>
<li>AP: Application 应用程序</li>
<li>RM： Resource Manager 资源管理者，数据库</li>
<li>TM： Transaction Manager事务管理器/协调者</li>
</ul>
<h4 id="两段提交协议"><a href="#两段提交协议" class="headerlink" title="两段提交协议"></a>两段提交协议</h4><ul>
<li>准备阶段： TM同之RM准备事务，并告知准备结果</li>
<li>提交/回滚阶段：如果所有RM返回成功则执行提交完成指令，反之执行回滚指令。</li>
</ul>
<p>存在问题：</p>
<ol>
<li>同步阻塞数据库</li>
<li>容易失败，一个节点失败就回滚</li>
<li>TM单点故障问题，造成RM锁死。</li>
<li>脑裂问题，二阶段部分提交问题。</li>
</ol>
<h4 id="三段提交协议"><a href="#三段提交协议" class="headerlink" title="三段提交协议"></a>三段提交协议</h4><ul>
<li>CanCommit询问阶段: TM询问是否可以参与事务/超时。</li>
<li>PreCommit准备阶段：如果所有RM确认可以，则发起事务，并返回结果/超时。</li>
<li>DoCommit提交/回滚阶段：如果均成功提交则发起提交/回滚指令。</li>
</ul>
<p>改进部分:</p>
<ul>
<li>超时即失败机制，避免两阶段提交锁死等待问题。</li>
<li>提前确认节点状态</li>
</ul>
<h3 id="分布式事务解决方案"><a href="#分布式事务解决方案" class="headerlink" title="分布式事务解决方案"></a>分布式事务解决方案</h3><ul>
<li>基于MQ的消息中间件实现TCC (Try-Confirm-Cancel)模型补偿型方案(幂等性实现，最大努力通知机制)</li>
<li>基于Seata模式的分布式事务框架(AT, TCC, Sega 和XA事务模式)</li>
</ul>
<h3 id="Seata源码分析"><a href="#Seata源码分析" class="headerlink" title="Seata源码分析"></a>Seata源码分析</h3><h2 id="Spring-Cloud-Stream-发布-订阅流处理"><a href="#Spring-Cloud-Stream-发布-订阅流处理" class="headerlink" title="Spring Cloud Stream 发布/订阅流处理"></a>Spring Cloud Stream 发布/订阅流处理</h2><p>Spring Cloud Stream支持消息中间件通信，因而可以支持多种高并发消息发布/消费场景：</p>
<p>Spring Cloud Stream包含如下四个核心部分：</p>
<ul>
<li>Spring Messaging<ul>
<li>Message, 消息对象，包含消息头和消息体</li>
<li>MessageChannel, 消息通道接口，用于接收消息，提供send方法将消息发送至消息通道</li>
<li>MessageHandler, 消息处理器接口，用于处理消息逻辑</li>
</ul>
</li>
<li>Spring Integration<ul>
<li>MessageDispatcher：消息分发接口，用于分发消息和添加删除消息处理器</li>
<li>MessageRouter: 消息路由接口，定义默认的输出消息通道</li>
<li>Filter：消息的过滤注解，用于配置消息过滤表达式</li>
<li>Aggregator: 消息的聚合注解，用于将多个消息聚合成一条</li>
<li>Splitter: 消息的分割，用于将一条消息拆分成多条</li>
</ul>
</li>
<li>Binders 目标绑定器，负责于外部消息中间件系统集成的组件<ul>
<li>doBindProducer: 为中间件绑定发送消息模块，让中间件能从MessageChannel接受到符合中间件格式的消息</li>
<li>doBindConsumer：为中间件绑定接受消息模块，让中间件能够发送符合Spring Message标准的消息到MessageChannel</li>
</ul>
</li>
<li>Bindings 绑定生成的桥梁，支持Kafka，RabbitMQ中间件</li>
</ul>
<h3 id="RocketMQ-分布式消息通信源码分析"><a href="#RocketMQ-分布式消息通信源码分析" class="headerlink" title="RocketMQ 分布式消息通信源码分析"></a>RocketMQ 分布式消息通信源码分析</h3><p>消息发送流程源码分析：</p>
<p><img src="/2020/12/07/Microservices-via-Spring-Cloud/SpringCloudStream.jpg" alt="MQProducer"></p>
<p>除了负责和Spring Cloud服务器中的Messaging集成之外，RocketMQ Binder还负责和MQ中间件集群通信，源码分发布/订阅两部分，分别如下:</p>
<ul>
<li>使用RocketMQTemplate真正发送MQ消息到中间件</li>
<li>同时创建ConsumerEndpoint和input MessageChannel监听MQ订阅消息，并且负责转发给下游</li>
<li>消息的消费分为顺序消费和并发消费，分别由DefaultMessageListenerOrderly,DefaultMessageListenerConcurrently实现，通过binders的配置设定。</li>
</ul>
<p>消息订阅流程源码分析：</p>
<p><img src="/2020/12/07/Microservices-via-Spring-Cloud/SpringCloudStreamConsume.jpg" alt="MQProducer"></p>
<p>其中，服务器对消息的接收，是基于注解方式注入到响应的业务方法中的。这就是在业务代码中，不需要为接收信息创建MessageChannel，却能拿到信息体中的反序列化后信息。</p>
<h3 id="RocketMQ-消息使用场景与实现"><a href="#RocketMQ-消息使用场景与实现" class="headerlink" title="RocketMQ 消息使用场景与实现"></a>RocketMQ 消息使用场景与实现</h3><h4 id="RocketMQ-顺序消息实现"><a href="#RocketMQ-顺序消息实现" class="headerlink" title="RocketMQ 顺序消息实现"></a>RocketMQ 顺序消息实现</h4><p>顺序发送消费场景：订单创建、支付、退款流程处理，数据库BinLog信息消费等等。</p>
<ul>
<li>顺序发送需要将消息发送到同一队列即可，通过基于消息ID的哈希分队选择器即可完成。</li>
<li>顺序消费需要binders中配置好ConsumerMQ的集群消费模式，即每条消息只会被ConsumerGroup中的一个Consumer消费。通过Consumer拿Broker独占锁实现。消费成功后会提交并更新消费进程，避免重复消费。代码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.processQueue.getLockConsume().lock();</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">this</span>.processQueue.isDropped())&#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  status = messageListener.consumeMessage(Collections.unmodifieableList(msgs), context);</span><br><span class="line">&#125;<span class="keyword">catch</span>(Throwable e)&#123;</span><br><span class="line">  hasException - <span class="keyword">true</span>;</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.processQueue.getLockConsume().unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="RocketMQ-普通消息发送实现"><a href="#RocketMQ-普通消息发送实现" class="headerlink" title="RocketMQ 普通消息发送实现"></a>RocketMQ 普通消息发送实现</h4><p>普通消息在队列选择可以由两种机制:</p>
<ul>
<li>轮询机制：轮流使用每个队列发送消息</li>
<li>故障规避机制： </li>
</ul>
<h4 id="RocketMQ-消息并发消费实现"><a href="#RocketMQ-消息并发消费实现" class="headerlink" title="RocketMQ 消息并发消费实现"></a>RocketMQ 消息并发消费实现</h4><p>并发消费场景下，消息队列允许Consumer的线程消费池可以向同一个队列消费信息，并且每个消费线程消费信息会有自己的进度信息。</p>
<h4 id="RocketMQ-分布式事务消息实现"><a href="#RocketMQ-分布式事务消息实现" class="headerlink" title="RocketMQ 分布式事务消息实现"></a>RocketMQ 分布式事务消息实现</h4><p>为分布式事务处理提供了通信基础。</p>
<p><img src="/2020/12/07/Microservices-via-Spring-Cloud/RocketMQ.png" alt="RMQ"></p>
<p>Rocket发送事务消息：</p>
<p>Rocket发送事务消息是二次提交的，第一次发送prepare提交到服务器时消息主题会替换为RMQ_SYS_TRANS_HALF_TOPIC。等到本地事务执行完毕以后才进行二次提交，这时会发送给原本消息的topic。</p>
<ol>
<li><p>由producer发送prepare（半消息）给MQ的broker。MQ会把消息记录到本地，然后回复prepare消息状态给producer。</p>
</li>
<li><p>prepare消息发送以后获取发送状态，如果是成功则执行本地业务（本地事务），根据本地事务执行结果手动返回相应状态（RocketMQLocalTransactionState.COMMIT、RocketMQLocalTransactionState.ROLLBACK等）给MQ。</p>
</li>
<li><p>如果是COMMIT则说明本地事务执行成功，prepare为可提交状态，MQ收到COMMIT消息就会发送给consumer，然后consumer执行本地业务。如果是ROLLBACK则会删除prepare消息。</p>
</li>
<li><p>如果MQ一直没收到返回状态则会启动定时任务检查本地事务状态</p>
</li>
<li><p>消费者、生产者的事务各由开发者自己保证。MQ的事务是由MQ保证，这里会根据使用者配置的参数来决定如何执行。</p>
</li>
</ol>
<h4 id="RocketMQ消费模式"><a href="#RocketMQ消费模式" class="headerlink" title="RocketMQ消费模式"></a>RocketMQ消费模式</h4><ul>
<li>at-most-once最多一次</li>
<li>at-least-once最少一次，RocketMQ通过消费者ACK机制支持至少一次</li>
<li>exactly-only-once仅此一次</li>
</ul>
<h3 id="RocketMQ实现原理"><a href="#RocketMQ实现原理" class="headerlink" title="RocketMQ实现原理"></a>RocketMQ实现原理</h3><h4 id="高性能设计"><a href="#高性能设计" class="headerlink" title="高性能设计"></a>高性能设计</h4><h4 id="高可用设计"><a href="#高可用设计" class="headerlink" title="高可用设计"></a>高可用设计</h4><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>肉肉</tag>
        <tag>Microservice</tag>
      </tags>
  </entry>
  <entry>
    <title>Java Concurrency In Depth</title>
    <url>/2019/12/24/Java-Concurrency-In-Depth/</url>
    <content><![CDATA[<p>本文将从计算机底层实现的角度描述Java目前的并发工具的实现细节。</p>
<h1 id="Synchronized实现细节"><a href="#Synchronized实现细节" class="headerlink" title="Synchronized实现细节"></a>Synchronized实现细节</h1><p>JVM基于进入和退出Monitor对象来实现方法同步和代码块同步。即使用monitorenter和monitorexit指令实现的。</p>
<ul>
<li>monitorenter指令是在编译后插入到同步代码块的开始位置，而monitorexit是插入到方法结束处和异常处。</li>
<li>线程执行到monitorenter指令时会尝试获取对象所对应的monitor的所有权/对象锁。</li>
</ul>
<p>Synchronized用的锁是存在与Java对象头里。Java对象头的结构于<a href="/2018/11/07/JVM-memory-management-and-GC/#对象头">这里</a>。</p>
<p>锁一共有4种状态，级别从低到高分别是：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态。</p>
<p>偏向锁：</p>
<pre><code>1. 设置:当一个线程获取锁，对象锁从无锁状态变成偏向锁，允许该线程反复拿锁。（已经有identity hashcode的对象不会使用偏向锁）

2. 撤销：当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，撤销后变成无锁状态，膨胀成轻量级锁。（偏向对象如果需要identity hashcode则会膨胀成重量级锁）
</code></pre><p>** identity hash code： 未被覆写的 java.lang.Object.hashCode() 或者 java.lang.System.identityHashCode(Object) 所返回的值。</p>
<p>轻量级锁：</p>
<pre><code>1. 设置：JVM在当前线程栈帧中创建用于存储锁纪录的空间，并将对象头的MarkWord复制到锁纪录中。然后尝试用CAS操作将指向锁纪录指针放入MarkWord空间。如果成功，则获得锁，如果失败，则自旋来获取锁。

2. 解锁: CAS操作将Displaced MarkWord
放回到对象头，如果成功，表示没有竞争。如果失败说明存在竞争,即两个线程中解锁线程无法将MarkWord取回，因为另一个自旋线程已经尝试将MarkWord放到自己线程的锁记录中，CAS会发现MW的owner不是自己，膨胀成重量级锁。阻塞所有没拿到锁的线程。
</code></pre><p>重量级锁：</p>
<pre><code>1. 设置：重量级锁会阻塞拿不到锁的所有线程，减少了自旋带来的CPU开销。一旦升级成重量级锁，将不会降级锁。
</code></pre><h1 id="原子操作的实现原理"><a href="#原子操作的实现原理" class="headerlink" title="原子操作的实现原理"></a>原子操作的实现原理</h1><p>原子操作主要依赖的是计算机的如下几个CPU基本操作：</p>
<p><img src="/2019/12/24/Java-Concurrency-In-Depth/AtomicFundamentals.jpg" alt="AtomicFundamentals"></p>
<p>为了达到原子操作的目的，CPU会通过如下两种方式确保在某一时刻，只有一个CPU对共享内存中的数据进行写操作：</p>
<ol>
<li>通过总线锁保证原子性：CPU会提供一个LOCK #信号，将其他处理器的内存访问请求阻塞住，从而独占共享内存。</li>
<li>通过缓存所定保证原子性：需要处理器支持，开销较小，CPU修改缓存行进行缓存锁定，那么另一个CPU就不能同时缓存该内存数据，这是通过处理器的缓存以执行机制来保证的。</li>
</ol>
<p>JVM中是可以通过锁和循环CAS操作来保证该变量的赋值成功的。</p>
<p>其中循环CAS操作可能带来如下问题：</p>
<ol>
<li>ABA问题，值已经变化，但CAS的旧值比较返回true，解决方法是加入变量版本号。</li>
<li>循环时间开销大，可以通过JVM支持CPU的pause指令提升效率。</li>
<li>只能保证单一共享变量的原子性，可以通过AtomicReference方式合并变量成为一个新的对象处理。</li>
</ol>
<p>锁机制，除了偏向锁，锁本身就是通过循环CAS实现拿/释放锁。</p>
<h1 id="Lock锁实现细节"><a href="#Lock锁实现细节" class="headerlink" title="Lock锁实现细节"></a>Lock锁实现细节</h1><p>对比与synchronized中采用的锁，  Lock有如下不同之处:</p>
<p><img src="/2019/12/24/Java-Concurrency-In-Depth/LockSynchronized.png" alt="LockSynchronized"></p>
<p>以下是Lock的API介绍，本文将展示API的实现细节：<br><img src="/2019/12/24/Java-Concurrency-In-Depth/LockAPI.png" alt="LockAPI"></p>
<p>ReentrantLock的实现依赖于Java同步器框架，下面将着重讲解同步器框架的实现。对于公平锁和非公平锁的实现，AQS基本实现都一样，除了在公平锁释放节点是会调用hasQueuedPredecessors()方法判定是否队列中用等待节点，从而保证不会有线程在释放阶段竞争到锁，让线程串行化拿锁。</p>
<h2 id="队列同步器AQS框架实现细节"><a href="#队列同步器AQS框架实现细节" class="headerlink" title="队列同步器AQS框架实现细节"></a>队列同步器AQS框架实现细节</h2><blockquote>
<p><a href="http://www.cnblogs.com/waterystone/p/4920797.html" target="_blank" rel="noopener">http://www.cnblogs.com/waterystone/p/4920797.html</a></p>
</blockquote>
<p>类如其名，抽象的队列式的同步器，AQS定义了一套多线程访问共享资源的同步器框架，许多同步类实现都依赖于它，如常用的ReentrantLock/Semaphore/CountDownLatch。</p>
<p>实现细节在另一篇<a href="Java-Memory-Model/##实现细节">文章</a>已讲述。</p>
<p>同步器本身是一个抽象类，实现了同步器的类可以完成线程同步，包括：同步队列，独占式同步状态获取与释放，共享式同步状态获取与释放及超时获取同步状态。队列同步器使用了一个int成员变量表示同步状态，通过内置的FIFO队列来完成资源获取线程的排队工作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractQueueSynchronizer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标记锁状态， 0是无锁状态，非0则是同步队列有被阻塞节点/线程。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line">    <span class="comment">//同步状态相关方法</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> in <span class="title">getState</span><span class="params">()</span></span>; <span class="comment">// 获取当前的同步状态</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> newState)</span></span>; <span class="comment">//设置当前的同步状态</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span></span>; <span class="comment">//使用CAS设置当前状态，能够保证状态设置的原子性</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//支持重写的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> arg)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusive</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//模板方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquireNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanos)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquireSharedNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanos)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Collection&lt;Thread&gt; <span class="title">getQueuedThreads</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>支持重写方法的不同重写可以实现不同的锁，具体如下：<br><img src="/2019/12/24/Java-Concurrency-In-Depth/AQSoverride.png" alt="AQSoverride"></p>
<p>在实现重写方法可以调用模板方法，具体如下：<br><img src="/2019/12/24/Java-Concurrency-In-Depth/AQStemplate.png" alt="AQStemplate"></p>
<p>下文将分类别讲述模板方法的实现:</p>
<h3 id="同步队列"><a href="#同步队列" class="headerlink" title="同步队列"></a>同步队列</h3><p>同步器内部有一个同步队列（FIFO双向队列）进行同步状态管理。当前线程获取同步状态失败时，同步器会将当前线程及等待状态等信息构造成为一个节点并将其加入同步队列，同时会阻塞当前线程，当同步状态释放时，会把节点中的线程唤醒，使其再次尝试获取同步状态。</p>
<p><img src="/2019/12/24/Java-Concurrency-In-Depth/AQSQueue.png" alt="AQSQueue"></p>
<p>compareAndSetTail(…)方法基于CAS设置尾节点，保证队列更新的线程安全。<br>而头节点的更新是由获得锁的线程更新的，因此不需要作同步处理，是线程安全的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line">    <span class="keyword">private</span> Node prev;</span><br><span class="line">    <span class="keyword">private</span> Node next;</span><br><span class="line">    <span class="keyword">private</span> Node nextWaiter;</span><br><span class="line">    <span class="keyword">private</span> Thread thread;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体描述如下图所示：</p>
<p><img src="/2019/12/24/Java-Concurrency-In-Depth/Node.png" alt="Node"></p>
<ol>
<li>当首节点的线程成功地获取了同步状态/锁，该线程会将首节点设置为后继节点，并且将本节点的next引用断开即可。然后线程执行任务，任务完成后唤醒后继节点。具体的节点处理实现由锁的类型(独占/共享)的模板方法Release/ReleaseShared实现。</li>
</ol>
<p><img src="/2019/12/24/Java-Concurrency-In-Depth/Deque.jpg" alt="Dequeue"></p>
<ol start="2">
<li>当一个线程无法获取到同步状态，会被构造成节点加入到同步队列尾部，CAS设置能保证节点加入过程的线程安全。过程图如图所示。</li>
</ol>
<p><img src="/2019/12/24/Java-Concurrency-In-Depth/Enque.jpg" alt="Enqueue"></p>
<p>节点操作由具体的模板方法AcquireQueued/AcquireShared等实现，而节点封装和入队细节如下列代码所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Node head;</span><br><span class="line">    <span class="keyword">private</span> Node tail;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span></span>&#123;</span><br><span class="line">        Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">        <span class="comment">//快速尝试在尾部添加</span></span><br><span class="line">        Node pred = tail;</span><br><span class="line">        <span class="keyword">if</span>( pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">            node.prev = pred;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(pred, node))&#123;</span><br><span class="line">                pred.next = node;</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        enq(node);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 死循环保证了节点的添加在有并发冲突的情况也能成功</span></span><br><span class="line">        <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">            Node t = tail;</span><br><span class="line">            <span class="keyword">if</span>(t == <span class="keyword">null</span>)&#123;<span class="comment">//Must initialize</span></span><br><span class="line">                <span class="keyword">if</span>(compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                    tail = head;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                node.prev = t;</span><br><span class="line">                <span class="keyword">if</span>(compareAndSetTail(t, node))&#123;</span><br><span class="line">                    t.next = node;</span><br><span class="line">                    <span class="keyword">return</span> t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="独占式同步状态获取与释放"><a href="#独占式同步状态获取与释放" class="headerlink" title="独占式同步状态获取与释放"></a>独占式同步状态获取与释放</h3><p>独占式同步状态，是指在同一时刻只能有一个线程成功获取同步状态，锁的获取是排他的，不是共享的。</p>
<ol>
<li>独占式同步状态获取流程如图所示:<br><img src="/2019/12/24/Java-Concurrency-In-Depth/Acquire.jpg" alt="Acquire"></li>
</ol>
<p>相关的实现代码如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//在同步队列入队完成后，每个节点都在自旋等待，但是只有前驱是头节点的节点(头节点的next节点)才能有终端自旋的可能</span></span><br><span class="line">        <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span>(p == <span class="function">head $$ <span class="title">tryAcquire</span><span class="params">(arg)</span>)</span>&#123;</span><br><span class="line">                <span class="comment">//更新头节点</span></span><br><span class="line">                setHead(node);</span><br><span class="line">                <span class="comment">//断开头节点对后续节点的引用</span></span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">//help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(shouldParkAfterFailedAcquiredAcquire(p, node) &amp;&amp; parkAndCheckInterrupe())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol start="2">
<li>独占式同步状态释放<br>在当前线程获取了同步状态并执行后，需要释放同步状态，从而使得后续的同步节点可以获取同步状态。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tryRelease(arg))&#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span>(h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);<span class="comment">//使用lockSupport去唤醒等待状态的线程。</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="共享式同步状态获取与释放"><a href="#共享式同步状态获取与释放" class="headerlink" title="共享式同步状态获取与释放"></a>共享式同步状态获取与释放</h3><p>共享式获取与独占式获取最主要的区别在与同一时刻能否有多个线程同时获取到同步状态。以文件的读写为例，读操作可以是共享式访问，写操作则是独占式访问。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tryAcquireShared(arg) &lt; <span class="number">0</span>&gt;)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 自旋获取共享锁</span></span><br><span class="line">        <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head)&#123;</span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="comment">//获取到了同步状态</span></span><br><span class="line">                <span class="keyword">if</span>( r &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">if</span>(interrupted)</span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//tryReleaseShared通过自旋和CAS保证释放状态成功</span></span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        <span class="comment">//释放同步状态后，会唤醒处于等待状态的节点。</span></span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="独占式超时获取同步状态"><a href="#独占式超时获取同步状态" class="headerlink" title="独占式超时获取同步状态"></a>独占式超时获取同步状态</h3><p>超时获取同步状态，即在指定的时间段内获取同步状态，如果获取到同步状态则返回true，否则，返回false。具体流程如下: </p>
<p><img src="/2019/12/24/Java-Concurrency-In-Depth/Workflow.jpg" alt="Workflow"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">doAcquireNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">    <span class="keyword">long</span> lastTime = System.nanoTime();</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node,EXCLUSIVE);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">//确定时间内获取成功</span></span><br><span class="line">            <span class="keyword">if</span>(p == head &amp;&amp; tryAcquire(arg))&#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>;</span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//确定时间内获取失败</span></span><br><span class="line">            <span class="keyword">if</span>(nanosTimeout &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(shouldParkAfterFailedAcquire(p, node) &amp;&amp; nanosTimeout &gt; spinForTimeoutThreshold)</span><br><span class="line">                LockSupport.parkNanos(<span class="keyword">this</span> nanosTimeout);</span><br><span class="line">            <span class="keyword">long</span> now = System.nanoTime();</span><br><span class="line">            <span class="comment">// 计算lastTime到现在的睡眠时间，并且更新还应该睡眠的时间</span></span><br><span class="line">            nanosTimeout -= now - lastTime;</span><br><span class="line">            lastTime = now;</span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Condition实现细节"><a href="#Condition实现细节" class="headerlink" title="Condition实现细节"></a>Condition实现细节</h1><p>每个Condition对象都包含一个等待队列，Object包含一个AQS队列，两个队列节点是AQS中的Node，并用这个两个队列共同实现了wait/notify功能。</p>
<h2 id="等待"><a href="#等待" class="headerlink" title="等待"></a>等待</h2><p>Condition.await()让线程释放锁，构造新节点加入等待队列进入等待状态。返回的前提是重新获取了condition相关联的锁。底层是通过LockSupport的park()方法释放。</p>
<h2 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h2><p>Condition.signal()将等待队列中等待时间最长的节点加入同步队列，并用LockSupport.unpark()唤醒该节点。加入同步队列的节点通过tryAcquire()竞争获取锁，获取锁后从await()中返回继续执行。</p>
<h1 id="并发容器实现细节"><a href="#并发容器实现细节" class="headerlink" title="并发容器实现细节"></a>并发容器实现细节</h1><h2 id="ConcurrentHashMap实现细节"><a href="#ConcurrentHashMap实现细节" class="headerlink" title="ConcurrentHashMap实现细节"></a>ConcurrentHashMap实现细节</h2><blockquote>
<p>ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成。Segment是一种可重入锁ReentrantLock，在ConcurrentHashMap里扮演锁的角色，HashEntry则用于存储键值对数据。一个ConcurrentHashMap里包含一个Segment数组，Segment的结构和HashMap类似，是一种数组和链表结构， 一个Segment里包含一个HashEntry数组，每个HashEntry是一个链表结构的元素， 每个Segment守护者一个HashEntry数组里的元素,当对HashEntry数组的数据进行修改时，必须首先获得它对应的Segment锁。</p>
</blockquote>
<p><img src="/2019/12/24/Java-Concurrency-In-Depth/concurrentHashmap.png" alt="ConcurrentHashMap"></p>
<p>读取HashEntry信息是不需要拿锁，从而保证了并发读的高效性。HashMap中读取Map.Entry&lt;K,V&gt;是需要拿锁的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HashEntry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;  </span><br><span class="line">    <span class="keyword">final</span> K key; <span class="comment">// immutable field保证链表稳定性，新节点头插入,或者替换已有的值（不能重复value）。  </span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;  </span><br><span class="line">    <span class="keyword">volatile</span> V value;  <span class="comment">//volatile保证可见性，删除需要O(n)倒序复制被删节点前的list。</span></span><br><span class="line">    <span class="keyword">final</span> HashEntry&lt;K,V&gt; next;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在Hash中，会进行分段哈希从而保证segment中数组的均匀性，会对hash值的高字段和低字段进行分段处理，前半段获取segment位置，后端确定segment中数组中未知。</p>
<ul>
<li>get()操作不需要枷锁，除非读到的值为空才会加锁重读。</li>
<li>put()操作需要对加锁操作。扩容时，只会对某segment中的数组进行扩种。</li>
<li>size()操作会两次不加锁计算，当操作数没有变化，则直接返回，如果变化则加锁获取size。</li>
</ul>
<h2 id="阻塞队列实现原理"><a href="#阻塞队列实现原理" class="headerlink" title="阻塞队列实现原理"></a>阻塞队列实现原理</h2><h1 id="线程池并行执行机制Executor"><a href="#线程池并行执行机制Executor" class="headerlink" title="线程池并行执行机制Executor"></a>线程池并行执行机制Executor</h1><p>Java线程即是工作单元，也是执行机制。工作单元包括Runnable和Callable，而执行机制由Executor框架提供。应用程序通过Executor框架控制上层的调度，下层的调度由操作系统内核控制，下层调度不受应用程序的控制。<br><img src="/2019/12/24/Java-Concurrency-In-Depth/ExecutorMechanism.jpg" alt="Executor"></p>
<p>Executor接收<code>Runnable/Callable&lt;T&gt;</code>接口的实例的任务，返回<code>Future&lt;T&gt;</code>接口的<code>FutureTask&lt;T&gt;</code>实例，当任务完成时，可以获取任务执行结果。</p>
<h2 id="ThreadPoolExecutor-线程池-框架和实现原理"><a href="#ThreadPoolExecutor-线程池-框架和实现原理" class="headerlink" title="ThreadPoolExecutor (线程池)框架和实现原理"></a>ThreadPoolExecutor (线程池)框架和实现原理</h2><p>ThreadPoolExecutor可以有三种: FixedThreadPool, SingleThreadExecutor, CachedThreadPool。这三种是不同配置的ThreadPoolExecutor，并非不同子类型。</p>
<ul>
<li><p>FixedThreadPool:<br>FixedThreadPool是使用固定线程数的线程池，适用于为了满足资源管理的需求，而需要限制当前线程数量的应用场景，适用于负载较重的服务器。<br><img src="/2019/12/24/Java-Concurrency-In-Depth/FixedThreadPool.jpg" alt="FixedThreadPool"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads, <span class="number">0L</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());<span class="comment">//无界队列</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads, ThreadFactory threadFactory)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>SingleThreadExecutor:<br>SingleThreadExecutor是单个线程的线程“池”，适用于需要保证顺序执行的各个任务，并且保证没有多个线程活动的应用场景。<br><img src="/2019/12/24/Java-Concurrency-In-Depth/SingleThreadExecutor.jpg" alt="SingleThreadExecutor"></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">SingleThreadExecutor</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// FinalizableDelegatedExecutorService 增加对gc时停掉线程池的功能</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService(<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0L</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">SingleThreadExecutor</span><span class="params">(ThreadFactory threadFactory)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>CachedThreadPool:<br>CachedThreadPool是大小无界的线程池，适用于执行多的短期异步任务的小程序，适合负载较轻的服务器。<br><img src="/2019/12/24/Java-Concurrency-In-Depth/CachedThreadPool.jpg" alt="CachedThreadPool"></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">CachedThreadPool</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE, <span class="number">60L</span>, TimeUnit.SECONDS,<span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());<span class="comment">//使用没有容量的工作队列，因为线程数没有限制。</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">CachedThreadPool</span><span class="params">(ThreadFactory threadFactory)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="ThreadPoolExecutor实现原理"><a href="#ThreadPoolExecutor实现原理" class="headerlink" title="ThreadPoolExecutor实现原理"></a>ThreadPoolExecutor实现原理</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Class ThreadPoolExecutor&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> corePool; <span class="comment">// 核心线程池大小，当前运行线程数少于此则创建新线程至预热完成。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maximumPool; <span class="comment">//最大线程池的大小，当前线程数不会超过此，多的任务会挂起在工作阻塞队列中。</span></span><br><span class="line">    <span class="keyword">private</span> BlockingQueue&lt;Runnable&gt; workQueue; <span class="comment">//保存任务的工作队列，只要队列不为空，空闲的线程会获取任务并执行，直到任务队列为空。</span></span><br><span class="line">    <span class="keyword">private</span> RejectedExecutionHandler handler; <span class="comment">// 工作队列饱和时调用的handler</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> keepAliveTime; <span class="comment">//空闲线程存活时间</span></span><br><span class="line">    <span class="keyword">private</span> TimeUnit unit; <span class="comment">//空闲时间单位</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ScheduledThreadPoolExecutor-调度线程池）框架实现原理"><a href="#ScheduledThreadPoolExecutor-调度线程池）框架实现原理" class="headerlink" title="ScheduledThreadPoolExecutor (调度线程池）框架实现原理"></a>ScheduledThreadPoolExecutor (调度线程池）框架实现原理</h2><p>调度线程池是线程池实现的扩展，主要在给定的延迟后运行任务，或者定期执行任务。<br>ScheduledThreadPoolExecutor有两种: ScheduledThreadPoolExecutor和SingleThreadScheduledExecutor。</p>
<ul>
<li><p>ScheduledThreadPoolExecutor:<br>ScheduledThreadPoolExecutor是固定个数线程的调度线程池，适用于需要多个后台线程执行周期任务，同时为了满足资源管理的需求而需要限制后台线程的数量的应用场景。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize, ThreadFactory threadFactory)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>SingleThreadScheduledExecutor:<br>SingleThreadScheduledExecutor是单个后台线程执行周期任务，同事需要保证顺序地执行各个任务的应用场景。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">SingleThreadScheduledExecutor</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">SingleThreadScheduledExecutor</span><span class="params">(ThreadFactory threadFactory)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="ScheduledThreadPoolExecutor实现原理"><a href="#ScheduledThreadPoolExecutor实现原理" class="headerlink" title="ScheduledThreadPoolExecutor实现原理"></a>ScheduledThreadPoolExecutor实现原理</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title">ThreadPoolExecutor</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> time; <span class="comment">// 任务要被执行的具体时间，当前时间大于等于time值时被执行</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> sequenceNumber; <span class="comment">// 任务被添加到Executor时的序号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> period; <span class="comment">// 任务执行的间隔周期</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>提交任务<br>ScheduledThreadPoolExecutor接受实现了RunnableScheduledFuture接口的ScheduledFutureTask实例。通过scheduleAtFixedRate()方法或者scheduleWithFixedDelay()方法提交，放在<code>DelayQueue&lt;RunnableScheduledFuture&gt;</code>中。<br><img src="/2019/12/24/Java-Concurrency-In-Depth/ScheduledTaskSubmission.jpg" alt="ScheduledTask"></p>
</li>
<li><p>执行任务<br>DelayQueue封装了一个PriorityQueue, 对队列中的ScheduledFutureTask进行排序，time小的排在前面。如果time值相同，则sequenceNumber小的在前面。</p>
</li>
<li><p>放回任务<br>对于执行过的周期任务，time值被重置为下一次的执行时间，并且将task放回DelayQueue中。</p>
</li>
</ol>
<h3 id="DelayQueue部分实现原理"><a href="#DelayQueue部分实现原理" class="headerlink" title="DelayQueue部分实现原理"></a>DelayQueue部分实现原理</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayQueue</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Delayed</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ReentrantLoc lock;</span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;E&gt; q;</span><br><span class="line">    <span class="keyword">private</span> Thread leader;</span><br><span class="line">    <span class="keyword">private</span> Condition available;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lockInterruptibly(); <span class="comment">// 处理队列需要获得锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">                E first = q.peek();<span class="comment">// 线程锁住等待直到有task出现</span></span><br><span class="line">                <span class="keyword">if</span>( first == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    available.await();</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">long</span> deplay = first.getDelay(TimeUnit.NANOSECONDS);</span><br><span class="line">                    <span class="keyword">if</span>(delay &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="keyword">long</span> tl = available.awaitNanos(delay); <span class="comment">// wait nanoseonds for task to be ready to execute.</span></span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        E x = q.poll(); <span class="comment">// when task is ready, take the task and do</span></span><br><span class="line">                        <span class="keyword">assert</span> x != <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">if</span>( q.size() != <span class="number">0</span>)</span><br><span class="line">                            available.signalAll(); <span class="comment">//release condition</span></span><br><span class="line">                        <span class="keyword">return</span> x;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">offer</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            E first = q.peek(); </span><br><span class="line">            q.offer(e); <span class="comment">// 拿到锁后放入这个queue</span></span><br><span class="line">            <span class="keyword">if</span>(first == <span class="keyword">null</span>) || e.compareTo(first) &lt; <span class="number">0</span>)</span><br><span class="line">                available.singalAll(); <span class="comment">// 检查task是否到期可以执行，如果ready触发take的线程。</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ForkJoinPool-框架实现原理"><a href="#ForkJoinPool-框架实现原理" class="headerlink" title="ForkJoinPool 框架实现原理"></a>ForkJoinPool 框架实现原理</h2><p>ForkJoinPool由ForkJoinTask数组和ForkJoinWorkerThread数组组成，前者用于存放程序提交的任务，ForkJoinWorkerThread数组负责执行任务。</p>
<p>算法执行分两段，fork阶段将任务分割到足够小，创建/唤醒一个工作线程执行；join阶段将任务的结果收集合并结果得到最后的结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinTask</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ForkJoinTask&lt;V&gt; <span class="title">fork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ((ForkJoinWorkerThread) Thread.currentThread()).pushTask(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">join</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(doJoin() != NORMAL)</span><br><span class="line">            <span class="keyword">return</span> reportResult();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> getRawResult();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> V <span class="title">reportResult</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s; Throwable ex;</span><br><span class="line">        <span class="keyword">if</span>((s = status) == CANCELLED)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> CancellationException();</span><br><span class="line">        <span class="keyword">if</span>(s == EXCEPTIONAL &amp;&amp; (ex = getThrowableException()) != <span class="keyword">null</span>)</span><br><span class="line">            UNSAFE.throwException(ex);</span><br><span class="line">        <span class="keyword">return</span> getRawResult();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">doJoin</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Thread t; ForkJoinWorkerTHread w; <span class="keyword">int</span> s; <span class="keyword">boolean</span> completed;</span><br><span class="line">        <span class="keyword">if</span>((t = Thread.currentThread()) <span class="keyword">instanceof</span> ForkJoinWorkThread) &#123;</span><br><span class="line">            <span class="keyword">if</span> (( s = STATUS)  &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> s;</span><br><span class="line">            <span class="keyword">if</span>( ((w = (ForkJoineWorkerThread)t).unpushTask(<span class="keyword">this</span>))) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    completed = exec();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable rex) &#123;</span><br><span class="line">                    <span class="keyword">return</span>  setExceptionalCompletion( rex);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(completed)</span><br><span class="line">                    <span class="keyword">return</span> setCompletion(NORMAL);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> w.joinTask(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> exeternalAwaitDone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinWorkerThread</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">pushTask</span><span class="params">(ForkJoinTask&lt;?&gt; t)</span> </span>&#123;</span><br><span class="line">        ForkJoinTask&lt;?&gt;[] q; <span class="keyword">int</span> s, m;</span><br><span class="line">        <span class="keyword">if</span>((q = quque) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> u = (((s = queueTop) &amp; (m = q.length - <span class="number">1</span>)) &lt;&lt; ASHIFT) + ABASE;</span><br><span class="line">            UNSAFE.putOrderObject(q, u, t);</span><br><span class="line">            queueTop = s + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> ((s -= queueBase) &lt;= <span class="number">2</span>)</span><br><span class="line">                pool.singalWork();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s == m)</span><br><span class="line">                growQuque();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="异步执行机制"><a href="#异步执行机制" class="headerlink" title="异步执行机制"></a>异步执行机制</h1><h2 id="FutureTask实现原理"><a href="#FutureTask实现原理" class="headerlink" title="FutureTask实现原理"></a>FutureTask实现原理</h2><p>FutureTask实现了Future, Runnable接口。是Executor的执行任务单元，也可以由调用线程直接执行FutureTask.run()。FutureTask的get方法能阻塞当前线程，等待任务执行结果再执行下文。</p>
<p>FutureTask通过内部聚合的AQS的子类实现完成FUtureTask的获取和释放操作。队列中的每个FutureTask实例的get方法并不以一定需要在run方法之前执行，get方法会阻塞调用线程直到run方法被执行完成。每个任务只会执行一次，并且会有定义好的执行顺序，从get方法调用线程恢复执行上下文，从而达到异步调用的效果。类似.NET中的beginInvoke和endInvoke方法。<br><img src="/2019/12/24/Java-Concurrency-In-Depth/FutureTask.jpg" alt="Future"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt;, <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Sync sync;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        Callable.call();</span><br><span class="line">        ...</span><br><span class="line">        AQS.compareAndSetState(<span class="keyword">int</span> expect, <span class="keyword">int</span> update);</span><br><span class="line">        ...</span><br><span class="line">        AQS.releaseShared(<span class="keyword">int</span> arg);</span><br><span class="line">        ...</span><br><span class="line">        FutureTask.done();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        AQS.acquireSharedInterruptily(<span class="keyword">int</span> arg);</span><br><span class="line">        ...</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> V <span class="title">innerGet</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">innerRun</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">innerCancel</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="CompletableFuture实现原理"><a href="#CompletableFuture实现原理" class="headerlink" title="CompletableFuture实现原理"></a>CompletableFuture实现原理</h2><p>CompletableFuture实现了Future，CompletionStage接口，后者接口增加了更多对任务流程的控制接口，可以直接通过接口实现回调函数的定义。</p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>肉肉</tag>
      </tags>
  </entry>
  <entry>
    <title>Java Concurrency</title>
    <url>/2018/12/12/Java-Concurrency/</url>
    <content><![CDATA[<h1 id="线程概念"><a href="#线程概念" class="headerlink" title="线程概念"></a>线程概念</h1><p>线程是一种轻量级的进程内的执行单元，线程共用进程中的内存地址空间，但是拥有自己的调用栈，寄存器，程序计数器和局部变量。线程状态如下：</p>
<p><img src="/2018/12/12/Java-Concurrency/ThreadStatus.jpg" alt="ThreadStatus"></p>
<ol>
<li>新建状态(New) : 线程对象被创建后，就进入了新建状态。例如，Thread thread = new Thread()。</li>
<li>就绪状态(Runnable): 也被称为“可执行状态”。线程对象被创建后，其它线程调用了该对象的start()方法，从而来启动该线程。例如，thread.start()。处于就绪状态的线程，随时可能被CPU调度执行。</li>
<li>运行状态(Running) : 线程获取CPU权限进行执行。需要注意的是，线程只能从就绪状态进入到运行状态。</li>
<li>阻塞状态(Blocked)  : 阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种：<ol>
<li>等待阻塞 – 通过调用线程的wait()方法，让线程等待某工作的完成。</li>
<li>同步阻塞 – 线程在获取synchronized同步锁失败(因为锁被其它线程所占用)，它会进入同步阻塞状态。</li>
<li>其他阻塞 – 通过调用线程的sleep()或join()或发出了I/O请求时，线程会进入到阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。</li>
</ol>
</li>
<li>死亡状态(Dead/Terminated)    : 线程执行完了或者因异常退出了run()方法，该线程结束生命周期。</li>
</ol>
<h1 id="多线程概念"><a href="#多线程概念" class="headerlink" title="多线程概念"></a>多线程概念</h1><p>多线程是利用线程并行和并发处理的优势提升程序性能的一种编程方法。</p>
<p>优点：</p>
<ol>
<li>可以使每个线程做自己的任务，代码上语义更明确</li>
<li>利用多核CPU的优势</li>
<li>可以把占据时间长如阻塞UI的任务放到后台处理从而保证界面/线程响应</li>
<li>可以提升CPU利用率，通过回调方式而不是阻塞方式处理IO操作</li>
</ol>
<p>缺点：</p>
<ol>
<li>线程安全问题（脏数据，死锁）</li>
<li>性能问题（活锁，饥饿，上下文切换开销）</li>
<li>线程本身需要更多的内存</li>
</ol>
<h1 id="线程管理的基本工具（及Executor框架）"><a href="#线程管理的基本工具（及Executor框架）" class="headerlink" title="线程管理的基本工具（及Executor框架）"></a>线程管理的基本工具（及Executor框架）</h1><h2 id="创建一个新线程"><a href="#创建一个新线程" class="headerlink" title="创建一个新线程"></a>创建一个新线程</h2><ol>
<li><p>Thread类是一个实体类，继承Thread类，重写RUN方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 也可以 public class MyThread extends Thread &#123;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Object o = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>;i++)&#123;</span><br><span class="line">            sychronized(o)&#123;</span><br><span class="line">                number++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>实现RUNABLE 接口，实例对象作为THREAD的构造函数的传参。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyThread());</span><br><span class="line">t.start();</span><br></pre></td></tr></table></figure>
</li>
<li><p>实现CALLABLE接口，通过FUTURETASK来创建</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="comment">//return the thread name executing this callable task</span></span><br><span class="line">        <span class="keyword">return</span> Thread.currentThread().getName();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    Callable&lt;String&gt; oneCallable = <span class="keyword">new</span> MyCallable();</span><br><span class="line">    FutureTask&lt;String&gt; oneTask = <span class="keyword">new</span> FutureTask&lt;String&gt;(oneCallable);</span><br><span class="line"></span><br><span class="line">    Thread t = <span class="keyword">new</span> Thread(oneTask);</span><br><span class="line">    System.out.println(Thead.currentThread().getName());</span><br><span class="line"></span><br><span class="line">    t.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li><p>通过线程池本身ThreadPoolExecutor进行task管理。线程池是一个功能强大的多线程工具，在每一个新的Runnable提交的时候，会有如下流程处理：<img src="/2018/12/12/Java-Concurrency/workflow.jpg" alt="Workflow"><br>在线程池处理task过程中，会需要如下参数控制流程：<img src="/2018/12/12/Java-Concurrency/Threadpool.jpg" alt="ThreadPool.jpg"></p>
</li>
<li><p>通过线程池工厂Executors生成<a href="https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ExecutorService.html" target="_blank" rel="noopener">ExecutorService</a>接口下的实例,创建并执行任务。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> POOL_NUM = <span class="number">5</span>;</span><br><span class="line"><span class="comment">// 通过 Executors 静态方法创建一个线程池</span></span><br><span class="line">ExecutorService es = Executors.newFixedThreadPool(POOL_NUM);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; POOL_NUM); i++) &#123;</span><br><span class="line">    es.execute(oneTask);</span><br><span class="line">    <span class="comment">//Future&lt;String&gt; anotherTask = es.submit(oneCallabe);也可以执行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//类似Task in c#</span></span><br><span class="line"><span class="keyword">while</span>(oneTask.isDone())&#123;</span><br><span class="line">    System.out.println(oneTask.get());</span><br><span class="line">&#125;</span><br><span class="line">es.shutdown();</span><br></pre></td></tr></table></figure>
<h2 id="通过Object方法控制线程并发"><a href="#通过Object方法控制线程并发" class="headerlink" title="通过Object方法控制线程并发"></a>通过Object方法控制线程并发</h2><p>wait/notify(wait(), await(), notify() notifyAll())是Object的方法，运用了实例本身的锁功能控制多线程的并发访问和修改问题。</p>
<pre><code>* wait的语义是释放当前拿到的锁，让本线程进入睡眠状态。
* notify的语义是通知其他线程唤醒，让原本是waiting状态的线程变成了blocked（同步块中释放锁，重新等待拿锁恢复同步块内代码wait()后继续执行）。
</code></pre><p>一般的应用场景是，wait释放锁，notify别的线程来拿锁，并唤醒继续执行。这些方法必须在已经获得锁的同步块中书写，否则会抛出illeagalmonitorStateException。这属于线程的基本工具，一般推荐使用已有的并发框架，而非此类方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// the standard idiom for using the wait method</span></span><br><span class="line">synchonized(o)&#123;</span><br><span class="line">    <span class="comment">// 防止线程被无意唤醒，需要while loop保证代码安全</span></span><br><span class="line">    <span class="keyword">while</span>(!condition)&#123;</span><br><span class="line">        o.wait();</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">        <span class="comment">// notifyAll能保证需要被唤醒的线程的活性。如果都在等待同一个条件，可以用notify()</span></span><br><span class="line">        o.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// do something when condition is fulfilled.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="线程调度器Scheduler"><a href="#线程调度器Scheduler" class="headerlink" title="线程调度器Scheduler"></a>线程调度器Scheduler</h2><ol>
<li>static Thread.yeild()：可以让步出当前线程的优先级，让其他同优先级的线程先跑。</li>
<li><p>Thread.join(): 当前线程等待一个线程t（join的实例）完成后再继续执行。类似于</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">    <span class="comment">// if t is alive, keep waiting</span></span><br><span class="line">    <span class="keyword">while</span>(isAlive())&#123;</span><br><span class="line">        wait();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// continue current thread</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>static Thread.sleep(): 保持拿锁，线程睡眠一定时间。与wait()不同之处在于前者锁并没有释放。</p>
</li>
<li>Thread.interrupt(): 调用中断的线程去中断别的线程，被中断的线程如果处于等待/睡眠状态，会抛出InterrupException，如果处于阻塞于IO状态，会抛出ClosedByInterruptException，并且连接中断，如果阻塞与selector，则会出发selector’s wakeup方法，并且状态Thread.interrupted()变成true。其他情况，直接Thread.isInterrupted()/static Thread.interrupted()变成true。在异常处理完毕后，线程的中断标志位会复位，从而允许再一次中断。</li>
<li>Deprecated方法有suspend(),resume()，stop()能让线程暂停,恢复运行和完全停止。需要留意的是线程被suspend和stop并不会释放线程已经拿到的锁，所以不是一个很好的终止线程的方法，而中断则可以在异常捕捉处理好锁释放，资源释放的逻辑。</li>
</ol>
<h2 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h2><ol>
<li><p>volatile, synchronized（略）</p>
</li>
<li><p>wait/notify(略)</p>
</li>
<li><p>pipewriter/pipereader：将管道的输出连接到其他线程的输入从而达到通信目的。</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Piped</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        PipedWriter out = <span class="keyword">new</span> PipedWriter();</span><br><span class="line">        PipedReader in = <span class="keyword">new</span> PipedReader();</span><br><span class="line">        <span class="comment">//连接</span></span><br><span class="line">        out.connect(in);</span><br><span class="line"></span><br><span class="line">        Thread printThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Print(in), <span class="string">"PrintThread"</span>);</span><br><span class="line">        printThread.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> receive = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>((receive = System.in.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">                out.write(receive);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">            out.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Print</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> PipedReader in;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Print</span><span class="params">(PipedReader in)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.in = in;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">int</span> receive = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">while</span>((receive = in.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">                    System.out.print((<span class="keyword">char</span>) receive);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">catch</span>(IOException ex)&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>join（略）</p>
</li>
<li><p>ThreadLocal: ThreadLocal集合类型可以为线程提供局部变量，在多线程场景下，保证线程自由变量的安全。常用于AOP代码，例如计时器。</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Profiler</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Long&gt; TIME_THREADLOCAL = <span class="keyword">new</span> ThreadLocal&lt;Long&gt;()&#123;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Long <span class="title">initialValue</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> System.currentTimeMillis();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">begin</span><span class="params">()</span></span>&#123;</span><br><span class="line">        TIME_THREADLOCAL.set(Stystem.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">end</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> System.currentTimeMillis() - TIME_THREADLOCAL.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Profiler.begin();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">"Cost: "</span> + Profiler.end() + <span class="string">" mills"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Exchanger类: Exchanger是一个用于线程间协作的工具类。Exchanger创建了一个同步点，当两个线程都到达同步点时，数据进行交换。应用场景如下：</p>
</li>
</ol>
<ul>
<li>遗传算法（1/2基因数据交换)</li>
<li><p>校对工作（AB岗两人进行录入对稿）</p>
<p>  Exchanger使用示例：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExchangerTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Exchanger&lt;String&gt; exgr = <span class="keyword">new</span> Exchanger&lt;String&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        threadPool.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    String A = <span class="string">"流水数据A"</span>;</span><br><span class="line">                    <span class="comment">//A录入银行流水数据</span></span><br><span class="line">                    exgr.exchange(A);</span><br><span class="line">                &#125;<span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        threadPool.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    String B = <span class="string">"流水数据B"</span>;</span><br><span class="line">                    <span class="comment">//B录入银行流水</span></span><br><span class="line">                    String A = exgr.exchange(B);</span><br><span class="line">                    System.out.println(<span class="string">"A和B数据是否一致："</span> + A.equals(B));</span><br><span class="line">                &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="线程上下文管理工具"><a href="#线程上下文管理工具" class="headerlink" title="线程上下文管理工具"></a>线程上下文管理工具</h2><ol>
<li><p>Executor框架</p>
<p> Executor框架定义了各个Task在线程池/单线程执行的上下文。Developer可以自己实现Executor框架来自定义Task执行上下文。Executor支持的线程池框架有ThreadPoolExecutor和ScheduleThreadPoolExecutor，主要负责处理相对独立的任务。</p>
<p> 在新线程执行</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPerTask</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">( Runnable task)</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(task).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 在同一个线程执行</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InThreadTask</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">( Runnable task)</span></span>&#123;</span><br><span class="line">        task.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> ExecutorService接口扩展了Executor接口，支持更加多的接口去控制executor的周期。当ExecutorService被shutdown()后，不再接受submit(),当其执行完所有task后，就终止。</p>
<ul>
<li>Running ===&gt;</li>
<li>Shutting down ===&gt;</li>
<li><p>Terminated</p>
</li>
<li><p>CoompletionService</p>
<p>Executor和BlockingQueue的组合。</p>
</li>
</ul>
</li>
<li><p>Fork/Join框架</p>
<p> Fork/Join框架适合大量task并发执行,由于task可以在不同的线程进行根据空闲程度自由调度，所以具有特定的执行设计场景（一般是只读场景）:</p>
<ol>
<li>归并排序</li>
<li>map/reduce</li>
<li><p>递归多线程计算</p>
<p>ForkJoinPool线程池是Fork/Join执行框架的线程池，也是Executor框架的一种。也是CompletableFuture的底层线程池实现。</p>
<p>Fork/Join使用示例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THRESHOLD = <span class="number">2</span>; <span class="comment">//阈值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> start;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> end;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CountTask</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Integer <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果任务足够小就计算任务</span></span><br><span class="line">        <span class="keyword">boolean</span> canCompute = (end - start) &lt;= THRESHOLD;</span><br><span class="line">        <span class="keyword">if</span> ( canCompute) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果任务大于阈值，就分裂成两个子任务计算</span></span><br><span class="line">            <span class="keyword">int</span> middle = (start + end) / <span class="number">2</span>;</span><br><span class="line">            CountTask leftTask = <span class="keyword">new</span> CountTask(start, middle);</span><br><span class="line">            CountTask rightTask = <span class="keyword">new</span> CountTask(middle + <span class="number">1</span>, end);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//执行子任务</span></span><br><span class="line">            leftTask.fork();</span><br><span class="line">            rightTask.fork();</span><br><span class="line">            <span class="comment">//等待子任务执行完，并取到结果</span></span><br><span class="line">            <span class="keyword">int</span> leftResult = leftTask.join();</span><br><span class="line">            <span class="keyword">int</span> rightResult = rightTask.join();</span><br><span class="line">            <span class="comment">//合并结果</span></span><br><span class="line">            sum = leftResult + rightResult;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        ForkJoinPool forkJoinPool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">        <span class="comment">//生成一个计算任务，负责计算1+2+3+4</span></span><br><span class="line">        CountTask task = <span class="keyword">new</span> CountTask(<span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line">        <span class="comment">//执行任务</span></span><br><span class="line">        Future&lt;Integer&gt; result = forkJoinPool.submit(task);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//检查task执行结果</span></span><br><span class="line">            <span class="keyword">if</span>(task.isCompletedAbnormally()) &#123;</span><br><span class="line">                System.out.println(task.getException());</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(result.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>BlockingQueue阻塞队列</p>
</li>
</ol>
<p>提供两个可以阻塞当前线程的方法扩展Queue的操作，常用于生产者和消费者场景。</p>
<ul>
<li>take() 移除元素，当队列为空时，获取元素的线程会等待队列变为非空。</li>
<li>put() 增加元素，当队列满的时候，队列会阻塞插入元素的线程，直到队列不满。</li>
</ul>
<p><img src="/2018/12/12/Java-Concurrency/BlockingQueue.png" alt="BlockingQueues"></p>
<p>阻塞队列支持四种处理方式，如上图所示，包含7个阻塞队列：</p>
<ol>
<li>ArrayBlockingQueue, 由数组结构组成的有界阻塞队列。</li>
<li>LinkedBlockingQueue, 由链表结构组成的有界阻塞队列。</li>
<li>PriorityBlockingQueue, 支持优先级排序的无界阻塞队列。</li>
<li>SynchronousQueue，一个不存储元素的阻塞队列。</li>
<li>DelayQueue, 使用优先级队列实现的无界阻塞队列。</li>
<li>LinkedTransferQueue, 链表结构组成的无界阻塞队列。</li>
<li>LinkedBlockingDeque, 链表结构组成的双向阻塞队列。</li>
</ol>
<h2 id="线程同步器Synchronizer"><a href="#线程同步器Synchronizer" class="headerlink" title="线程同步器Synchronizer"></a>线程同步器Synchronizer</h2><p>同步器是使线程能够等待另一个线程，允许他们协调动作的工具类。</p>
<ol>
<li>信号量Semaphore</li>
</ol>
<p>信号量是用来控制同时访问特定资源的线程数量的锁，某个时候只能由n个线程同时访问该同步资源，n=1时候信号量和简单互斥锁一样。</p>
<ol start="2">
<li>CountDownLatch</li>
</ol>
<p>CountDownLatch允许一个或多个线程等待其他线程完成操作。当这n个线程都完成时，当前等待线程再执行, CountDownLatch内部的计数器不能重置。</p>
<ol start="3">
<li>CyclicBarrier</li>
</ol>
<p>CyclicBarrier，让一组线程到达一个同步点后再一起继续运行，在其中任意一个线程未达到同步点，其他到达的线程均会被阻塞。</p>
<ol start="4">
<li>Phaser</li>
</ol>
<p>Phaser可以理解为CyclicBarrier的更复杂应用，通过控制每个阶段的锁来控制线程行为。Phaser在n个线程完成一个阶段后才进入下一个多线程阶段。</p>
<ol start="5">
<li>Condition 类</li>
</ol>
<p>Condition类提供了wait(), notify(), notifyAll()接口方法，可以灵活制定锁的行为，同时避免了锁和object的一对一对应关系。condition.wait()释放锁等待，condition.signal()唤醒等待的线程（需要尽快释放锁保证notify成功)。Condition类是BlockingQueue实现的关键类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoundedBuffer</span> </span>&#123;</span><br><span class="line">   <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">   <span class="keyword">final</span> Condition notFull  = lock.newCondition(); </span><br><span class="line">   <span class="keyword">final</span> Condition notEmpty = lock.newCondition(); </span><br><span class="line"></span><br><span class="line">   <span class="keyword">final</span> Object[] items = <span class="keyword">new</span> Object[<span class="number">100</span>];</span><br><span class="line">   <span class="keyword">int</span> putptr, takeptr, count;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Object x)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">     lock.lock();</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="keyword">while</span> (count == items.length)</span><br><span class="line">         notFull.await();</span><br><span class="line">       items[putptr] = x;</span><br><span class="line">       <span class="keyword">if</span> (++putptr == items.length) putptr = <span class="number">0</span>;</span><br><span class="line">       ++count;</span><br><span class="line">       notEmpty.signal();</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">       lock.unlock();</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">     lock.lock();</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">         notEmpty.await();</span><br><span class="line">       Object x = items[takeptr];</span><br><span class="line">       <span class="keyword">if</span> (++takeptr == items.length) takeptr = <span class="number">0</span>;</span><br><span class="line">       --count;</span><br><span class="line">       notFull.signal();</span><br><span class="line">       <span class="keyword">return</span> x;</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">       lock.unlock();</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<ol start="6">
<li>LockSupport 类<br>LockSupport定义了一组公共静态方法，是一个基础工具，提供了线程阻塞和唤醒功能。</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:left">方法名</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">park()</td>
<td style="text-align:center">阻塞当前线程，如果调用unpark()，park()才会返回</td>
</tr>
<tr>
<td style="text-align:left">parkNanos(long nanos</td>
<td style="text-align:center">阻塞当前线程不超过nanos秒</td>
</tr>
<tr>
<td style="text-align:left">parkUntil(long deadline)</td>
<td style="text-align:center">阻塞当前线程，直到deadline时间</td>
</tr>
<tr>
<td style="text-align:left">unpark(Thread t)</td>
<td style="text-align:center">唤醒处于阻塞状态的线程t</td>
</tr>
</tbody>
</table>
<h1 id="多线程问题"><a href="#多线程问题" class="headerlink" title="多线程问题"></a><strong>多线程问题</strong></h1><ol>
<li>数据访问问题（读写）</li>
<li>资源生产与消费问题（生产者-消费者模式）&lt;= 常用来解决数据的强耦合问题</li>
</ol>
<p>下文会展开描述这两类问题。</p>
<h2 id="多线程数据读写访问问题（同步-并发问题）"><a href="#多线程数据读写访问问题（同步-并发问题）" class="headerlink" title="多线程数据读写访问问题（同步/并发问题）"></a>多线程数据读写访问问题（同步/并发问题）</h2><p>由于多线程情况下JVM的内存模型，实际上是存在主内存和工作内存之间的同步问题。读写操作实际上是read-load, store-write操作，在多线程并发时，操作的并发会导致主内存和工作内存某变量值的不同步问题。</p>
<h3 id="synchronized-关键字"><a href="#synchronized-关键字" class="headerlink" title="synchronized 关键字"></a>synchronized 关键字</h3><p>synchronized可以在三个地方使用，一种是在方法体内部，可以进行instance level或者class level(通过synchronized(AccountSync.Class))进行锁定。最后一种是在一个代码块进行锁定，可以指定拿锁的object。</p>
<ul>
<li><p>当synchronized锁定在（静态）方法级别，所有（静态）method只能有一个method被线程调用，其他线程需要等待。同一个线程可重入synchronized区块/方法。</p>
</li>
<li><p>当synchronized锁定在instance级别时，取决于instance的状态，所有需要拿该instance的线程需要等待。也就是说，即使是同一个instance的不同的synchronized method，在某时刻，只能有一个线程访问其中某个synchronized method。</p>
</li>
<li><p>当synchronized锁定在block级别是，需要制定block的owner，即一个object，只有拿到了该object的锁，才能执行相应的block。只是比较推荐的方法，因为可以最小化同步块，同时也能避免基类方法和父类方法的访问造成的“互相绊住脚”的行为。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountSync</span> </span>&#123;</span><br><span class="line">    Object o = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [])</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(o)&#123;</span><br><span class="line">            <span class="comment">//synchronized block </span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">myMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// lock class level access</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><p><a href="https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/locks/Lock.html" target="_blank" rel="noopener">Lock</a>是java的一个interface，所有实现了该接口的类型都具有锁的特质。</p>
<ol>
<li><p>不可重入锁（简单锁）<br>Java底层为每个object提供了mutex，没有拿到锁的线程需要忙等待，没有优先级控制。<br>简单锁本身在java内部没有直接的实现，可以通过Semaphore计数值为1来实现。</p>
</li>
<li><p>可重入锁<a href="https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/locks/ReentrantLock.html" target="_blank" rel="noopener">ReentrantLock</a><br>同一个线程可以重复进入该锁（不会因为同步代码自己调用自己而被死锁）</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Lock l = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">l.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// must in finally 解锁。</span></span><br><span class="line">    l.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>读写锁<br>读写锁是两个锁，分别对应<br><a href="https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/locks/ReentrantReadWriteLock.ReadLock.html" target="_blank" rel="noopener">ReentrantReadWriteLock.ReadLock</a>,<a href="https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/locks/ReentrantReadWriteLock.WriteLock.html" target="_blank" rel="noopener">ReentrantReadWriteLock.WriteLock</a>。</li>
</ol>
<p>读锁，没有线程hold写锁的时候，写锁可以给出，或者读锁可以给多线程访问。<br>写锁，没有线程hold读锁和写锁的时候，读锁可以给出，一旦写锁先被hold，读锁是不允许再被hold。</p>
<p>读写锁的特性如下：</p>
<p><img src="/2018/12/12/Java-Concurrency/RWLock.png" alt="RWLock.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWriteMap</span></span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Map&lt;String, Data&gt; m = <span class="keyword">new</span> TreeMap&lt;String, Data&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ReentrantReadWriteLock rw1 = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">    <span class="keyword">final</span> Lock r = rw1.readLock();</span><br><span class="line">    <span class="keyword">final</span> Lock w = rw1.writeLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Data <span class="title">get</span> <span class="params">(String key)</span></span>&#123;</span><br><span class="line">        r.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> m.get(key)</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123; r.unlock();&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Data <span class="title">put</span> <span class="params">(String key, Data value)</span></span>&#123;</span><br><span class="line">        w.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> m.put(key, value);</span><br><span class="line">        &#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">            w.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="并发集合Concurrent-collection"><a href="#并发集合Concurrent-collection" class="headerlink" title="并发集合Concurrent collection"></a>并发集合Concurrent collection</h3><ol>
<li>ConcurrentHashMap</li>
</ol>
<blockquote>
<p><a href="https://www.cnblogs.com/ITtangtang/p/3948786.html" target="_blank" rel="noopener">https://www.cnblogs.com/ITtangtang/p/3948786.html</a></p>
</blockquote>
<p>HashMap并发问题：</p>
<blockquote>
<p> HashTable容器使用synchronized来保证线程安全，但在线程竞争激烈的情况下HashTable的效率非常低下。因为当一个线程访问HashTable的同步方法时，其他线程访问HashTable的同步方法时，可能会进入阻塞或轮询状态。如线程1使用put进行添加元素，线程2不但不能使用put方法添加元素，并且也不能使用get方法来获取元素，所以竞争越激烈效率越低。</p>
</blockquote>
<p>ConcurrentHashMap解决并发问题:</p>
<blockquote>
<p>ConcurrentHashMap所使用的锁分段技术，首先将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。有些方法需要跨段，比如size()和containsValue()，它们可能需要锁定整个表而而不仅仅是某个段，这需要按顺序锁定所有段，操作完毕后，又按顺序释放所有段的锁。这里“按顺序”是很重要的，否则极有可能出现死锁，在ConcurrentHashMap内部，段数组是final的，并且其成员变量实际上也是final的，但是，仅仅是将数组声明为final的并不保证数组成员也是final的，这需要实现上的保证。这可以确保不会出现死锁，因为获得锁的顺序是固定的。</p>
</blockquote>
<p>ConcurrentHashMap的使用和HashMap相同，API如下:</p>
<pre><code>|API名|操作含义|
|:---|:---:|
|get()|拿key对应的value|
|put()|放元素V|
|size()|获取大小|
|remove()|删除元素|
|putIfAbsent()|存放元素如果没有|
</code></pre><ol start="2">
<li>ConcurrentLinkedQueue<br>线程安全队列有两种实现方式，一种是阻塞算法加锁，另一种是使用循环CAS的方式。ConcurrentLinkedQueue采用的是后者，基于链接节点的无界限线程安全队列。</li>
</ol>
<p>offer()是入队，将节点添加到队尾。<br>poll()是出队，将首节点拿出。</p>
<p><strong>减少死锁优化</strong></p>
<ul>
<li>减少锁的持有时间（同步方法改同步块）</li>
<li>减少锁的粒度（CONCURRENT HASHMAP）</li>
<li>锁分离（读写锁，读锁写锁）（LinkedBlockingQueue，PUT一把锁，锁尾巴，TAKE一把锁锁头）</li>
</ul>
<h3 id="无锁并发工具"><a href="#无锁并发工具" class="headerlink" title="无锁并发工具"></a>无锁并发工具</h3><p>在多核操作系统中，Java提供了很多无锁并发工具。没有需要加锁的需要，避免了developer自己处理线程的阻塞行为，减少这部分开销。原来某些需要锁的场景，通过限制计算机指令执行和强制线程内部缓存失效，可以达到并发读写的需求，而不需要用锁来控制线程访问。</p>
<ol>
<li>volatile 关键字</li>
</ol>
<p>volatile的读写，可以看作是一个锁，对该变量的读写操作进行了同步。概括的说，保证内存可见性，防止指令重排序。</p>
<ol start="2">
<li>final 关键字</li>
</ol>
<p>凡是对成员变量或者本地变量(在方法中的或者代码块中的变量称为本地变量)声明为final的都叫作final变量。final变量经常和static关键字一起使用，作为常量。final变量能保证其初始化的同步操作。</p>
<ol start="3">
<li>原子操作</li>
</ol>
<p>原子操作是指不受多线程影响的最基本单元操作，可以保证同步。<br>Java在JVM层面也支持了同步，lock-free操作，利用CAS无所算法和乐观锁假设(仅在修改数据时候检查锁状态，适合并发修改比较少的情况)。底层是基于读写锁实现。</p>
<blockquote>
<p>CAS是利用CPU的CAS指令，同时借助JNI来完成Java的非阻塞算法,实现原子操作。是直接调用CPU 的cmpxchg（是汇编指令）指令。</p>
</blockquote>
<blockquote>
<p>CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。</p>
</blockquote>
<p>下列操作为原子操作：</p>
<ol>
<li>all assignment of primitive types except for long and double. （并不是说primitive types的所有操作都是原子操作）</li>
<li>all assignment of references</li>
<li>all operations of Java.Concurrent.Atomic.* classes</li>
<li>all assignments to volatile longs and doubles</li>
</ol>
<p><strong>原子类型by Java</strong></p>
<p>java.util.concurrent.atomic包提供了primitive类型的atomic类，它们可以自动的保证对于他们的操作是原子的并且不需要使用同步。但是使用方法和primitive类型完全不同，atomic类型里提供了各种操作方法保证方法/方法流执行的原子性。</p>
<ul>
<li>AtomicBoolean，AtomicInteger，AtomicLong，AtomicReference</li>
</ul>
<p>通过原子的方式更新数组里的某个元素，Atomic包提供了以3类</p>
<ul>
<li>AtomicIntegerArray，AtomicLongArray,AtomicReferenceArray</li>
</ul>
<p>如果需原子地更新某个类里的某个字段时，就需要使用原子更新字段类，Atomic包提供了以下3个类进行原子字段更新。</p>
<ul>
<li>AtomicLongFieldUpdater，AtomicIntegerFieldUpdater，AtomicReferenceFieldUpdater</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicIntegerFieldUpdaterTest</span> </span>&#123; </span><br><span class="line">    <span class="comment">// 创建原子更新器,并设置需要更新的对象类和对象的属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicIntegerFieldUpdater&lt;User&gt; a = </span><br><span class="line">            AtomicIntegerFieldUpdater.newUpdater(User.class, <span class="string">"old"</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;  </span><br><span class="line">        <span class="comment">// 设置柯南的年龄是10岁</span></span><br><span class="line">        User conan = <span class="keyword">new</span> User(<span class="string">"conan"</span>, <span class="number">10</span>);</span><br><span class="line">        <span class="comment">// 柯南长了一岁，但是仍然会输出旧的年龄</span></span><br><span class="line">        System.out.println(a.getAndIncrement(conan));</span><br><span class="line">        <span class="comment">// 输出柯南现在的年龄</span></span><br><span class="line">        System.out.println(a.get(conan));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">int</span> old;</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name, <span class="keyword">int</span> old)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">            <span class="keyword">this</span>.old = old;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOld</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> old;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="多线程的资源生产与消费问题"><a href="#多线程的资源生产与消费问题" class="headerlink" title="多线程的资源生产与消费问题"></a>多线程的资源生产与消费问题</h2><p>Java的Vector容器实际上是线程安全的数据结构，也就是说Vector的各个操作都能保证其原子性，但是也会存在多线程问题。这是因为在Vector的删除和添加操作中，如果存在多线程并发，删除操作的对象是可能是一个空Vector容器，造成问题。Developer需要有很好的上下文控制来避免这种生产消费问题。</p>
<h3 id="多线程管理工具"><a href="#多线程管理工具" class="headerlink" title="多线程管理工具"></a>多线程管理工具</h3><h4 id="Object方法"><a href="#Object方法" class="headerlink" title="Object方法"></a><a href="#通过Object方法控制线程并发">Object方法</a></h4><h4 id="线程调度器"><a href="#线程调度器" class="headerlink" title="线程调度器"></a><a href="#线程调度器Scheduler">线程调度器</a></h4><h4 id="线程同步器"><a href="#线程同步器" class="headerlink" title="线程同步器"></a><a href="#线程同步器Synchronizer">线程同步器</a></h4><h4 id="线程上下文管理工具-1"><a href="#线程上下文管理工具-1" class="headerlink" title="线程上下文管理工具"></a><a href="#线程上下文管理工具">线程上下文管理工具</a></h4><h1 id="题外话：C-多线程工具"><a href="#题外话：C-多线程工具" class="headerlink" title="题外话：C#多线程工具"></a>题外话：C#多线程工具</h1><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>肉肉</tag>
        <tag>Java</tag>
      </tags>
  </entry>
</search>
